# 모던 자바스크립트 Deep Dive(21 ~ )

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 21장 빌트인 객체

### 21.1 자바스크립트 객체의 분류

- 표준 빌트인 객체

  표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공한다. 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.

- 호스트 객체

  호스트 객체는 ECMAScript 사양에 정의디어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체를 말한다.

- 사용자 정의 객체

  사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.



### 21.2 표준 빌트인 객체

자바스크립트는 40여 개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 ㅔ서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.

```js
const strObj = new String('Lee');

// String 생성자 함수를 통해 생성한 strObj의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype);	// true
```



### 21.3 원시값과 래퍼 객체

원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?

```js
const str = 'hello';

// 원시값이 객체처럼 작동한다
console.log(str.length);
console.log(str.toUpperCase());
```

위 예제를 보면 원시값이 객체처럼 작동하는 것을 볼 수 있다. 이것이 가능한 이유는 자바스크트 엔진이 원시값에 대해 객체처럼 접근하면 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 이처럼 **문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.**

```js
const str = 'hi';

// String 인스턴스로 변환된다.
console.log(str.length);
console.log(str.toUpperCase());

// 끝나면 다시 원시값으로 되돌린다.
console.log(typeof str);	// string
```

래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. 다른 값들도 마찬가지로 작동한다.

```js
const num = 1.5;

console.log(num.toFixed());	// 2

console.log(typeof num, num);	// number 1.5
```

문자열, 숫자, 불리언, 심벌 이외의 원시값인 null과 undefined는 래퍼 객체를 생성하지 않는다.



### 21.4 전역 객체

전역 객체는 콛가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다. 브라우저에서는 window가 전역 객체를 가리키고, Node.js 환경에서는 global이 전역 객체를 가리킨다.

전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체다.

전역 객체의 특징은 다음과 같다.

- 전역 객체는 개발자가 의도적으로 생성할 수 없다.

- 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.

  ```js
  window.parseInt('F', 16);	// 15
  
  // window.parseInt는 parseInt로 호출할 수 있다.
  parseInt('F', 16);
  
  window.parseInt === parseInt;
  ```

- 전역 객체는 Object, String, Number, Boolean, Function 등과 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.

- 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.

- var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.

  ```js
  var foo = 1;
  console.log(window.foo);
  
  bar = 2;
  console.log(window.bar);
  
  function baz() {return 3;}
  console.log(window.baz());
  ```

- let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let이나 const 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록내에 존재하게 된다.

  ```js
  let foo = 123;
  console.log(window.foo);	//	 undefined
  ```

- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리해도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미다.



#### 21.4.1 빌트인 전역 프로퍼티

빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

##### Infinity

무한대를 나타내는 숫자값 Infinity를 갖는다.

```js
console.log(window.Infinity === Infinity);
```



##### NaN

NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.



##### undefined

undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.



#### 21.4.2 빌트인 전역 함수

##### eval

eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 받는다. 전달받은 문자열 코드가 표현식이라면 eval 함수는 문자열 코드를 런타임에 평가하여 값을 생성하고, 전달받은 인수가 표현식이 아닌 문이라면 eval 함수는 문자열 코드를 런타임에 실행한다. 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한다.

```js
/**
 * 주어진 문자열 코드를 런타임에 평가 또는 실행한다.
 * @param {string} code - 코드를 나타내는 문자열
 * @returns {*} 문자열 코드를 평가/실행한 결과값
 */
eval(code)
```

**eval 함수는 기존의 스코프를 런타임에 동적으로 수정한다.**

```js
const x = 1;

function foo() {
    eval('var x = 2');
    console.log(x);	// 2
}

foo();
console.log(x);	// 1
```

단, strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.

```js
const x = 1;

function foo() {
	'use strict';
    
    eval('var x = 2; console.log(x);');	// 2
    console.log(x);	// 1
}

foo()
console.log(x);	// 1
```

또한 인수로 전달받은 문자열 코드가 let, const 키워드를 사용한 변수 선언문이라면 암묵적으로 strict mode가 적용된다.

eval함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최저고하가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느리다. 따라서 **eval 함수의 사용은 금지해야 한다.**



##### isFinite

전달받은 인수가 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 변환한다.

```js
isFinite(0);	// true
isFinite(2e64);	// true
isFinite('10');	// true
isFinite(null);	// true

// 인수가 무한수 또는 NaN으로 평가되는 값이라면 false
isFinite(Infinity);	// false
isFinite(-Infinity);// false
isFinite('Hello');	// false
isFinite(NaN);		// false
```



##### isNaN

전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.

```js
isNaN(NaN);	// true
isNaN(10);	// false

isNaN('blabla');	// true
isNaN('10');		// false
isNaN('');			// false
isNaN(' ');			// false

isNaN(undefined);	// true
isNaN({});			// true

isNaN(new Date());	// false
isNaN(new Date().toString());	// true
```



##### parseFloat

전달받은 문자열 인수를 부동 소수점 숫자로 해석하여 반환한다.

```js
parseFloat('3.14');	// 3.14
parseFloat('10.00');// 10

// 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
parseFloat('34 56 66');	// 34
parseFloat('40 years');	// 40

// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.
parseFloat('He was 40');	// NaN

// 앞뒤 공백은 무시된다.
parseFloat(' 60 ');	// 60
```

##### parseInt

전달받은 문자열 인수를 정수로 해석하여 반한한다.

```js
parseInt('10');	// 10
parseInt('10.123');	// 10

// 두 번째 인수로 진법을 나타내는 기수를 전달할 수 있다.
// 10을 10진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10');	// 10
// 10을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 2);	// 2
// 10을 8진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 8);	// 8
// 10을 16진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 16);	// 16

// 문자열의 첫 번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다.
parseInt('A0');	// NaN
parseInt('20', 2);	// NaN

// 문자열의 두 번째 이후부터 해당 지수의 숫자로 변환될 수 없다면 이후 문자들은 무시된다.
parseInt('1A0');	// 1
parseInt('102', 2);	// 2

// parseFloat과 같이 공백으로 나누어져 있으면 첫 번째 문재열만 변환한다.
// parseFloat과 같이 첫 번째 문자열을 변환활 수 없다면 NaN을 반환한다.
// parseFloat과 같이 앞뒤 공백은 무시된다.
```



##### encodeURI / decodeURI

encodeURI 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.

```js
// 완전한 URI
const uri = 'http://example.com?name=아무개&job=programmer&teacher';

const enc = encodeURI(uri);
console.log(enc);
// http://example.com?name=인코딩된부분&job=programmer&teacher
```

decodeURI 함수는 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩한다

```js
// 위 예제의 enc 사용
const dec = decodeURI(enc);
console.log(dec);
// http://example.com?name=아무개&job=programmer&teacher
```



##### encodeURIComponent / decodeURIComponent

encodeURIComponent 함수는 URI 구성 요소를 인수로 전달받아 인코딩한다. 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.

encodeURIComponent 함수는 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주한다. 따라서 =, ?, &까지 인코딩한다.

```js
const uriComp = 'name=아무개&job=programmer&teacher'

let enc = encodeURIComponent(uriComp);
console.log(enc);
// name인코오오오오ㅗ디ㅣ이이이잉job인코딩programmer인코딩teacher

let dec = decodeURIComponent(enc);
console.log(dec);
// 아무개&job=programmer&teacher
```



#### 21.4.3 암묵적 전역

자바스크립트 엔진은 스코프에서 찾을 수 없는 변수를 전역 객체에 프로퍼티로 동적 생성하여 추가하기 때문에 전역변수처럼 접근할 수 있다. 이것을 **암묵적 전역**이라 한다.

```js
var x = 10;

function foo () {
    y = 20;	// window.y = 20
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y);	// 30
```

또한 변수가 아니라 프로퍼티이기 때문에 y는 delete 연산자로 삭제할 수 있다.



## 22장 this

### 22.1 this 키워드

객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조다. 동작을 나타내는 메서드는 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 한다. 이때 메서드가 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.

```js
const circle = {
    radius: 5,
    getDiameter(){
        // 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면
        // 자신이 속한 객체인 circle을 참조할 수 있어야 한다.
        return 2 * circle.radius;
    }
};

console.log(circle.getDiameter());	// 10
```

위 예제에서 getDiameter 메서드 내에서 자신이 속한 객체를 가리키는 식별자 circle을 사용하고 있다. 이 참조 표현식이 평가되는 시점은 getDiameter 메서드가 호출되어 몸체가 실행되는 시점이다.

위 예제의 객체 리터럴은 circle 변수에 할당되기 직전에 평가된다. 따라서 getDiameter가 호출되는 시점에는 이미 객체 리터럴이 평가된 후이니 getDiameter는 circle을 참조할 수 있다.

하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다. 생성자 함수 방식을 생각해보자

```js
function Cirle(radius){
	// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    ????.radius = radius;
}

Circle.prototype.getDiameter = function(){
    // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    return 2 * ????.radius;
};

// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.
const circle = new Circle(5);
```

생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 자신을 가리킬 특별한 식별자가 필요한데, 이를 위해 자바스크립트는 this라는 특수한 식별자를 제공한다.

**this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.**

this는 자바스크립트에 의해 암묵적으로 생성된다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, **this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.**

```js
const circle = {
	radius: 5,
	getDiameter(){
        return 2 * this.radius;
    }
};

console.log(circle.getDiameter());	// 10

function Circle(radius){
    this.radius = radius;
}

Circle.prototype.getDiameter = function(){
    return 2 * this.radius;
};

const circle1 = new Circle(5);
console.log(circle1.getDiameter());	// 10
```



### 22.2 함수 호출 방식과 this 바인딩

this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. 함수도 다양한 방식으로 호출할 수 있으니 주의하자

1. 일반 함수 호출
2. 메서드 호출
3. 생성자 함수 호출
4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

```js
// this 바인딩의 결정은 함수 호출 방식에 의해 결정된다.
const foo = function(){
    console.dir(this);
};

// 1. 일반 함수 호출
foo();	// window

// 2. 메서드 호출
const obj = { foo };
obj.foo();	// obj

// 3. 생성자 함수 호출
new foo();	// foo {}

// 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출
const bar = { name: 'bar' };

foo.call(bar);	// bar
foo.apply(bar);	// bar
foo.bind(bar);	// bar
```



#### 22.2.1 일반 함수 호출

**기본적으로 this에는 전역 객체가 바인딩된다.**

```js
function foo(){
	console.log("foo's this: ", this);	// window
    function bar(){
        console.log("bar's this: ", this);	//window
    }
    bar();
}
foo();
```

전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다. strict mode 에서는 this에 undefined가 바인딩된다.

메서드 내에서 중첩된 함수도 일반 함수로 호출되면 this로 전역 객체가 바인딩된다. 메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 일치시키는 방법은 다음과 같다.

```js
var value = 1;

const obj = {
    value: 100,
    foo() {
        // this 바인딩을 that에 할당한다.
        const that = this;
        
        setTimeout(function (){
            console.log(that.value);
        }, 100);
        
        /* 2번째 방법
        화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다
        setTimeout(() => console.log(this.value), 100);	// 100
        */
    }
};

obj.foo();
```



#### 22.2.2 메서드 호출

메서드 내부의 this에는 메서드를 호출한 객체가 바인딩된다. 주의할 것은 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.

```js
const person = {
    name: 'Lee',
    getName(){
        return this.name;
    }
};

console.log(person.getName());	// Lee
```

위 예제의 getName 프로퍼티가 가리키는 함수 객체는 person 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체이다.(getName식별자가 가리키는 것은 객체의 주소니까) 따라서 getName 메서드는 다른 객체의 프로퍼티에 할당할 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.

```js
const anotherPerson = {
	name: 'Kim'
};

another.Person.getName = person.getName;

console.log(anotherPerson.getName());	// Kim

const getName = person.getName;

console.log(getName());	// ''
// 일반 함수로 호출됐으니 window.name과 같다.
// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
// Node.js 환경에서 this.name은 undefined이다.
```



#### 22.2.3 생성자 함수 호출

생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다.

```js
function Circle(radius){
    this.radius = radius;
    this.getDiameter = function(){
        return 2 * this.radius;
    };
}

const circle1 = new Circle(5);
const circle2 = enw Circle(10);

console.log(circle1.getDiameter());	// 10
console.log(circle2.getDiameter());	// 20

const circle3 = Circle(15);

console.log(circle3);	// undefined

console.log(radius);	// 15
```



#### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

apply, call, bind 메서드는 Function.prototype의 메서드다. 모든 함수가 상속받아 사용 가능하다.

apply와 call 메서드의 사용법은 다음과 같다.

```js
/**
 * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체
 * @returns 호출된 함수의 반환값
 */
Function.prototype.apply(thisArg[, argsArray])

/**
 * 주어진 this 바인딩과 ,로 구분된 인수 리스트를 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트
 * @returns 호출된 함수의 반환값
 */
Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])

function getThisBinding(){
    return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding());	// window

console.log(getThisBinding.apply(thisArg));	// {a: 1}
console.log(getThisBinding.call(thisArg));	// {a: 1}
```

apply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 작동한다. 위 예제에는 인수를 전달하지 않았으니 새로운 예제를 보자

```js
function getThisBinding(){
	console.log(arguments);
    return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
// [Arguments] { '0': 1, '1': 2, '2': 3 }
// { a: 1 }

console.log(getThisBinding.call(thisArg, 1, 2, 3));
// [Arguments] { '0': 1, '1': 2, '2': 3 }
// { a: 1 }
```

apply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다.

```js
function convertArgsToArray(){
	console.log(arguments);
	
    // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다.
    const arr = Array.prototype.slice.call(arguments);
    
    console.log(arr);
    return arr;
}

convertArgsToArray(1, 2, 3);	// [1, 2, 3]
```

Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다.

```js
function getThisBinding(){
    return this;
}

const thisArg = {a: 1};

console.log(getThisBinding.bind(thisArg));	// getThisBinding
// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.
console.log(getThisBinding.bind(thisArg)());// {a: 1}
```

bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 사용된다.

```js
const person = {
	name: 'Lee',
	foo(callback){
        setTimeout(callback, 100);
    }
};

person.foo(function(){
    console.log(`Hi! my name is ${this.name}.`);	// Hi! my name is .
})
// foo가 호출된 시점의 this는 person이지만 콜백 함수는 일반 함수이므로 콜백 함수가 호출될 때 this는 전역 객체이다.
```

여기서 person.foo의 콜백 함수는 person.foo를 돕는 역할을 하기 때문에 this가 다르면 문맥상 문제가 발생한다. bind를 통해 this를 통일시켜 주자

```js
const person = {
	name: 'Lee',
	foo(callback){
        setTimeout(callback.bind(this), 100);
    }
};

person.foo(function(){
    console.log(`Hi! my name is ${this.name}.`);	// Hi! my name is Lee.
})
// foo가 호출된 시점의 this는 person이지만 콜백 함수는 일반 함수이므로 콜백 함수가 호출될 때 this는 전역 객체이다.
```

지금까지 알아본 this 바인딩을 정리하면 다음과 같다.

| 함수 호출 방식                                             | this 바인딩                                                  |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 일반 함수 호출                                             | 전역 객체                                                    |
| 메서드 호출                                                | 메서드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에)생성할 인스턴스                        |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |



## 23장 실행 컨텍스트

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.

### 23.1 소스코드의 타입

ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.

| 소스코드의 타입 | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 전역 코드       | 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| 함수 코드       | 함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| eval 코드       | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드를 말한다. |
| 모듈 코드       | 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

이렇게 4가지로 구분하는 이유는 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.



#### 1. 전역 코드

전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다. 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.



#### 2. 함수 코드

함수 코드는 지역 스코프를 생성하고 지역 변수, 매개 변수, arguments 객체를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.



#### 3. eval 코드

eval 코드는 strict mode에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스크가 생성된다.



#### 4. 모듈 코드

모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.



### 23.2 소스코드의 평가와 실행

모든 소스코드는 실행에 앞서 평가 과정을 거치며 코드를 실행하기 위한 준비를 한다. 이는 소스코드를 '소스코드의 평가' 와 '소스코드의 실행'과정으로 나누어 처리한다는 것이다.

소스코드의 평가 과정에서 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.

소스코드 평가 과정이 끝나면 비로소 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다.(=런타임) 이때 소스코드 실행에 필요한 정보를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 소스토드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.



### 23.3 실행 컨텍스트의 역할

다음 예제를 자바스크립트 엔진이 어떻게 평가하고 실행할지 알아보자

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

#### 1. 전역 코드의 평가

전역 코드를 실행하기에 앞서 먼저 전역 코드 평가 과정을 거친다. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고, 그 결과 생성된 전역 변수와 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다. 이때 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.



#### 2. 전역 코드 실행

전역 코드 평가 과정이 끝나면 런타임이 된다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.



#### 3. 함수 코드 평가

함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거친다. 이때 매개변수와 지역 변수 선언문이 먼저 실행되고, 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다



#### 4. 함수 코드 실행

함수 코드 평가 과정이 끝나고 런타임이 된다. 이때 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다.

console.log 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. console 식별자는 스코프체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다. 이는 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미한다.

다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다. 그후 console.log메서드에 인수로 전달된 표현식 a+x+y가 평가된다. a, x, y 식별자는 스코프 체인을 통해 검색한다. console.log 메서드의 실행이 종료되면 함수 코드 실행 과정이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.



위처럼 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

1. 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.
2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.
3. 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

이 모든 것을 관리하는 것이 실행 컨텍스트다. 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

구체적으로 말하면 **실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**

식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.



### 23.4 실행 컨텍스트 스택

```js
const x = 1;

function foo(){
    const y = 2;
    
    function bar(){
        const z = 3;
        console.log(x + y + z);
    }
    bar();
}

foo();	// 6
```

위 예제는 소스코드의 타입으로 분류할 때 전역 코드와 함수 코드로 이루어져 있다. 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.

이때 생성된 실행 컨텍스트는 스택 자료구조로 관리된다. 이를 **실행 컨텍스트 스택**이라고 한다.

위 예제를 실행하면 시간의 흐름에 따라 실행 컨텍스트 스택에는 다음과 같이 실행 컨텍스트가 추가되고 제거된다.

1. 전역 실행 컨텍스트 push
2. foo 함수 실행 컨텍스트 push
3. bar 함수 실행 컨텍스트 push
4. bar 함수 실행 컨텍스트 pop
5. foo 함수 실행 컨텍스트 pop
6. 전역 실행 컨텍스트 pop

**실행 컨텍스트 스택은 코드의 실행 순서를 관리한다. 그리고 실행 컨텍스트 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트다.** 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행중인 실행 컨텍스트**라 부른다.



### 23.5 렉시컬 환경

렉시컬 환경은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다. 실행 컨텍스트 스택이 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.

렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 렉시컬 스코프의 실체다.

실행 컨텍스트는 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 이 둘은 하나의 동일한 렉시컬 환경을 참조한다. 이후 몇 가지 상황을 만나면 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고, 이때부터 둘의 내용이 달라지는 경우도 있다. 책에서는 이 둘을 구분하지 않고 렉시컬 환경으로 통일해서 간략하게 설명한다.

렉시컬 환경은 두 개의 컴포넌트로 구성된다.

1.  환경 레코드

   스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다. 환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.

2. 외부 렉시컬 환경에 대한 참조

   외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다. 이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이것을 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.



### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

다음 예제를 통해 실행 과정을 알아보자

```js
var x = 1;
const y = 2;

function foo(a){
    var x = 3;
    const y = 4;
    
    function bar(b){
        const z = 5;
        console.log(a + b + x + y + z);
    }
    bar(10);
}

foo(20);
```



#### 23.6.1 전역 객체 생성

전역 객체는 전역 코드가 평가되기 이전에 생성된다. 전역 객체도 Object.prototype을 상속받기 때문에 프로토타입 체인의 일원이다.



#### 23.6.2 전역 코드 평가

소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가한다.

1. 전역 실행 컨텍스트 생성

   비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다. 이때 전역 실행 컨텍스트는 스택의 최상위에 위치하여 현재 실행 중인 실행 컨텍스트가 된다.

2. 전역 렉시컬 환경 생성

   전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.

   1. 전역 환경 레코드 생성

      전역 렉시컬 환경을 구성하는 컴포넌트이다. 전역 변수를 관리하는 전역 스코프, 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체를 제공한다. let, const 키워드로 선언한 전역 변수를 구분하기 위해 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.

      1. 객체 환경 레코드 생성

         전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.

      2. 선언적 환경 레코드 생성

         let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다. 15.2.4절에서 let, const 키워드로 선언한 전역 변수는 개념적인 블록 내에 존재하게 된다고 했는데 그 블록이 선언적 환경 레코드다. 또한 const 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행한다. 따라서  런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 **일시적 사각지대**에 빠지게된다.

   2. this 바인딩

      전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 일반적으로 전역 코드에서 this는 전역 객체를 가리키기 때문에 전역 객체가 바인딩된다. 전역 코드에서 this를 참조하면 [[GlobalThisValue]] 내부 슬롯에 바인딩되어 있는 객체가 반환된다.

   3. 외부 렉시컬 환경에 대한 참조 결정

      외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 **상위 스코프를 가리킨다.** 이를 통해 단방향 링크드 리스크인 스코프 체인을 구현한다. 현재 평가중인 코드는 전역 코드이니 참조에 null이 할당된다.



#### 23.6.3 전역 코드 실행

전역 코드가 순차적으로 실행되기 시작한다. 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인해야 한다. 어느 스코프의 식별자를 참조하면 되는지 결정하는 것을 **식별자 결정**이라 한다.

식별자 결정을 위해 식별자를 검색할 때는 실행중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 실행중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 상위 스코프(외부 렉시컬 환경에 대한 참조)로 이동하여 식별자를 검색한다. 전역에서도 검색할 수 없다면 참조 에러를 발생시킨다.



#### 23.6.4 foo 함수 코드 평가

foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다.

1. 함수 실행 컨텍스트 생성

   foo 함수 실행 컨텍스트를 생성한다. 이것은 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 푸시된다. 푸시되면 스택의 최상위인 실행 중인 실행 컨텍스트가 된다.

2. 함수 렉시컬 환경 생성

   foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩한다.

   1. 함수 환경 레코드 생성

      함수 환경 레코드는 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

   2. this 바인딩

      함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다. 이 슬롯에 바인딩될 객체는 22장에서 보았듯 함수 호출 방식에 따라 결정된다. foo 함수는 일반 함수로 호출되었으므로 this는 전역 객체를 가리킨다.

   3. 외부 렉시컬 환경에 대한 참조 결정

      foo 함수는 전역 코드에 정의된 전역 함수다. 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트다. 따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다.



#### 23.6.5 foo 함수 코드 실행

foo 함수의 코드가 순차적으로 실행되기 시작한다. 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당된다. 그리고 bar가 호출된다.



#### 23.6.6 bar 함수 코드 평가

bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동하여 평가한다. 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드의 평가와 동일하다. bar 함수의 외부 렉시컬 환경에 대한 참조는 foo 함수의 렉시컬 환경이 된다.



#### 23.6.7 bar 함수 코드 실행

bar 함수의 소스코드가 순차적으로 실행된다. 그리고 console.log가 실행된다.



##### console 식별자 검색

console 식별자를 스코프 체인에서 검색한다. 현재 실행중인 실행 컨텍스트는 bar 함수 실행 컨텍스트다. 이곳(bar 함수 렉시컬 환경)에 console 식별자가 없으니 상위 스코프(foo 함수 렉시컬 환경)로 이동하여 검색한다. 이곳에도 없으니 상위 스코프(전역 렉시컬 환경)로 이동하여 console 식별자를 검색하고 console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.



##### log 메서드 검색

console 객체에서 log 메서드를 검색한다. 이때 console 객체의 프로토타입 체인을 통해 메서드를 검색한다. log는 상속된 프로퍼티가 아니라 console 객체가 직접 소유하는 프로퍼티다.

```js
console.hasOwnProperty('log');	// true
```



##### 표현식 a + b + x + y + z의 평가

표현식의 평가를 위해 a, b, x, y, z 식별자를 검색한다. 식별자는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경(상위 스코프)에 대한 참조로 이어지는 렉시컬 환경의 연속에서 검색한다.

a, x, y는 foo 함수 렉시컬 환경, b, z는 bar 함수 렉시컬 환경에서 검색된다.



##### console.log 메서드 호출

표현식이 평가되어 생성한 값 42를 console.log 메서드에 전달하여 호출한다.



#### 23.6.8 bar 함수 코드 실행 종료

더 실행할 코드가 없으니 bar 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop되어 제거되고 foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.

bar 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 렉시컬 환경은 독립적인 개체이기 때문에 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리의 공간의 확보가 해제되어 소멸한다.



#### 23.6.9 foo 함수 코드 실행 종료

bar 함수가 종료되면 더 이상 실행할 코드가 없으므로 foo 함수도 실행이 종료된다. foo 함수 실행 컨텍스트가 pop되어 제거되고 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.



#### 23.6.10 전역 코드 실행 종료

foo 함수가 종료되면 더 이상 실행할 코드가 없으므로 전역 코드의 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 pop되어 아무것도 남지 않게 된다.



### 23.7 실행 컨텍스트와 블록 레벨 스코프

var 키워드로 선언한 변수는 함수 레벨 스코프지만 let과 const로 선언한 변수는 블록 레벨 스코프를 따른다.

```js
let x = 1;

if(true){
    let x = 10;
    console.log(x);	// 10
}

console.log(x);	// 1
```

if 문의 코드 블록이 실행되면 if 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다. 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. 이때 새롭게 생성된 if 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if 문이 실행되기 이전의 전역 렉시컬 환경을 가리킨다.

이는 if 문뿐 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용된다. for 문의 변수 선언문에 let 키워드를 사용한 for 문은 코드 블록이 반복해서 실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다. 만약 for 문의 코드 블록 내에서 정의된 함수가 있다면 이 함수의 상위 스코프는 for 문이 생성한 렉시컬 환경이다. 이때 함수의 상위 스코프는 for 문의 코드 블록이 반복해서 실행될 때마다 식별자의 값을 유지해야 한다. 이를 위해 for 문의 코드 블록이 반복해서 실행될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다.



## 24장 클로저

클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다. 클로저는 자바스크립트 고유의 개념이 아니므로 ECMAScript 사양에 등장하지 않는다. 대신 MDN에서는 클로저에 대해 다음과 같이 정의한다.

**클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.**

```js
const x = 1;

function outerFunc() {
  const x = 10;

  function innerFunc() {
    console.log(x); // 10
  }

  innerFunc();
}

outerFunc();
```

outerFunc 함수 내부에서 중첩 함수 innerFunc가 정의되고 호출되었다. 이때 중첩 함수 innerFunc의 상위 스코프는 외부 함수 outerFunc의 스코프다. 따라서 innerFunc는 외부 함수 outerFunc의 x 변수에 접근할 수 있다.

만약 innerFunc가 outerFunc의 중첩 함수가 아니라면 outerFunc 함수의 변수에 접근할 수 없을 것이다.

```js
const x = 1;

function outerFunc() {
  const x = 10;
  innerFunc();
}

function innerFunc() {
  console.log(x); // 1
}

outerFunc();
```

이러한 이유는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문이다.



### 24.1 렉시컬 스코프

렉시컬 스코프를 실행 컨텍스트의 관점에서 다시 한번 살펴보자.

**자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.**

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

foo 함수와 bar 함수는 모두 전역에서 정의된 전역 함수다. 함수의 상위 스코프는 함수를 어디서 정의했느냐에 따라 결정되므로 foo 함수와 bar 함수의 상위 스코프는 전역이다. 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지 못한다.

23장 실행 컨텍스트에서 살펴보았듯이 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신의 "외부 렉시컬 환경에 대한 참조"를 통해 상위 렉시컬 환경과 연결된다. 이것이 바로 스코프 체인이다. 따라서 함수의 상위 스코프를 결정한다는 것은 외부 렉시컬 환경에 대한 참조를 결정하는 것이다. 이것을 반영해서 다시 렉시컬 스코프를 정의해 보면 다음과 같다.

**렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.**



### 24.2 함수 객체의 내부 슬롯 [[Environment]]

함수가 정의된 환경(위치)과 호출되는 환경(위치)은 다를 수 있다. 따라서 상위 스코프를 기억해야 하기 때문에 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.

함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장한다. 이때 자신의 내부 슬롯에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.

예를 들어, 전역에서 정의된 함수 선언문은 전역 코드가 평가되는 시점에 객체를 생성한다. 이때 생성된 함수 객체의 내부 슬롯 [[Environment]]에는 함수 정의가 평과되는 시점인 전역 코드 평가 시점에 실행 중인 컨텍스트의 렉시컬 환경 즉, 전역 렉시컬 환경의 참조가 저장된다.

```js
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 [[Environment]]에 저장하여 기억한다.
function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

foo 함수와 bar 함수는 모드 전역 함수로 선언되었다. 따라서 두 함수 모두 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성하고 전역 객체 window의 메서드가 된다.

함수가 호출되면 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 함수 코드 평가는 아래 순서로 진행된다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
   1. 함수 환경 레코드 생성
   2. this 바인딩
   3. 외부 렉시컬 환경에 대한 참조 결정

이때 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯[[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.



### 24.3 클로저와 렉시컬 환경

```js
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```

outer 함수를 호출하면 outer 함수는 중첩 함수 inner를 반환하고 생명 주기를 마감(= 실행 컨텍스트를 pop)한다. 이때 outer 함수의 지역 변수 x는 접근할 방법이 없어 보이지만 코드의 실행 결과는 10이다.

이처럼 **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.**

자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다. 따라서 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있으며 식별자에 바인딩된 값을 변경할 수도 있다. 위 예제에서 inner 함수는 자신이 평가될 때 자신이 정의된 위치에 의해 결정된 상위 스코프를 [[Environment]] 내부 슬롯에 저장한다. 이때 저장된 상위 스코프는 함수가 존재하는 한 유지된다.

위 예제에서 outer 함수의 실행이 종료되면 inner 함수를 반환하면서 outer 함수의 생명 주기가 종료된다. 이때 outer 함수의 실행 컨텍스트는 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있기 때문이다.

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 일반적으로 클로저라고 하지 않는다.
      function bar() {
        const z = 3;

        debugger;
        // 상위 스코프의 식별자를 참조하지 않는다.
        console.log(z);
      }

      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 외부 함수 foo보다 더 오래 유지되지만 상위 스코프의 어떤 식별자도 참조하지 않는다. 이처럼 상위 스코프의 어떤 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다. 따라서 bar 함수는 클로저라고 할 수 없다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;

      // 일반적으로 클로저라고 하지 않는다.
      // bar 함수는 클로저였지만 곧바로 소멸한다.
      function bar() {
        debugger;
        // 상위 스코프의 식별자를 참조한다.
        console.log(x);
      }
      bar();
    }

    foo();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 하지만 외부 함수 foo의 외부로 중첩 함수 bar가 반환되지 않는다. 즉, 외부 함수 foo 보다 중첩 함수 bar의 생명 주기가 짧다. 이런 경우 중첩 함수 bar는 클로저였지만 외부 함수보다 일찍 소멸되기 때문에 클로저의 본질에 부합하지 않는다. 따라서 bar는 일반적으로 클로저라고 하지 않는다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 클로저
      // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
      function bar() {
        debugger;
        console.log(x);
      }
      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 외부 함수보다 오래 살아 남는다. 이러한 중첩 함수를 클로저라고 부른다. **클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.**

이론적으로 클로저는 상위 스코프를 기억해야 하므로 불필요한 메모리의 점유를 걱정할 수도 있지만 모던 자바스크립트 엔진은 최적화가 잘 되어있기 때문에 불필요한 식별자는 기억하지 않는다. 즉, 상위 스코프의 식별자 중에서 기억해야 할 식별자만 기억한다.



### 24.4 클로저의 활용

**클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.** 다시 말해, **상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.**

```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 예제는 잘 작동하지만 오류를 발생시킬 가능성을 내포하고 있다.

1. 카운트 상태는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.
2. 카운트 상태는 increase 함수만이 변경할 수 있어야 한다.



```js
// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태 변수
  let num = 0;

  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

// 이전 상태를 유지하지 못한다.
console.log(increase()); // 1
console.log(increase()); // 1
console.log(increase()); // 1
```

위 예제는 num을 지역 변수로 변경하의 의도치 않은 상태 변경은 방지했지만 이전 상태를 유지할 수 없다.



```js
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // 카운트 상태를 1만큼 증가 시킨다.
    return ++num;
  };
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 코드가 실행되면 즉시 실행 함수가 호출되고 반환한 함수가  increase 변수에 할당된다. increase 변수에 할당된 함수는 자신이 정위된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다.

클로저는 increase 변수에 할당되어 호출된다. 즉시 실행 함수는 소멸했지만 즉시 실행 함수의 렉시컬 환경은 클로저에 기억되고 있기 때문에 increase를 통해서만 num을 변경시킬 수 있게 된다.



### 24.5 캡슐화와 정보 은닉

캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.

정보 은닉은 정보를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.

대부분의 객체지향 프로그래밍 언어는 접근 제한자(public, private, protected)를 선언하여 공개 범위를 한정할 수 있다. 하지만 자바스크립트는 이를 제공하지 않는다.

```js
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private

  // 인스턴스 메서드
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

여기서 name 프로퍼티는 공개되어 있어서 자유롭게 참조하거나 변경할 수 있다. 하지만 _age 변수는 Person 생성자 함수의 지역 변수이므로 외부에서 참조하거나 변경할 수 없다. 즉, private 하다.

위 예제는 sayHi 메서드가 Person 객체를 생성할 때마다 중복되어 생성되니 이를 방지해보자.

```js
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  // Person 생성자 함수의 지역 변수 _age를 참조할 수 없다
  console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
};
```

이때 Person.prototype.sayHi 메서드 내에서 Person 생성자 함수의 지역 변수 _age를 참조할 수 없는 문제가 발생한다. 따라서 Person 생성자 함수와 sayHi 메서드를 하나의 함수 내에 모아 보자.

```js
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

위 패턴을 사용하면 접근 제한자 없이 자바스크립트에서도 정보 은닉이 가능한 것처럼 보인다. 하지만 이 코드도 문제가 있다. Person 생성자 함수가 여러 개의 인스턴스를 생성할 경우 다음과 같이 _age 변수의 상태가 유지되지 않는다는 것이다.

```js
const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.

// _age 변수 값이 변경된다!
me.sayHi(); // Hi! My name is Lee. I am 30.
```

이는 Person.prototype.sayHi 메서드가 단 한 번 생성되는 클로저이기 때문에 발생하는 현상이다. sayHi 메서드는 자신의 상위 스코프인 즉시 실행 함수의 실행 컨텍스트의 렉시컬 환경의 참조를 [[Environment]]에 저장하여 기억한다. 따라서 Person 생성자 함수의 모든 인스턴스가 상속을 통해 호출할 수 있는 sayHi 메서드의 상위 스코프는 어떤 인스턴스로 호출하더라도 하나의 동일한 상위 스코프를 사용하게 된다. 이러한 이유로 _age의 상태가 유지되지 않는다.

이처럼 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다.



### 24.6 자주 발생하는 실수

아래는 클로저를 사용할 때 자주 발생할 수 있는 실수를 보여주는 예제다.

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () { return i; }; // ①
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ②
}
```

var가 함수 레벨 스코프를 갖기 때문에 i 가 전역 변수가 되어 발생하는 문제이다. 클로저를 사용해 위 예제를 제대로 동작하게 만들자

```js
var funcs = [];

for (var i = 0; i < 3; i++){
  funcs[i] = (function (id) { // ①
    return function () {
      return id;
    };
  }(i));
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

또는 var를 let으로 바꾸어 해결할 수도 있다

```js
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () { return i; };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0 1 2
}
```

let이나 const 키워드를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스냅숏을 찍는 것처럼 저장한다. 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 블록 내부에 함수 정의가 없는 반복문이 생성하는 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.



## 25장 클래스

### 25.1 클래스는 프로토타입의 문법적 설탕인가?

자바스크립트는 프로토타입 기반 객체지향 언어다. 그리고 프로토타입 기반 객체지향 언어는 클래스가 필요 없는 프로그래밍 언어다.

```js
// 클래스 없이도 상속을 구현할 수 있다.
var Person = (function(){
    function Person(name){
        this.name = name;
    }
    
    Person.prototype.sayHi = function(){
        console.log(`Hi! My name is ${this.name}`);
    };
    
    return Person;
}());

var me = new Person('Lee');
me.sayHi();	// Hi! My name is Lee
```

하지만 클래스 기반 언어에 익숙한 프로그래머들을 위해 ES6에서 클래스가 도입되었다. 하지만 사실 여기서 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.

단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

클래스와 생성자 함수의 차이점은 다음과 같다.

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수는 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. 열거되지 않는다.

생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현했다는 점에서 매우 유사하다. 하지만 클래스는 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료하다. 따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 메커니즘**으로 보는 것이 좀 더 합당하다.



### 25.2 클래스 정의

클래스는 class 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다. 물론 사용하지 않아도 에러는 발생하지 않는다.

```js
class Person {}
```

함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. 이때 이름을 가질수도, 갖지 않을 수도 있다.

```js
const Person = class {};

const Person = class MyClass {};
```

클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용 가능한 일급 객체라는 것을 의미한다. 

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.
