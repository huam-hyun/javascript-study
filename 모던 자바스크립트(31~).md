# 모던 자바스크립트 Deep Dive(31 ~ )

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 31장 RegExp(정규 표현식)

### 31.1 정규 표현식이란?

정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어다. 자바스크립트의 고유 문법이 아니고, 대부분의 프로그래밍 언어와 코드 에디터에 내장되어 있다.

정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다. 패턴 매칭 기능은 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.

예를 들어, 전화번호를 입력 받을 때 숫자 3개 - 숫자 4개 - 숫자 4개라는 일정한 패턴이 있다.

```js
const tel = '010-1234-567팔'

const regExp = /^\d{3}-\d{4}-\d{4}$/;

regExp.test(tel);
```

만약 반복문과 조건문을 통해 체크하려면 한 문자씩 연속해서 체크해야 한다.



### 31.2 정규 표현식의 생성

정규 표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 RegExp 생성자 함수를 사용할 수 있다. 일반적인 방법은 리터럴을 사용하는 것이다. 정규 표현식 리터럴은 다음과 같이 표현한다. `/regExp패턴/i(플래그)`

```js
const target = 'Is this all there is?'

// 패턴: is
// 플래그: i => 대소문자를 구분하지 않고 검색한다.
const regexp = /is/i;

regexp.test(target);
```



RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.

```js
/**
 * pattern: 정규 표현식의 패턴
 * flags: 정규 표현식의 플래그(g, i, m, u, y)
 */

new RegExp(pattern[, flags])
```

```js
const target = 'Is this all there is?';

const egexp = new RegExp(/is/i);	// ES6
// const regexp = new RegExp(/is/i, 'i');
// const regexp = new RegExp('is', 'i');

regexp.test(target);	// true
```



RegExp 생성자 함수를 사용하면 변수를 사용해 동적으로 RegExp 객체를 생성할 수 있다.

```js
const count = (str, char) => (str.match(new RegExp(char, 'gi')) ?? []).length;

count('Is this all there is?', 'is');	// 3
count('Is this all there is?', 'xx');	// 0
```



### 31.3 RegExp 메서드

정규표현식을 사용하는 메서드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다.



#### 31.3.1 RegExp.prototype.exec

exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.exec(target);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exex 메서드는 모든 패턴을 검색ㅎ는 g 플래그를 지정해도 첫 번째 매칭 결과만 반환한다.



#### 31.3.2 RegExp.prototype.test

test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.test(target);	// true
```



#### 31.3.3 String.prototype.match

String 표준 빌트인 객체로 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

target.match(regExp);	// exec와 target, match의 위치만 바꼈다
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exec 메서드는 g 플래그를 지정해도 첫 번쨰 매칭 결과만 반환하지만 match 메서드는 모든 결과를 배열로 반환한다.



### 31.4 플래그

패턴과 함꼐 정규 표현식을 구성한다. 플래그는 총 6개가 있다. 그중 중요한 3개를 알아보자.

| 플래그 | 의미        | 설명                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| i      | Ignore case | 대소문자를 구별하지 않고 패턴을 검색한다.                    |
| g      | Global      | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m      | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다.               |

플래그는 옵션이니 선택적으로 사용할 수 있다. 순서와 상관없이 하나 이상의 플래그를 동시에 설정할 수도 있다. 어떠한 플래그도 사용하지 않으면 대소문자를 구별해서 패턴을 검색한다. 그리고 대상이 1개 이상 존재해도 첫 번째 대상만 검색하고 종료한다.

```js
const target = 'Is this all there is?';

target.match(/is/);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]
target.match(/is/g);
// [ 'is', 'is' ]
target.match(/is/ig);
// [ 'Is', 'is', 'is' ]
```



### 31.5 패턴

정규 표현식의 패턴은 문자열의 일정한 규칙을 표현하기 위해 사용하며, 플래그는 검색 방식을 설정하기 위해 사용한다.

패턴은 /로 열고 닫으며 문자열의 따옴표는 생략한다. 따옴표를 포함하면 따옴표까지 패턴에 포함되어 검색된다. 패턴을 표현하는 몇 가지 방법에 대해 알아보자.



#### 31.5.1 문자열 검색

패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴을 지정한 문자 또는 문자열을 검색한다.

```js
const target = 'Is this all there is?';

// is 문자열과 매치하는 패턴. 플래그가 생략되었으니 대소문자를 구별한다.
const regExp = /is/;

regExp.test(target);	// true
target.match(regExp);
```



#### 31.5.2 임의의 문자열 검색

.은 임의의 문자 한 개를 의미한다. 내용은 무엇이든 상관없다. 다음 예제는 .을 3개 연속하여 패턴을 생성하였으니 임의의 3자리 문자열과 매치한다.

```js
const target = 'Is this all there is?';

const regExp = /.../g;

console.log(target.match(regExp));
/*
[
  'Is ', 'thi',
  's a', 'll ',
  'the', 're ',
  'is?'
]
*/
```



#### 31.5.3 반복 검색

{m, n}은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 작동안하니 주의하자.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{1,2}/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AA', 'A' ]
```



{n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다. 즉, {n,n}과 같다.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{2}/g;

console.log(target.match(regExp));	// [ 'AA', 'AA' ]
```



{n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A{2,}/g;

console.log(target.match(regExp));	// [ 'AA', 'AAA' ]
```

 

+는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. {1,}과 같은 의미이다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AAA' ]
```



?는 앞선 패턴이 최대 한 번 이상 반복되는 문자열을 의미한다. {0, 1}과 같다. /colou?r/는 colo 다음 u가 최대 한번 반복되고 r이 이어지는 문자열(color, colour)과 매치한다.

```js
const target = 'color colour';

const regExp = /colou?r/g;

target.match(regExp);
```



#### 31.5.4 OR 검색

|은 or의 의미를 갖는다. 다음 예제의 /A|B/는 A 또는 B를 의미한다.

```js
const target = 'A AA B B Aa Bb';

const regExp = /A|B/g;

console.log(target.match(regExp));
/*
[
  'A', 'A', 'A',
  'B', 'B', 'A',
  'B'
]
*/
```



분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /A+|B+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



위 예제는 패턴을 or로 한 번 이상 반복하는 것인데 이를 간단히 []로 표현할 수 있다. [] 내의 문자는 or로 동작한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /[AB]+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



범위를 지정하려면 []내에 -를 사용한다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Z]+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'BB', 'ZZ', 'A', 'B' ]
```



대소문자를 구별하지 않고 검색하는 방법은 다음과 같다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Za-z]+/g;

console.log(target.match(regExp));
```



숫자를 검색하는 방법은 다음과 같다.

```js
const target = 'AA BB 12,345';

const regExp = /[0-9]+/g;

target.match(regExp);	// ['12', '345']

// 쉼표를 포함하고 싶다면 패턴에 쉼표를 포함시키면 된다.
// const regExp2 = [0-9,]+/g;
```



위 예제를 간단히 표현하면 다음과 같다. \d는 숫자를 의미한다. \D는 \d와 반대로 동작한다.

```js
const target = 'AA BB 12,345';

let regExp = /[\d,]+/g;

target.match(RegExp);	// ['12,345']

regExp = /[\D,]+/g;

target.match(regExp);	// ['AA BB ', ',']
```



\w는 알파벳, 숫자, 언더스코어를 의미한다. [A-Za-z0-9_]와 같다. \W는 \w와 반대로 동작한다.

```js
const target = 'Aa Bb 12,345 _$%&';

let regExp = /[\w,]+/g;

target.match(regExp);	// [ 'Aa', 'Bb', '12,345', '_' ]

regExp = /[\W,]+/g;

target.match(regExp);	// [ ' ', ' ', ',', ' ', '$%&' ]
```



#### 31.5.5 NOT 검색

[...]내의 ^은 not의 의미를 갖는다. 예를 들어, ^0-9는 숫자를 제외한 문자(\D)를 의미한다.

```js
const target = 'AA BB 12 Aa Bb';

const regExp = /[^0-9]+/g;

target.match(regExp);	// [ 'AA BB ', ' Aa Bb' ]
```



#### 31.5.6 시작 위치로 검색

[...]밖의 ^은 문자열의 시작을 의미한다. [...]안이면 NOT을 의미하니 주의하자.

```js
const target = 'https://poiemaweb.com';

// https로 시작하는지 검사한다.
const regExp = /^https/;

regExp.test(target);	// true
```



#### 31.5.7 마지막 위치로 검색

$는 문자열의 마지막을 의미한다.

```js
const target = 'https:/poiemaweb.com';

const regExp = /com$/;

regExp.test(target);	// true
```



### 31.6 자주 사용하는 정규표현식

#### 31.6.1 특정 단어로 시작하는지 검사

```js
const url = 'https://example.com';

// [] 바깥의 ^는 문자열의 시작을 의미하고 ?는 앞선 패턴이 최대 한번(있어도 되고 없어도 된다) 반복되는지를 의미한다.
// http:// 또는 https://로 시작하는지 검사한다.
/^https?:\/\//.test(url);	// true
/^(http|https):\/\//.test(url);	// true
```



#### 31.6.2 특정 단어로 끝나는지 검사

```js
const fileName = 'index.html';

/html$/.test(fileName);	// true
```



#### 31.6.3 숫자로만 이루어진 문자열인지 검사

```js
const target = '12345';

// ^: 숫자로 시작, +: 한번 이상 반복, $: 숫자로 끝남
/^\d+$/.test(target);	// true
```



#### 31.6.4 하나 이상의 공백으로 시작하는지 검사

\s는 여러가지 공백 문자를 의미한다. [\t\r\n\v\f]와 같은 의미다.

```js
const target = ' Hi!';

/^[\s]+/.test(target);	// true
```



#### 31.6.5 아이디로 사용 가능한지 검사

검색 대상 문자열이 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사해보자

```js
const id = 'abc123';

/^[A-Za-z0-9]{4,10}$/.test(id);	// true
```



#### 31.6.6 메일 주소 형식에 맞는지 검사

*는 0번 이상의 반복을 의미한다.

```js
const email = 'sanghyun2@gmail.com';

console.log(/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/.test(email));	// true
```



인터넷 메시지 형식 규약인 RFC 5322에 맞는 정교한 패턴 매칭이 필요하다면 다음과 같은 복잡한 패턴이 필요하다.

```js
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```



#### 31.6.7 핸드폰 번호 형식에 맞는지 검사

```js
const cellphone = '010-1234-5678';

/^\d{3}-\d{4}-\d{4}$/.test(cellphone);	// true
```



#### 31.6.8 특수 문자 포함 여부 검사

특수문자는 A-Za-z0-9 이외의 문자다.

```js
const target = 'abc#123';

(/[^A-Za-z0-9]/gi).test(target);	// true
```



다음 방식으로 대체할 수도 있다. 이 방식은 특수 문자를 선택적으로 검사할 수 있다는 장점이 있다

```js
(/[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi).test(target);
```



특수문자를 제거할 때는 String.prototype.replace 메서드를 사용한다.

```js
target.replace(/[^A-Za-z0-9]/gi, '');	// abc123
```



## 32장 String

표준 빌트인 객체 String은 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메서드를 제공한다.

### 32.1 String 생성자 함수

String 객체는 생성자 함수 객체다. new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. 생성자 함수에 인수를 전달하지 않으면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 래퍼 객체를 생성한다.

String 래퍼 객체는 배열과 마찬가지로 length 프로퍼티를 가지고 인덱스를 프로퍼티 키로, 문자를 프로퍼티 값으로 가지는 유사 배열 객체이다. 따라서 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.

문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.

```js
const strObj = new String('Lee');

strObj[0] = 'S';
console.log(strObj);	// 'Lee'
```

String 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 인수를 문자열로 강제 변환한다.

```js
// 결과를 간단히만 표현했다
let strObj = new String(123);
console.log(strObj);	// '123'

strObj = new String(null);
console.log(strObj);	// 'null'
```

![image-20220312154713541](C:\Users\Sanghyun\AppData\Roaming\Typora\typora-user-images\image-20220312154713541.png)

명시적 타입 변환에서 살펴보았듯이 new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 인스턴스가 아닌 문자열을 반환한다.

```js
String(1);			//'1'
String(NaN);		//'NaN'
String(Infinity);	//'Infinity'

String(true);		// 'true'
String(false);		// 'false'
```



### 32.2 length 프로퍼티

length 프로퍼티는 문자열의 문자 개수를 반환한다.

```js
'Hello'.length;			// 5
'안녕하세요!'.length;	 // 6
```



### 32.3 String 메서드

String 객체에는 원본 객체를 변경하는 String 메서드가 존재하지 않는다. String 메서드들은 언제나 새로운 문자열(문자열은 원시값이기 때문에 변경할 수 없다)을 반환한다.

#### 32.3.1 String.rototype.indexOf

대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = 'Hello World';

str.indexOf('l');	// 2
str.indexOf('or');	// 7
str.indexOf('x');	// -1
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
str.indexOf('l', 3);	// 3
```

indexOf메서드는 대상 문자열에 특정 문자열이 존재하는지 확인할 때 유용하다.



#### 32.3.2 String.prototype.search

대상 문자열에서 인수로 전달받은 정규표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = 'Hello world';

str.search(/o/);	// 4
str.search(/x/);	// -1
```



#### 32.3.3 String.prototype.includes

대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
const str = 'Hello World';

str.includes('Hello');	// true
str.includes('');		// true
str.includes('x');		// false
str.includes();			// false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.



#### 32.3.4 String.prototype.startsWith

대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
const str = 'Hello World';

str.startsWith('He');	// true
str.startsWith('x');	// false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.



#### 32.3.5 String.prototype.endsWith

대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
str = 'Hello World';

str.endsWith('ld');	// true
str.endsWith('x');	// false
```

2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.



#### 32.3.6 String.prototype.charAt

대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다.

```js
const str = 'Hello World';

for(let i = 0; i < str.length; i++){
    console.log(str.charAt(i))l	// H e l l o
}
```

인덱스가 문자열의 범위를 벗어난 경우 빈 문자열을 반환한다.



#### 32.3.7 String.prototype.substring

대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.

```js
const str = 'Hello World';

str.substring(1, 4);	// ell
```

두 번째 인수를 생략하면 첫 번째 인수에서 부터 마지막까지 문자열을 반환한다.

```js
const str = 'Hello World';

str.substring(1);	// 'ello World'
```

substring 메서드는 두 번째 인수가 더 작아야 정상이다. 하지만 다음과 같이 인수를 전달해도 동작한다.

- 첫 번째 인수 > 두 번째 인수인 경우 두 인수는 교환된다.
- 인수 < 0 또는 NaN인 경우 0으로 취급된다.
- 인수 > 문자열의 길이인 경우 인수는 문자열의 길이로 취급된다.

```js
const str = ' Hello World'

str.substring(4, 1);	// 'ell'

str.substring(-2);	// 'Hello World'

str.substring(1, 100);	// 'ello World'
```



#### 32.3.8 String.prototype.slice

substring 메서드와 동일하게 동작한다. 단, 음수인 인수를 전달할 수 있다. 음수의 경우 뒤에서부터 n번째를 나타낸다.

```js
const str = 'hello world';

str.slice(0, 5);	// 'hello'

str.slice(2);		// 'llo world'

str.slice(-5);		// 'world'
```



#### 32.3.9 String.prototype.toUpperCase

대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.

```js
const str = 'Hello World!';

str.toUpperCase();	// 'HELLO WORLD!'
```



#### 32.3.10 String.prototype.toLowerCase

대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.

```js
const str = 'Hello World!';

str.toLowerCase();	// 'hello world!'
```



#### 32.3.11 String.prototype.trim

대상 문자열 앞뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환한다.

```js
const str = '    foo  '

str.trim();		// 'foo'
```

현재는 trimStart, trimEnd를 사용해 대상 문자열 앞 또는 뒤에 있는 공백을 제거한 문자열을 반환할 수 있다.

String.prototype.replace 메서드에 정규 표현식을 전달하여 공백 문자를 제거할 수도 있다.

```js
const str = '    foo  ';

str.replace(/\s/g, '');		// 'foo'
str.replace(/^\s+/g, '');	// 'foo  '
str.replace(/\s$/g, '');	// '     foo'
```



#### 32.3.12 String.prototype.repeat

대상 문자열을 인수로 받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 전달받은 인수가 0이면 빈 문자열을 반환하고, 음수이면 RangeError를 발생시킨다. 생략하면 기본값 0이 설정된다.

```js
const str = 'abc';

str.repeat();		// ''
str.repeat(0);		// ''
str.repeat(1);		// 'abc'
str.repeat(2);		// 'abcabc'
str.repeat(2.5);	// 'abcabc' 2.5가 2로 바뀌었다
str.repeat(-1);		// RangeError
```



#### 32.3.13 String.prototype.replace

대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.

```js
const str = 'Hello world';

str.replace('world', 'Lee');	// 'Hello Lee'
```

검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.

```js
const str = 'Hello world world';

str.replace('world', 'Lee');	// 'Hello Lee world'
```

특수한 교체 패턴을 사용할 수 있다. 예를 들어 $&는 검색된 문자열을 의미한다.

```js
const str = 'Hello world';

str.replace('world', '<stong>$&</strong>');
```

replace 메서드의 두 번째 인수로 치환 함수를 전달할 수 있다.

```js
function camelToSnake(camelCase){
    return camelCase.replace(/.[A-Z]/g, match =>{
        console.log(match);
        return match[0] + '_' + match[1].toLowerCase();
    });
}

const cameCase = 'helloWorld';
camelToSnake(camelCase);	// 'hello_world'

function snakeToCamel(snakeCase){
    return snakeCase.replace(/_[a-z]]/g, match =>{
        console.log(match);
        return match[1].toUpperCase();
    });
}

const snakeCase = 'hello_world';
snakeToCamel(snakeCase);	// 'helloWorld'
```



#### 32.3.14 String.prototype.split

대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 빈 문자열을 전달하면 각 문자를 모두 분리하고, 생략하면 대상 문자열 전체를 하나로 반환한다.

```js
const str = 'How are you doing?';

str.split(' ');		// [ 'How', 'are', 'you', 'doing?']

str.split(/\s/);	// [ 'How', 'are', 'you', 'doing?']

str.split();		// [ 'How are you doing?' ]
```

두 번째 인수로 배열의 길이를 지정할 수 있다.

```js
str.split(' ', 3);	// [ 'How', 'are', 'you' ] 배열의 길이가 3이다
```



## 33장 7번째 데이터 타입 Symbol

### 33.1 심벌이란?

ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.



### 33.2 심벌 값의 생성

#### 33.2.1 Symbol 함수

심벌 값은 Symbol 함수를 호출하여 생성한다. 이때 생성된 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```js
const mySymbol = Symbol();
console.log(typeof mySymbol);	// symbol

console.log(mySymbol);	// Symbol() 외부로 노출되지 않아 확인할 수 없다.
```

Symbol은 변경 불가능한 값이기 때문에 생성자 함수를 사용해서 생성하지 않는다. Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며, 심벌 값 생성에 어떠한 영향도 주지 않는다.

```js
const mySymbol1 = Symbol('mySymbol');
const mySymbol2 = Symbol('mySymbol');

console.log(mySymbol1 === mySymbol2);	// false
```

심벌 값도 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.

```js
const mySymbol = Symbol('mySymbol');

console.log(mySymbol.description);	// mySymbol
console.log(mySymbol.toString());	// Symbol(mySymbol)
```

심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.

```js
const mySymbol = Symbol();

console.log(mySymbol + '');	// TypeError
console.log(+mySymbol);		// TypeError
```

