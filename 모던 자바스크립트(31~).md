# 모던 자바스크립트 Deep Dive(31 ~ )

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 31장 RegExp(정규 표현식)

### 31.1 정규 표현식이란?

정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어다. 자바스크립트의 고유 문법이 아니고, 대부분의 프로그래밍 언어와 코드 에디터에 내장되어 있다.

정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다. 패턴 매칭 기능은 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.

예를 들어, 전화번호를 입력 받을 때 숫자 3개 - 숫자 4개 - 숫자 4개라는 일정한 패턴이 있다.

```js
const tel = '010-1234-567팔'

const regExp = /^\d{3}-\d{4}-\d{4}$/;

regExp.test(tel);
```

만약 반복문과 조건문을 통해 체크하려면 한 문자씩 연속해서 체크해야 한다.



### 31.2 정규 표현식의 생성

정규 표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 RegExp 생성자 함수를 사용할 수 있다. 일반적인 방법은 리터럴을 사용하는 것이다. 정규 표현식 리터럴은 다음과 같이 표현한다. `/regExp패턴/i(플래그)`

```js
const target = 'Is this all there is?'

// 패턴: is
// 플래그: i => 대소문자를 구분하지 않고 검색한다.
const regexp = /is/i;

regexp.test(target);
```



RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.

```js
/**
 * pattern: 정규 표현식의 패턴
 * flags: 정규 표현식의 플래그(g, i, m, u, y)
 */

new RegExp(pattern[, flags])
```

```js
const target = 'Is this all there is?';

const egexp = new RegExp(/is/i);	// ES6
// const regexp = new RegExp(/is/i, 'i');
// const regexp = new RegExp('is', 'i');

regexp.test(target);	// true
```



RegExp 생성자 함수를 사용하면 변수를 사용해 동적으로 RegExp 객체를 생성할 수 있다.

```js
const count = (str, char) => (str.match(new RegExp(char, 'gi')) ?? []).length;

count('Is this all there is?', 'is');	// 3
count('Is this all there is?', 'xx');	// 0
```



### 31.3 RegExp 메서드

정규표현식을 사용하는 메서드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다.



#### 31.3.1 RegExp.prototype.exec

exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.exec(target);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exex 메서드는 모든 패턴을 검색ㅎ는 g 플래그를 지정해도 첫 번째 매칭 결과만 반환한다.



#### 31.3.2 RegExp.prototype.test

test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.test(target);	// true
```



#### 31.3.3 String.prototype.match

String 표준 빌트인 객체로 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

target.match(regExp);	// exec와 target, match의 위치만 바꼈다
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exec 메서드는 g 플래그를 지정해도 첫 번쨰 매칭 결과만 반환하지만 match 메서드는 모든 결과를 배열로 반환한다.



### 31.4 플래그

패턴과 함꼐 정규 표현식을 구성한다. 플래그는 총 6개가 있다. 그중 중요한 3개를 알아보자.

| 플래그 | 의미        | 설명                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| i      | Ignore case | 대소문자를 구별하지 않고 패턴을 검색한다.                    |
| g      | Global      | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m      | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다.               |

플래그는 옵션이니 선택적으로 사용할 수 있다. 순서와 상관없이 하나 이상의 플래그를 동시에 설정할 수도 있다. 어떠한 플래그도 사용하지 않으면 대소문자를 구별해서 패턴을 검색한다. 그리고 대상이 1개 이상 존재해도 첫 번째 대상만 검색하고 종료한다.

```js
const target = 'Is this all there is?';

target.match(/is/);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]
target.match(/is/g);
// [ 'is', 'is' ]
target.match(/is/ig);
// [ 'Is', 'is', 'is' ]
```



### 31.5 패턴

정규 표현식의 패턴은 문자열의 일정한 규칙을 표현하기 위해 사용하며, 플래그는 검색 방식을 설정하기 위해 사용한다.

패턴은 /로 열고 닫으며 문자열의 따옴표는 생략한다. 따옴표를 포함하면 따옴표까지 패턴에 포함되어 검색된다. 패턴을 표현하는 몇 가지 방법에 대해 알아보자.



#### 31.5.1 문자열 검색

패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴을 지정한 문자 또는 문자열을 검색한다.

```js
const target = 'Is this all there is?';

// is 문자열과 매치하는 패턴. 플래그가 생략되었으니 대소문자를 구별한다.
const regExp = /is/;

regExp.test(target);	// true
target.match(regExp);
```



#### 31.5.2 임의의 문자열 검색

.은 임의의 문자 한 개를 의미한다. 내용은 무엇이든 상관없다. 다음 예제는 .을 3개 연속하여 패턴을 생성하였으니 임의의 3자리 문자열과 매치한다.

```js
const target = 'Is this all there is?';

const regExp = /.../g;

console.log(target.match(regExp));
/*
[
  'Is ', 'thi',
  's a', 'll ',
  'the', 're ',
  'is?'
]
*/
```



#### 31.5.3 반복 검색

{m, n}은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 작동안하니 주의하자.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{1,2}/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AA', 'A' ]
```



{n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다. 즉, {n,n}과 같다.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{2}/g;

console.log(target.match(regExp));	// [ 'AA', 'AA' ]
```



{n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A{2,}/g;

console.log(target.match(regExp));	// [ 'AA', 'AAA' ]
```

 

+는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. {1,}과 같은 의미이다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AAA' ]
```



?는 앞선 패턴이 최대 한 번 이상 반복되는 문자열을 의미한다. {0, 1}과 같다. /colou?r/는 colo 다음 u가 최대 한번 반복되고 r이 이어지는 문자열(color, colour)과 매치한다.

```js
const target = 'color colour';

const regExp = /colou?r/g;

target.match(regExp);
```



#### 31.5.4 OR 검색

|은 or의 의미를 갖는다. 다음 예제의 /A|B/는 A 또는 B를 의미한다.

```js
const target = 'A AA B B Aa Bb';

const regExp = /A|B/g;

console.log(target.match(regExp));
/*
[
  'A', 'A', 'A',
  'B', 'B', 'A',
  'B'
]
*/
```



분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /A+|B+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



위 예제는 패턴을 or로 한 번 이상 반복하는 것인데 이를 간단히 []로 표현할 수 있다. [] 내의 문자는 or로 동작한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /[AB]+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



범위를 지정하려면 []내에 -를 사용한다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Z]+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'BB', 'ZZ', 'A', 'B' ]
```



대소문자를 구별하지 않고 검색하는 방법은 다음과 같다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Za-z]+/g;

console.log(target.match(regExp));
```



숫자를 검색하는 방법은 다음과 같다.

```js
const target = 'AA BB 12,345';

const regExp = /[0-9]+/g;

target.match(regExp);	// ['12', '345']

// 쉼표를 포함하고 싶다면 패턴에 쉼표를 포함시키면 된다.
// const regExp2 = [0-9,]+/g;
```



위 예제를 간단히 표현하면 다음과 같다. \d는 숫자를 의미한다. \D는 \d와 반대로 동작한다.

```js
const target = 'AA BB 12,345';

let regExp = /[\d,]+/g;

target.match(RegExp);	// ['12,345']

regExp = /[\D,]+/g;

target.match(regExp);	// ['AA BB ', ',']
```



\w는 알파벳, 숫자, 언더스코어를 의미한다. [A-Za-z0-9_]와 같다. \W는 \w와 반대로 동작한다.

```js
const target = 'Aa Bb 12,345 _$%&';

let regExp = /[\w,]+/g;

target.match(regExp);	// [ 'Aa', 'Bb', '12,345', '_' ]

regExp = /[\W,]+/g;

target.match(regExp);	// [ ' ', ' ', ',', ' ', '$%&' ]
```



#### 31.5.5 NOT 검색

[...]내의 ^은 not의 의미를 갖는다. 예를 들어, ^0-9는 숫자를 제외한 문자(\D)를 의미한다.

```js
const target = 'AA BB 12 Aa Bb';

const regExp = /[^0-9]+/g;

target.match(regExp);	// [ 'AA BB ', ' Aa Bb' ]
```



#### 31.5.6 시작 위치로 검색

[...]밖의 ^은 문자열의 시작을 의미한다. [...]안이면 NOT을 의미하니 주의하자.

```js
const target = 'https://poiemaweb.com';

// https로 시작하는지 검사한다.
const regExp = /^https/;

regExp.test(target);	// true
```



#### 31.5.7 마지막 위치로 검색

$는 문자열의 마지막을 의미한다.

```js
const target = 'https:/poiemaweb.com';

const regExp = /com$/;

regExp.test(target);	// true
```



### 31.6 자주 사용하는 정규표현식

#### 31.6.1 특정 단어로 시작하는지 검사

```js
const url = 'https://example.com';

// [] 바깥의 ^는 문자열의 시작을 의미하고 ?는 앞선 패턴이 최대 한번(있어도 되고 없어도 된다) 반복되는지를 의미한다.
// http:// 또는 https://로 시작하는지 검사한다.
/^https?:\/\//.test(url);	// true
/^(http|https):\/\//.test(url);	// true
```



#### 31.6.2 특정 단어로 끝나는지 검사

```js
const fileName = 'index.html';

/html$/.test(fileName);	// true
```



#### 31.6.3 숫자로만 이루어진 문자열인지 검사

```js
const target = '12345';

// ^: 숫자로 시작, +: 한번 이상 반복, $: 숫자로 끝남
/^\d+$/.test(target);	// true
```



#### 31.6.4 하나 이상의 공백으로 시작하는지 검사

\s는 여러가지 공백 문자를 의미한다. [\t\r\n\v\f]와 같은 의미다.

```js
const target = ' Hi!';

/^[\s]+/.test(target);	// true
```



#### 31.6.5 아이디로 사용 가능한지 검사

검색 대상 문자열이 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사해보자

```js
const id = 'abc123';

/^[A-Za-z0-9]{4,10}$/.test(id);	// true
```



#### 31.6.6 메일 주소 형식에 맞는지 검사

*는 0번 이상의 반복을 의미한다.

```js
const email = 'sanghyun2@gmail.com';

console.log(/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/.test(email));	// true
```



인터넷 메시지 형식 규약인 RFC 5322에 맞는 정교한 패턴 매칭이 필요하다면 다음과 같은 복잡한 패턴이 필요하다.

```js
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```



#### 31.6.7 핸드폰 번호 형식에 맞는지 검사

```js
const cellphone = '010-1234-5678';

/^\d{3}-\d{4}-\d{4}$/.test(cellphone);	// true
```



#### 31.6.8 특수 문자 포함 여부 검사

특수문자는 A-Za-z0-9 이외의 문자다.

```js
const target = 'abc#123';

(/[^A-Za-z0-9]/gi).test(target);	// true
```



다음 방식으로 대체할 수도 있다. 이 방식은 특수 문자를 선택적으로 검사할 수 있다는 장점이 있다

```js
(/[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi).test(target);
```



특수문자를 제거할 때는 String.prototype.replace 메서드를 사용한다.

```js
target.replace(/[^A-Za-z0-9]/gi, '');	// abc123
```

------

## 32장 String

표준 빌트인 객체 String은 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메서드를 제공한다.

### 32.1 String 생성자 함수

String 객체는 생성자 함수 객체다. new 연산자와 함께 호출하여 String 인스턴스를 생성할 수 있다. 생성자 함수에 인수를 전달하지 않으면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 래퍼 객체를 생성한다.

String 래퍼 객체는 배열과 마찬가지로 length 프로퍼티를 가지고 인덱스를 프로퍼티 키로, 문자를 프로퍼티 값으로 가지는 유사 배열 객체이다. 따라서 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.

문자열은 원시 값이므로 변경할 수 없다. 이때 에러가 발생하지 않는다.

```js
const strObj = new String('Lee');

strObj[0] = 'S';
console.log(strObj);	// 'Lee'
```

String 생성자 함수의 인수로 문자열이 아닌 값을 전달하면 인수를 문자열로 강제 변환한다.

```js
// 결과를 간단히만 표현했다
let strObj = new String(123);
console.log(strObj);	// '123'

strObj = new String(null);
console.log(strObj);	// 'null'
```

![image-20220312154713541](C:\Users\Sanghyun\AppData\Roaming\Typora\typora-user-images\image-20220312154713541.png)

명시적 타입 변환에서 살펴보았듯이 new 연산자를 사용하지 않고 String 생성자 함수를 호출하면 인스턴스가 아닌 문자열을 반환한다.

```js
String(1);			//'1'
String(NaN);		//'NaN'
String(Infinity);	//'Infinity'

String(true);		// 'true'
String(false);		// 'false'
```



### 32.2 length 프로퍼티

length 프로퍼티는 문자열의 문자 개수를 반환한다.

```js
'Hello'.length;			// 5
'안녕하세요!'.length;	 // 6
```



### 32.3 String 메서드

String 객체에는 원본 객체를 변경하는 String 메서드가 존재하지 않는다. String 메서드들은 언제나 새로운 문자열(문자열은 원시값이기 때문에 변경할 수 없다)을 반환한다.

#### 32.3.1 String.rototype.indexOf

대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫 번째 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = 'Hello World';

str.indexOf('l');	// 2
str.indexOf('or');	// 7
str.indexOf('x');	// -1
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.

```js
str.indexOf('l', 3);	// 3
```

indexOf메서드는 대상 문자열에 특정 문자열이 존재하는지 확인할 때 유용하다.



#### 32.3.2 String.prototype.search

대상 문자열에서 인수로 전달받은 정규표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환한다. 검색에 실패하면 -1을 반환한다.

```js
const str = 'Hello world';

str.search(/o/);	// 4
str.search(/x/);	// -1
```



#### 32.3.3 String.prototype.includes

대상 문자열에 인수로 전달받은 문자열이 포함되어 있는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
const str = 'Hello World';

str.includes('Hello');	// true
str.includes('');		// true
str.includes('x');		// false
str.includes();			// false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.



#### 32.3.4 String.prototype.startsWith

대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
const str = 'Hello World';

str.startsWith('He');	// true
str.startsWith('x');	// false
```

2번째 인수로 검색을 시작할 인덱스를 전달할 수 있다.



#### 32.3.5 String.prototype.endsWith

대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 불리언 값으로 반환한다.

```js
str = 'Hello World';

str.endsWith('ld');	// true
str.endsWith('x');	// false
```

2번째 인수로 검색할 문자열의 길이를 전달할 수 있다.



#### 32.3.6 String.prototype.charAt

대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환한다.

```js
const str = 'Hello World';

for(let i = 0; i < str.length; i++){
    console.log(str.charAt(i))l	// H e l l o
}
```

인덱스가 문자열의 범위를 벗어난 경우 빈 문자열을 반환한다.



#### 32.3.7 String.prototype.substring

대상 문자열에서 첫 번째 인수로 전달받은 인덱스에 위치하는 문자부터 두 번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전 문자까지의 부분 문자열을 반환한다.

```js
const str = 'Hello World';

str.substring(1, 4);	// ell
```

두 번째 인수를 생략하면 첫 번째 인수에서 부터 마지막까지 문자열을 반환한다.

```js
const str = 'Hello World';

str.substring(1);	// 'ello World'
```

substring 메서드는 두 번째 인수가 더 작아야 정상이다. 하지만 다음과 같이 인수를 전달해도 동작한다.

- 첫 번째 인수 > 두 번째 인수인 경우 두 인수는 교환된다.
- 인수 < 0 또는 NaN인 경우 0으로 취급된다.
- 인수 > 문자열의 길이인 경우 인수는 문자열의 길이로 취급된다.

```js
const str = ' Hello World'

str.substring(4, 1);	// 'ell'

str.substring(-2);	// 'Hello World'

str.substring(1, 100);	// 'ello World'
```



#### 32.3.8 String.prototype.slice

substring 메서드와 동일하게 동작한다. 단, 음수인 인수를 전달할 수 있다. 음수의 경우 뒤에서부터 n번째를 나타낸다.

```js
const str = 'hello world';

str.slice(0, 5);	// 'hello'

str.slice(2);		// 'llo world'

str.slice(-5);		// 'world'
```



#### 32.3.9 String.prototype.toUpperCase

대상 문자열을 모두 대문자로 변경한 문자열을 반환한다.

```js
const str = 'Hello World!';

str.toUpperCase();	// 'HELLO WORLD!'
```



#### 32.3.10 String.prototype.toLowerCase

대상 문자열을 모두 소문자로 변경한 문자열을 반환한다.

```js
const str = 'Hello World!';

str.toLowerCase();	// 'hello world!'
```



#### 32.3.11 String.prototype.trim

대상 문자열 앞뒤에 공백 문자가 있을 경우 이를 제거한 문자열을 반환한다.

```js
const str = '    foo  '

str.trim();		// 'foo'
```

현재는 trimStart, trimEnd를 사용해 대상 문자열 앞 또는 뒤에 있는 공백을 제거한 문자열을 반환할 수 있다.

String.prototype.replace 메서드에 정규 표현식을 전달하여 공백 문자를 제거할 수도 있다.

```js
const str = '    foo  ';

str.replace(/\s/g, '');		// 'foo'
str.replace(/^\s+/g, '');	// 'foo  '
str.replace(/\s$/g, '');	// '     foo'
```



#### 32.3.12 String.prototype.repeat

대상 문자열을 인수로 받은 정수만큼 반복해 연결한 새로운 문자열을 반환한다. 전달받은 인수가 0이면 빈 문자열을 반환하고, 음수이면 RangeError를 발생시킨다. 생략하면 기본값 0이 설정된다.

```js
const str = 'abc';

str.repeat();		// ''
str.repeat(0);		// ''
str.repeat(1);		// 'abc'
str.repeat(2);		// 'abcabc'
str.repeat(2.5);	// 'abcabc' 2.5가 2로 바뀌었다
str.repeat(-1);		// RangeError
```



#### 32.3.13 String.prototype.replace

대상 문자열에서 첫 번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두 번째 인수로 전달한 문자열로 치환한 문자열을 반환한다.

```js
const str = 'Hello world';

str.replace('world', 'Lee');	// 'Hello Lee'
```

검색된 문자열이 여럿 존재할 경우 첫 번째로 검색된 문자열만 치환한다.

```js
const str = 'Hello world world';

str.replace('world', 'Lee');	// 'Hello Lee world'
```

특수한 교체 패턴을 사용할 수 있다. 예를 들어 $&는 검색된 문자열을 의미한다.

```js
const str = 'Hello world';

str.replace('world', '<stong>$&</strong>');
```

replace 메서드의 두 번째 인수로 치환 함수를 전달할 수 있다.

```js
function camelToSnake(camelCase){
    return camelCase.replace(/.[A-Z]/g, match =>{
        console.log(match);
        return match[0] + '_' + match[1].toLowerCase();
    });
}

const cameCase = 'helloWorld';
camelToSnake(camelCase);	// 'hello_world'

function snakeToCamel(snakeCase){
    return snakeCase.replace(/_[a-z]]/g, match =>{
        console.log(match);
        return match[1].toUpperCase();
    });
}

const snakeCase = 'hello_world';
snakeToCamel(snakeCase);	// 'helloWorld'
```



#### 32.3.14 String.prototype.split

대상 문자열에서 첫 번째 인수로 전달한 문자열 또는 정규 표현식을 검색하여 문자열을 구분한 후 분리된 각 문자열로 이루어진 배열을 반환한다. 빈 문자열을 전달하면 각 문자를 모두 분리하고, 생략하면 대상 문자열 전체를 하나로 반환한다.

```js
const str = 'How are you doing?';

str.split(' ');		// [ 'How', 'are', 'you', 'doing?']

str.split(/\s/);	// [ 'How', 'are', 'you', 'doing?']

str.split();		// [ 'How are you doing?' ]
```

두 번째 인수로 배열의 길이를 지정할 수 있다.

```js
str.split(' ', 3);	// [ 'How', 'are', 'you' ] 배열의 길이가 3이다
```

------

## 33장 7번째 데이터 타입 Symbol

### 33.1 심벌이란?

ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값이다. 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다.



### 33.2 심벌 값의 생성

#### 33.2.1 Symbol 함수

심벌 값은 Symbol 함수를 호출하여 생성한다. 이때 생성된 심벌 값은 외부로 노출되지 않아 확인할 수 없으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```js
const mySymbol = Symbol();
console.log(typeof mySymbol);	// symbol

console.log(mySymbol);	// Symbol() 외부로 노출되지 않아 확인할 수 없다.
```



Symbol은 변경 불가능한 값이기 때문에 생성자 함수를 사용해서 생성하지 않는다. Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심벌 값에 대한 설명으로 디버깅 용도로만 사용되며, 심벌 값 생성에 어떠한 영향도 주지 않는다.

```js
const mySymbol1 = Symbol('mySymbol');
const mySymbol2 = Symbol('mySymbol');

console.log(mySymbol1 === mySymbol2);	// false
```



심벌 값도 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다.

```js
const mySymbol = Symbol('mySymbol');

console.log(mySymbol.description);	// mySymbol
console.log(mySymbol.toString());	// Symbol(mySymbol)
```



심벌 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다.

```js
const mySymbol = Symbol();

console.log(mySymbol + '');	// TypeError
console.log(+mySymbol);		// TypeError
```



단, 불리언 타입으로는 암묵적으로 타입 변환된다.

```js
consy mySymbol = Symbol();

console.log(!!mySymbol);	// true

if(mySymbol) console.log('mySymbol is not empty.');
```



#### 33.2.2 Symbol.for / Symbol.keyFor 메서드

Symbol.for 메서드는 인수로 전달받은 문자열을 키로 사용하여 키와 심벌 값의 쌍들이 저장되어 있는 전역 심벌 레지스트리에서 해당 키와 일치하는 심벌 값을 검색한다.

- 검색에 성공하면 새로운 심벌 값을 생성하지 않고 검색된 심벌 값을 반환한다.
- 검색에 실패하면 새로운 심벌 값을 생성하여 전달된 키로 전역 심벌 레지스트리에 저장한 후, 생성된 심벌 값을 반환한다.

```js
const s1 = Symbol.for('mySymbol');

const s2 = Symbol.for('mySymbol');

console.log(s1 === s2);
```

Symbol.for 메서드를 사용하면 전역에서 중복되지 않는 심벌 값을 단 하나만 생성하여 전역 심벌 레지스트리를 통해 공유할 수 있다.



Symbol.keyFor 메서드를 사용하면 전역 심벌 레지스트리에 저장된 심벌 값의 키를 추출할 수 있다.

```js
const s1 = Symbol.for('mySymbol');

Symbol.keyFor(s1);	// mySymbol

// Symbol 함수를 호출하여 생성한 심벌 값은 전역 심벌 레지스트리에 등록되어 관리되지 않는다.
const s2 = Symbol('foo');

Symbol.keyFor(s2);	// undefined
```



### 33.3 심벌과 상수

```js
const Direction = {
    UP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4
};

const myDirection = Direction.UP;

if(myDirection === Direction.UP){
    console.log('You are going UP.');
}
```

위 예제같이 값에는 특별한 의미가 없고 이름 자체에 의미가 있는 경우가 있다. 상수 값 1, 2, 3, 4는 변경될 수 있기 때문에 다른 변수 값과 중복될 수 있다. 이러한 경우 변경/중복될 상수 대신 중복될 가능성이 없는 유일무이한 심벌 값을 사용할 수 있다.

```js
const Direction = {
    UP: Symbol('up'),
    DOWN: Symbol('down'),
    LEFT: Symbol('left'),
    RIGHT: Symbol('right')
};

const myDirection = Direction.UP;

if(myDirection === Direction.up){
    console.log('You are going UP.');
}
```



### 33.4 심벌과 프로퍼티 키

객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 만들 수 있으며, 동적으로 생성할 수 있다.

심벌 값으로 프로퍼티 키를 만들 때는 대괄호를 사용해야 한다. 접근할 때도 마찬가지로 대괄호를 사용한다.

```js
const obj = {
    [Symbol.for('mySymbol')]: 1
};

obj[Symbol.for('mySymbol')];	// 1
```

심벌은 유일무이한 값이므로 다른 프로퍼티 키와 절대 충돌하지 않는다.



### 33.5 심벌과 프로퍼티 은닉

심벌 값을 키로 생성한 프로퍼티는 for ... in 문이나 Object.keys 등의 메서드로 찾을 수 없다. 이처럼 심벌 값을 키로 사용하면 프로퍼티를 은닉할 수 있다.

```js
const obj = {
    [Symbol('mySymbol')]: 1,
};

for(const key in obj){
    console.log(key);	// 아무것도 출력되지 않는다.
}

console.log(Object.keys(obj));	// []
console.log(Object.getOwnPropertyNames(obj));	// []
```

 

하지만 ES6에서 도입된 Object.getOwnPropertySymbols 메서드를 사용하면 찾을 수 있다.

```js
const obj = {
    [Symbol('mySymbol')]: 1,
};

console.log(Object.getOwnPropertySymbols(obj));	// [Symbol(mySymbol)]

const symbolKey1 = Object.getOwnPropertySymbols(obj)[0];
console.log(obj[symbolKey1]);
```



### 33.6 심벌과 표준 빌트인 객체 확장

일반적으로 표준 빌트인 객체에 사용자 정의 메서드를 직접 추가하여 확장하는 것은 권장하지 않는다.

```js
Array.prototype.sum = function(){
    return this.reduce((acc, cur) => acc + cur, 0);
};

[1, 2].sum();	// 3
```

그 이유는 미래에 추가될 메서드의 이름이 중복될 수 있기 때문이다. 만약 이름이 같은 메서드를 이미 만들어 놨다면 추가된 함수를 사용자 정의 메서드가 덮어쓴다. 하지만 심벌을 이용한다면 이런 위험 없이 안전하게 확장할 수 있다.

```js
Array.prototype[Symbol.for('sum')] = function(){
    return this.reduce((acc, cur) => acc + cur, 0);
};

[1, 2][Symbol.for('sum')]();	// 3
```



### 33.7 Well-known Symbol

자바스크립트가 기본 제공하는 빌트인 심벌 값이 있다. 브라우저 콘솔에서 Symbol 함수를 참조하여 보자.

![image-20220316170549214](C:\Users\Sanghyun\AppData\Roaming\Typora\typora-user-images\image-20220316170549214.png)

자바스크립트가 기본 제공하는 빌트인 심벌 값을 ECMAScript 사양에서는 Well-known Symbol이라 부른다. 이들은 자바스크립트 엔진의 내부 알고리즘에 사용된다.

------

## 34장 이터러블

### 34.1 이터레이션 프로토콜

이터레이션 프로토콜은 순회 가능한 데이터 컬렉션(자료구조)을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

ES6 이전의 순회 가능한 데이터 컬렉션(배열, 문자열, 유사 배열 객체 등)은 통일된 규약 없이 각자 나름의 구조를 가지고 for 문, for ... in 문, forEach 메서드 등 다양한 방법으로 순회할 수 있었다. ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of 문, 스프레드 문법, 배열 디스트럭처렁 할당의 대상으로 사용할 수 있도록 일원화했다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.

- 이터러블 프로토콜

  Well-known Symbol인 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이러한 규약을 이터러블 프로토콜이라 하며, **이터러블 프로토콜을 준수한 객체를 이터러블이라 한다.**

- 이터레이터 프로토콜

  이터러블의 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 newxt 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이러한 규약을 이터레이터 프로토콜이라 하며, 이터레이터 프로토콜을 준수한 객체를 이터레이터라 한다. 이터레이터는 이터러블의 요소를 탐색하기 위한 포인터 역할을 한다.



#### 34.1.1 이터러블

이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다.

```js
// 이터러블을 확인하는 함수
const isIterable = v => v !== null && typeof v[Symbol.iterator] === 'function';

isIterable([]);			// true
isIterable('');			// true
isIterable(new Map());	// true
isIterable(new Set());	// true
isIterable({});			// true
```



배열은 Array.prototype의 Symbol.iterator 메서드를 상속받는 이터러블이다. 이터러블은 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다.

```js
const array = [1, 2, 3];

console.log(Symbol.iterator in array);	// true

for(const item of array){
    console.log(item);
}

console.log([...array]);	// [1, 2, 3]

const [a, ...rest] = array;
console.log(a, rest);	// 1, [2, 3]
```



Symbol.iterator 메서드를 직접 구현하거나 상속받지 않은 일반 객체는 이터러블이 아니다. 따라서 for ... of 문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 없다.

```js
const obj = {a: 1, b: 2};

console.log(Symbol.iterator in obj);	// false
```



#### 34.1.2 이터레이터

Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. **이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.**

```js
const array = [1, 2, 3];

const iterator = array[Symbol.iterator]();

console.log('next' in iterator);	// true
```



next 메서드는 이터러블의 각 요소를 순회하기 위한 포인터의 역할을 한다. next 메서드를 호출하면 이터러블을 순차적으로 한 단계씩 순회하며 순회 결과를 나타내는 **이터레이터 리절트 객체**를 반환한다.

```js
const array = [1, 2, 3];

const iterator = array[Symbol.iterator]();

// 이터레이터 리절트 객체는 value와 done 프로퍼티를 갖는 객체다.
console.log(iterator.next());	// { value: 1, done: false }
console.log(iterator.next());	// { value: 2, done: false }
console.log(iterator.next());	// { value: 3, done: false }
console.log(iterator.next());	// { value: undefined, done: true }
```

value는 현재 순회 중인 이터러블의 값을 나타내며 done 프로퍼티는 순회 완료 여부를 나타낸다.



### 34.2 빌트인 이터러블

자바스크립트는 이터레이션 프로토콜을 준수한 객체인 빌트인 이터러블을 제공한다.

| 빌트인 이터러블 | Symbol.iterator 메서드                                       |
| --------------- | ------------------------------------------------------------ |
| Array           | Array.prototype[Symbol.iterator]                             |
| String          | String.prototype[Symbol.iterator]                            |
| Map             | Map.prototype[Symbol.iterator]                               |
| Set             | Set.prototype[Symbol.iterator]                               |
| TypedArray      | TypedArray.prototype[Symbol.iterator]                        |
| arguments       | arguments[Symbol.iterator]                                   |
| DOM 컬렉션      | NodeList.prototype[Symbol.iterator]<br />HTMLCollection.prototype[Symbol.iterator] |



### 34.3 for ... of 문

for ... of 문은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.

```js
for (변수선언문 of 이터러블) {...}
```

for ... in 문의 형식과 매우 유사하다.

```js
for (변수선언문 in 객체) {...}
```

for ... of 문은 내부적으로 이터레이터의 next 메서드를 호출하여 이터러블을 순회하며 next 메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for ... of 문의 변수에 할당한다. 그리고 done 프로퍼티의 값이 false이면 이터러블의 순회를 계속하고 true면 순회를 중단한다.

```js
for (const item of [1, 2, 3]){
    // item 변수에 순차적으로 1, 2, 3이 할당된다.
    console.log(item);	// 1 2 3
}
```



### 34.4 이터러블과 유사 배열 객체

유사 배열 객체는 배열과 비슷하기 때문에 length 프로퍼티를 가지고 for 문을 이용하여 객체를 순회할 수 있다. 하지만 유사 배열 객체는 이터러블이 아니기 때문에 for ... of 문을 사용할 수 없다.

단, arguments, NodeList, HTMLCollection은 유사 배열 객체이면서 이터러블이다.



### 34.5 이터레이션 프로토콜의 필요성

ES6 이전의 순회 가능한 데이터 컬렉션들(배열, 문자열 등)은 통일된 규약 없이 각자의 구조를 가지고 for, for ... in, forEach메서드 등으로 순회할 수 있었다. ES6에서는 이 컬렉션들을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for ... of 문, 스프레드 문법, 디스트럭처링 할당의 대상으로 사용할 수 있도록 일원화했다.

※ 네트워크 프로토콜이 만들어진 이유와 비슷한 것 같다. 프로토콜이 생기기 이전에는 각 회사별로 자신들의 제품을 사용하기 위한 방법이 있었는데 프로토콜이 만들어 짐으로써 그 방법을 통일화시켜 어떤 회사 제품을 사용하더라도 동일한 방법으로 사용하게 되는 것이다.

이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 **데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.**



### 34.6 사용자 정의 이터러블

#### 34.6.1 사용자 정의 이터러블 구현

이터레이션 프로토콜을 준수하지 않는 일반 객체도 이터레이션 프로토콜을 준수하도록 구현하면 사용자 정의 이터러블이 된다.

```js
// 피보나치 수열을 구현해보자
const fibonacci = {
    [Symbol.iterator](){
        let [pre, cur] = [0, 1];
        const max = 10;
        
        return {
            next(){
                [pre, cur] = [cur, pre + cur];
                
                return {value: cur, done: cur >= max };
            }
        };
    }
};

for(const num of fibonacci){
    console.log(num);	.. 1 2 3 5 8
}
```

Symbol.iterator 메서드를 구현하고 next 메서드를 갖는 이터레이터를 반환하도록 한다. 그리고 next 메서드는 done과 value 프로퍼티를 가지는 이터레이터 리절트 객체를 반환한다.



#### 34.6.2 이터러블을 생성하는 함수

위 예제는 최댓값을 고정해놨지만, 외부에서 전달할 수 있도록 수정해보자

```js
const fibonacciFunc = function(max){
    let [pre, cur] = [0, 1];
    
    return {
        [Symbol.iterator](){
            return {
                next(){
                    [pre, cur] = [cur, pre + cur];
                    return { value: cur, done: cur >= max };
                }
            };
        }
    };
}

for (const num of fibonacciFunc(10)){
    console.log(num);	// 1 2 3 5 8
}
```



#### 34.6.3 이터러블이면서 이터레이터인 객체를 생성하는 함수

이터러블이면서 이터레이터인 객체를 생성하면 Symbol.iterator 메서드를 호출하지 않아도 된다.

```js
// 이터러블이면서 이터레이터인 객체.
// 이터레이터를 반환하는 Symbol.iterator 메서드와 이터레이션 리절트 객체를 반환하는 next 메서드를 소유한다.
{
    [Symbol.iterator](){ return this; },
    next(){
        return { value: any, done: boolean};
    }
}
```



fibonacciFunc 함수를 이터러블이면서 이터레이터인 객체를 생성하여 반환하는 함수로 변경해보자

```js
const fibonacciFunc = function(max){
    let [pre,cur] = [0, 1];
    
    return {
        [Symbol.iterator]() { return this; },
        next(){
            [pre, cur] = [cur, pre + cur];
            return { value: cur, done: cur >= max };
        }
    };
};

let iter = fibonacciFunc(10);	// iter는 이터러블이면서 이터레이터다.

for(const num of iter){
    console.log(num);	// 1 2 3 5 8
}

iter = fibonacciFunc(10);

console.log(iter.next());	// { value: 1, done: false }
console.log(iter.next());	// { value: 2, done: false }
console.log(iter.next());	// { value: 3, done: false }
console.log(iter.next());	// { value: 5, done: false }
console.log(iter.next());	// { value: 8, done: false }
console.log(iter.next());	// { value: 13, done: true }
```



#### 34.6.4 무한 이터러블과 지연 평가

```js
const fibonacciFunc = function(){
    let [pre, cur] = [0, 1];
    
    return {
        [Symbol.iterator]() { return this; },
        next(){
            [pre, cur] = [cur, pre + cur];
            // done 이 생략되었으니 무한으로 호출 가능하다.
            return { value: cur };
        }
    };
};

for(const num of fibonacciFunc()){
    if(num > 10000) break;
    console.log(num);	// 1 2 3 5 8 ... 4181 6765
}

// 배열 디스트럭처링 할당을 통해 무한 이터러블에서 3개의 요소만 취득한다.
const [f1, f2, f3] = fibonacciFunc();
console.log(f1, f2, f3);	// 1 2 3
```

배열이나 문자열 등은 모든 데이터를 메모리에 미리 확보한 다음 데이터를 공급한다. 하지만 위 예제의 이터러블은 **지연 평가**를 통해 데이터를 생성한다. 지연 평가는데이터가 필요한 시점에 데이터를 생성하는 기법이다.

위 예제의 fibonacciFUnc는 무한 이터러블을 생성한다. 하지만 for ... of 문이나 배열 디스트럭처링 할당 등이 실행되기 이전까지는 데이터를 생성하지 않는다. next가 호출되기 전까지 데이터를 생성을 지연하는 것이다.

지연 평가를 사용하면 불필요한 데이터를 미리 생성하지 않으므로 빠른 실행 속도를 기대할 수 있고 불필요한 메모리를 소비하지 않으며 무한도 표현할 수 있다는 장점이 있다.

------

## 35장 스프레드 문법

ES6에서 도입된 스프레드 문법 ...은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만든다.

스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, Set, DOM 컬렉션, arguments와 같이 for ... of 문으로 순회할 수 있는 이터러블에 한정된다.

```js
console.log(...[1, 2, 3]);							// 1 2 3

console.log(...'Hello');							// H e l l o

console.log(...new Map([['a', '1'], ['b', '2']]));	// [ 'a', '1' ] [ 'b', '2' ]

console.log(...new Set([1, 2, 3]));					// 1 2 3

console.log(...{a: 1, b: 2});						// TypeError: Found non-callable @@iterator
```

위 예제에서 ...[1, 2, 3]은 배열을 펼쳐서 개별적인 값들의 목록 1 2 3으로 만든다. 이때 1 2 3은 값이 아니라 값들의 목록이다(= 스프레드 문법의 결과는 값이 아니다). 따라서 스프레드 문법의 결과는 변수에 할당할 수 없다.

```js
const list = ...[1, 2, 3];	// SyntaxError
```



스프레드 문법의 결과물은 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다.

- 함수 호출문의 인수 목록
- 배열 리터럴의 요소 목록
- 객체 리터럴의 프로퍼티 목록



### 35.1 함수 호출문의 인수 목록에서 사용하는 경우

배열을 펼쳐서 이를 함수의 인수 목록으로 전달해야 하는 경우가 있다.

```js
const arr = [1, 2, 3];

const max = Math.max(arr);	// NaN
```

Math.max 메서드에는 배열을 인수로 전달하면 NaN을 결과로 반환한다. 이 문제를 해결하기 위해서는 배열을 펼쳐서 요소들을 목록으로 만들어 Math.max의 인수로 전달해야 한다.

스프레드 문법 이전에는 Function.prototype.apply를 사용했다.

```js
var arr = [1, 2, 3];

var max = Math.max.apply(null, arr);	// 3

// 스프레드 문법 이후로는 더 간결하고 가독성이 좋아졌다
max = Math.max(...arr);
```



스프레드 문법은 Rest 파라미터와 형태가 동일하여 혼동할 수 있으니 주의해야 한다.

Rest 파라미터는 전달받은 인수들의 목록을 배열로 바꾸기 위해 매개변수의 앞에 사용하고, 스프레드 문법은 여러 개의 하나로 뭉쳐있는 이터러블을 펼쳐서 개별적인 값들의 목록으로 만든다. Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다.

```js
function foo(...rest){
    console.log(rest);	// Rest 파라미터 1 2 3 -> [1, 2, 3]
}

foo(...[1, 2, 3]);	// 스프레드 문법 [1, 2, 3] -> 1 2 3
```



### 35.2 배열 리터럴 내부에서 사용하는 경우

 스프레드 문법은 배열 리터럴에서 사용하면 ES5에서 사용하던 기존 방식보다 더욱 간결하고 가독성 좋게 표현할 수 있으니 사용하던 방식과 비교하여 살펴보자



#### 35.2.1 concat

2개의 배열을 1개의 배열로 결합하고 싶을 때 사용하는 concat 메서드

```js
// ES5
var arr = [1, 2].concat([3, 4]);
console.log(arr);	// [1, 2, 3, 4]

// ES6
const arr = [...[1, 2], ...[3, 4]];
console.log(arr);	// [1, 2, 3, 4]
```



#### 35.2.2 splice

배열의 중간에 요소를 추가하거나 제거할때 사용하는 splice 메서드

```js
// ES5
var arr1 = [1, 4]
var arr2 = [2, 3]

arr1.splice(1, 0, arr2);
console.log(arr1);	// [1, [2, 3], 4]

// ES6
arr1.splice(1, 0, ...arr2);
console.log(arr1);	// [1, 2, 3, 4]
```



#### 35.2.3 배열 복사

배열을 복사할때 사용하는 slice 메서드

```js
// ES5
var origin = [1, 2];
var copy = origin.slice();

console.log(copy);	// [1, 2]
console.log(copy === origin);	// false

// ES6
const origin = [1, 2];
const copy = [...origin];

console.log(copy);	// [1, 2]
console.log(copy === origin);	// false
```



#### 35.2.4 이터러블을 배열로 변환

이터러블을 배열로 변환할 때 Function.prototype.apply 또는 Function.prototype.call 메서드를 사용하여 slice 메서드를 호출했었다.

```js
// ES5
function sum (){
    // 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
    var args = Array.prototype.slice.call(arguments);
    
    return args.reduce(function(pre, cur){
        return pre + cur;
    }, 0);
}
console.log(sum(1, 2, 3));	// 6

// 이터러블이 아닌 유사 배열 객체
const arrayLike = {
    0: 1,
    1: 2,
    2: 3,
    length: 3
};

const arr = Array.prototype.slice.call(arrayLike);	// [1, 2, 3]
console.log(Array.isArray(arr));	// true
```

스프레드 문법을 사용하면 좀 더 간편하게 배열로 변환할 수 있다.

```js
// ES6
function sum(){
    // arguments객체는 유사 배열 객체이지만 이터러블이니 스프레드 문법을 사용할 수 있다
    return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3));	// 6
```

Rest 파라미터를 사용하면 더 낫다

```js
const sum = (...args) => args,reduce((pre, cur) => pre + cur, 0);

console.log(sum(1, 2, 3));	// 6
```

이터러블이 아닌 유사 배열 객체를 배열로 바꾸려면 Array.from 메서드를 사용한다.



### 35.3 객체 리터럴 내부에서 사용하는 경우

Rest프로퍼티와 함꼐 TC39 프로세스의 stage 4 단계에 제안되어 있는 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법을 사용할 수 있다. 스프레드 문법의 대상은 이터러블이어야 하지만 이 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다.

```js
const obj = { x: 1, y: 2 };
const copy = { ...obj };
console.log(copy);	// { x: 1, y: 2 }
console.log(copy === obj);	// false

// 객체 병합
const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };
console.log(merged);	// { x: 1, y: 2, a: 3, b: 4 }
```



스프레드 프로퍼티가 제안되기 이전에는 ES6에서 도입된 Object.assign 메서드를 사용하여 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경 또는 추가했다.

```js
// 객체 병합
const merged = Object.assign({}, { x: 1, y: 2 }, { y: 10, z: 3 });
console.log(merged);	// { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = Object.assign({}, { x: 1, y: 2 }, { y: 100 });
console.log(changed);	// { x: 1, y: 100 }

// 프로퍼티 추가
const added = Object.assign({}, { x: 1, y: 2 }, { z: 0 });
console.log(added);		// { x: 1, y: 2, z: 0}
```



스프레드 프로퍼티는 Object.assign 메서드를 대체할 수 있다.

```js
// 객체 병합
const merged = { ...{ x: 1, y: 2 }, ...{ y:10, z: 3 } };
console.log(merged);	// { x: 1, y: 10, z: 3 }

// 특정 프로퍼티 변경
const changed = { ...{ x: 1, y: 2 }, y: 100 };
console.log(changed);	// { x: 1, y: 100 }

// 프로퍼티 추가
const added = { ...{ x: 1, y: 2 }, z: 0 };
console.log(added);		// { x: 1, y: 2, z: 0}
```

------

## 36장 디스트럭처링 할당

디스트럭처링 할당은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.



### 36.1 배열 디스트럭처링 할당

ES5에서 배열을 디스트럭처링하여 변수에 할당하는 방법은 다음과 같다.

```js
var arr = [1, 2, 3];

var one = arr[0];
var two = arr[1];
var three = arr[2];
```



ES6의 배열 디스트럭처링은 다음과 같이 쓸 수 있다. 하지만 **대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.**

```js
const arr = [1, 2, 3];

const [one, two, three] = arr;
```



우변에 이터러블을 할당하지 않으면 에러가 발생한다.

```js
const [x, y];	// SyntaxError

const [a, b] = {};	// TypeError: {} is not iterable
```



배열 디스트럭처링 할당의 변수 선언문은 선언과 할당을 분리할 수 있지만, 이 경우  const 키워드로 변수를 선언할 수 없으므로 권장하지 않는다.

```js
let x, y;
[x, y] = [1, 2];
```



배열 디스트럭처링 할당의 기준은 배열의 인덱스다. 순서대로 할당된다는 의미다. 이때 변수의 개수와 이터러블의 요소 개수가 반드시 일치할 필요는 없다.

```js
const [a, b] = [1, 2];
console.log(a, b);	// 1 2

const [c, d] = [1];
console.log(c, d);	// 1 undefined

const [e, f] = [1, 2, 3];
console.log(e, f);	// 1 2

const [g, , h] = [1, 2, 3];
console.log(g, h);	// 1 3
```



배열 디스트럭처링 할당을 위해 변수의 기본값을 설정할 수 있다.

```js
const [a, b, c = 3] = [1, 2];
console.log(a, b, c);	// 1 2 3

// 기본값보다 할당 값이 우선이다.
const [e, f = 10, g = 3] = [1, 2];
console.log(e, f, g);	// 1 2 3
```



배열 디스트럭처링은 배열과 같은 이터러블에서 필요한 요소만 추출하여 변수에 할당하고 싶을 때 유용하다.

```js
// URL을 파싱하여 protocol, host, path 프로퍼티를 갖는 객체를 생성해 반환한다.
function parseURL(url = ''){
    // '://' 앞의 문자열(protocol)과 '/'이전의 '/'로 시작하지 않는 문자열(host)과 '/' 이후의 문자열(path)을 검색한다
    const parsedURL = url.match(/^(\w+):\/\/([^/]+)\/(.*)$/);
    console.log(parsedURL);
	/*
	{
		'https://developer.mozilla.org/ko/docs/Web/JavaScript',
		'https',
		'developer,mozilla.org',
		'ko/docs/Web/JavaScript',
		index: 0,
		input: 'https://developer.mozilla.org/ko/docs/Web/JavaScript',
		groups: undefined
	}
	*/
    
    if(!parsedURL) return {};
    
    const [, protocol, host, path] = parsedURL;
    return { protocol, host, path };
}

const paredURL = parsedURL('https://developer.mozilla.org/ko/docs/Web/JavaScript');
console.log(parsedURL);
/*
{
	protocol: 'https',
	host: 'developer.mozilla.org',
	path: 'ko/docs/Web/JavaScript'
}
*/
```



배열 디스트럭처링 할당을 위한 변수에 Rest 요소 ...을 사용할 수 있다. Rest 요소는 파라미터와 마찬가지로 마지막에 위치해야 한다.

```js
const [x, ...y] = [1, 2, 3];
console.log(x, y);	// 1 [2, 3]
```



### 36.2 객체 디스트럭처링 할당

ES5에서 객체의 각 프로퍼티를 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용해야 한다.

```js
var user = { firstName: 'Sanghyun', last: 'Park' };

var firstName = user.firstName;
var lastName = user.lastName;

console.log(firstName, lastName);	// Sanghyun Park
```



ES6의 객체 디스트럭처링 할당의 대상은 객체이어야 하며, 할당 기준을 프로퍼티 키다.

```js
const user = { firstName: 'Sanghyun', lastName: 'Park' };

const { lastName, firstName } = user;

console.log(firstName, lastName);	// Sanghyun Park
```



배열 디스트럭처링 할당과 마찬가지로 객체 디스트럭처링도 할당 연산자 왼쪽에 값을 할당받을 변수를 선언해야 하는데, 이때 변수를 객체 리터럴 형태로 선언한다.

```js
const { lastName, firstName } = { firstName: 'Sanghyun', lastName: 'Park' };
```



객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당받으려면 다음과 같이 변수를 선언해야 한다.

```js
const user = { firstName: 'Sanghyun', lastName: 'Park' };

const { lastName: ln, firstName: fn } = user;

console.log(fn, ln);	// Sanghyun Park
```



변수에 기본 값을 할당할 수 있다.

```js
const { firstName = 'Sanghyun', lastName } = { lastName: 'Park' };

const { firstName: fn = 'Sanghyun', lastName: ln } = {lastName: 'Park'};
```



객체 디스트럭처링 할당은 객체에서 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하다.

```js
const str = 'Hello';

const { length } = str;
console.log(length);	// 5

const todo = { id: 1, content: 'HTML', completed: true };
const { id } = todo;
console.log(id);	// 1
```



객체 디스트럭처링 할당은 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다.

```js
function printTodo(todo){
    console.log(`할일 ${todo.content}은 ${todo.completed ? '완료' : '비완료'} 상태입니다.`)
}

printTodo({ id: 1, content: 'HTML', completed: true });	// 할일 HTML은 완료 상태입니다.

// 이것을 디스트럭처링 할당을 사용하면 더 간단하게 표현할 수 있다.
function printTodo({ content, completed }){
    console.log(`할일 ${content}은 ${completed ? '완료' : '비완료'} 상태입니다.`);
}

printTodo({ id: 1, content: 'HTML', completed: true })
```



배열의 요소가 객체인 경우 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다.

```js
const todos = [
    { id: 1, content: 'HTML', completed: true },
    { id: 2, content: 'CSS', completed: false },
    { id: 3, content: 'JS', completed: false }
];

const [, { id }] = todos;
console.log(id);	// 2
```



중첩 객체의 경우 다음과 같이 사용한다.

```js
const user = {
    name: 'Lee',
    address: {
        zipCode: '03068',
        city: 'Seoul'
    }
};

const { address: {city} } = user;
console.log(city);	// Seoul
```



Rest 파라미터와 유사하게 Rest 프로퍼티 ...을 사용할 수 있다.

```js
const { x, ...rest } = { x: 1, y: 2, z: 3 };
console.log(x, rest);	// 1 { y: 2, z: 3 }
```



## 37장 Set과 Map

### 37.1 Set

Set 객체는 중복되지 않는 유일한 값들의 집합이다. 배열과 유사하지만 차이가 있다.

| 구분                                | 배열 | Set객체 |
| ----------------------------------- | ---- | ------- |
| 동일한 값을 중복하여 포함할 수 있다 | O    | X       |
| 요소 순서에 의미가 있다             | O    | X       |
| 인덱스로 요소에 접근할 수 있다      | O    | X       |

Set객체의 특성은 수학적 집합과 일치한다. 따라서 Set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.



#### 37.1.1 Set 객체의 생성

Set 생성자 함수를 통해 Set 객체를 생성할 수 있다. Set 생성자 함수에 인수를 전달하지 않으면 객체가 생성된다.

```js
const set = new Set();
console.log(set);	// Set(0) {}
```



Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.

```js
const set1 = new Set([1, 2, 3, 3]);
copnsole.log(set1);	// Set(3) {1, 2, 3}

const set2 = new Set('hello');
console.log(set2);	// Set(4) {'h', 'e', 'l', 'o'}
```



Set을 사용하여 배열의 중복을 제거할 수 있다.

```js
const uniq = array => array.filter((v, i, self) => self.indexOf(v) === i );
console.log(uniq([2, 1, 2, 3, 4, 3, 4]));	// [2, 1, 3, 4]

const uniq = array => [...new Set(array)];
console.log(uniq([2, 1, 2, 3, 4, 3, 4]));	// [2, 1, 3, 4]
```



#### 37.1.2 요소 개수 확인

Set 객체의 요소 개수를 확인할 떄는 Set.prototype.size 프로퍼티를 사용한다.

```js
const { size } = new Set([1, 2, 3, 3]);
console.log(size);	// 3
```



size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.

```js
const set = new Set([1, 2, 3]);

console.log(Object.getOwnPropertyDescriptor(Set.prototype, 'size'));
/*
{
  get: [Function: get size],
  set: undefined,
  enumerable: false,
  configurable: true
}
*/

set.size = 10; 	// 무시된다.
console.log(set.size);	// 3
```



#### 37.1.3 요소 추가

Set 객체에 요소를 추가할 때는 Set.prototype.add 메서드를 사용한다.

```js
const set = new Set();
console.log(set);	// Set(0) {}

set.add(1);
console.log(set);	// Set(1) {1}
```



add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 연속적으로 호출 할 수 있다.

```js
const set = new Set();

set.add(1).add(2);
console.log(set);	// Set(2) {1, 2}
```

일치 비교 연산자 ===은 NaN을 다르다고 평가하지만 Set 객체는 NaN을 갖다고 평가하여 중복 추가를 혀용하지 않는다.



Set 객체는 객체나 배열과 같이 자바스크립트의 모든 값을 요소로 저장할 수 있다.

```js
const set = new Set();

set.add(1).add('a').add(true).add(undefined).add(null).add({}).add([]).add(()=>{})
```



#### 37.1.4 요소 존재 여부 확인

Set 객체에 특정 요소가 존재하는지 확인하려면 Set.prototype.has 메서드를 사용한다.

```js
const set = new Set([1, 2, 3]);

console.log(set.has(2));	// true
console.log(set.has(4));	// false
```



#### 37.1.5 요소 삭제

Set 객체의 특정 요소를 삭제하려면 Set.prototype.delete 메서드를 사용한다.

```js
const set = new Set([1, 2, 3]);

set.delete(2);
console.log(set);	// Set(2) {1, 3}

set.delete(1);
console.log(set);	// Set(1) {3}

// 존재하지 않는 요소를 삭제하려 하면 에러 없이 무시된다
set.delete(1);
console.log(set);	// Set(1) {3}
```

delete 메서드는 불리언 값을 반환하기 때문에 add 메서드와 달리 연속으로 호출할 수 없다.



#### 37.1.6 요소 일괄 삭제

Set 객체의 모든 요소를 일괄 삭제하려면 Set.prototype.clear 메서드를 사용한다.

```js
const set = new Set([1, 2, 3]);

set.clear();
console.log(set);	// Set(0) {}
```



#### 37.1.7 요소 순회

Set 객체의 요소를 순회하려면 Set.prototype.forEach 메서드를 사용한다. Set.prototype.forEach 메서드는 Array.prototype.forEach 메서드와 유사하게 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체를 인수로 전달한다.

- 첫 번째 인수: 현재 순회 중인 요소값
- 두 번째 인수: 현재 순회 중인 요소값
- 세 번째 인수: 현재 순회 중인 Set 객체 자체

1, 2번째 인수가 같은 이유는 Array.prototype.forEach 메서드와 인터페이스를 통일하기 위함이기 때문에 의미는 없다.

```js
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set) => console.log(v, v2, set));
/*
1 1 Set(3) { 1, 2, 3 }
2 2 Set(3) { 1, 2, 3 }
3 3 Set(3) { 1, 2, 3 }
*/
```



Set 객체는 이터러블이기 때문에 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링의 대상이 될 수 있다.

```js
const set = new Set([1, 2, 3]);

console.log(Symbol.iterator in set);	// true

for(const value of set){
    console.log(value);	// 1 2 3
}

console.log([...set]);	// [1, 2, 3]

const [a, ...rest] = set;
console.log(a, rest);	// 1, [2, 3]
```

Set 객체는 순서에 의미를 갖지 않지만 순회하는 순서는 요소가 추가된 순서를 따른다.



#### 17.1.8 집합 연산

Set 객체는 수학적 집합을 구현하기 위한 자료구조다. 따라서 집합 연산을 구현할 수 있다.

##### 교집합

```js
Set.prototype.intersection = function(set){
    const result = new Set();
    
    for(const value of set){
        if(this.has(value)) result.add(value);
    }
    
    return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB));	// Set(2) {2, 4}
console.log(setB.intersection(setA));	// Set(2) {2, 4}
```



방법2

```js
Set.prototype.intersection = function(set){
    return new Set([...this].filter(v => set.has(v)));
}

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.intersection(setB));	// Set(2) {2, 4}
console.log(setB.intersection(setA));	// Set(2) {2, 4}
```



##### 합집합

```js
Set.prototype.union = function (set){
    const result = new Set(this);
    
    for(const value of set){
        result.add(value);
    }
    
    return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.union(setB));	// Set(4) {1, 2, 3, 4}
console.log(setB.union(setA));	// Set(4) {2, 4, 1, 3}
```



방법2

```js
Set.prototype.union = function(set){
    return new Set([...this, ...set]);
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.union(setB));	// Set(4) {1, 2, 3, 4}
console.log(setB.union(setA));	// Set(4) {2, 4, 1, 3}
```



##### 차집합

```js
Set.prototype.difference = function(set){
    const result = new Set(this);
    
    for(const value of set){
        result.delete(value);
    }
    
    return result;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.differece(setB));	// Set(2) {1, 3}
console.log(setB.differece(setA));	// Set(0) {}
```



방법2

```js
Set.prototype.differece = function(set){
    return new Set([...this].filter(v => !set.has(v)));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.differece(setB));	// Set(2) {1, 3}
console.log(setB.differece(setA));	// Set(0) {}
```



##### 부분 집합과 상위 집합

```js
Set.prototype.isSuperset = function(subset){
    for(const value of subset){
        if(!this.has(value)) return false;
    }
    
    return true;
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.isSuperset(setB));	// true
console.log(setB.isSuperset(setA));	// false
```



방법2

```js
Set.prototype.isSuperset = function(subset){
    const supersetArr = [...this];
    return [...subset].every(v => supersetArr.includes(v));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);

console.log(setA.isSuperset(setB));	// true
console.log(setB.isSuperset(setA));	// false
```



### 37.2 Map

Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. 객체와 유사하지만 다음과 같은 차이가 있다.

| 구분                   | 객체                    | Map 객체              |
| ---------------------- | ----------------------- | --------------------- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값     | 객체를 포함한 모든 값 |
| 이터러블               | X                       | O                     |
| 요소 개수 확인         | Object.keys(obj).length | map.size              |



#### 37.2.1 Map 객체의 생성

Map 객체는 Map 생성자 함수로 생성한다.

```js
const map = new Map();
console.log(map);	// Map(0) {}
```



Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.

```js
const map1 = new Map([['key1', 'value1'], ['key2', 'value2']]);
console.log(map1);	// Map(2) { 'key1' => 'value1', 'key2' => 'value2' }

const map2 = new Map([1, 2]);	// TypeError: Iterator value 1 is not an entry object
```



Map 생성자 함수에 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어씌워진다.



#### 37.2.2 요소 개수 확인

Map 객체의 요소 개수를 확인할 때는 Map.prototype.size 프로퍼티를 사용한다.

```js
const { size } = new Map([['key1', 'value1'], ['key2', 'value2']]);
console.log(size);	// 2
```



size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티다. 따라서 size 프로퍼티에 숫자를 할당하여 Map 객체의 요소 개수를 변경할 수 없다.

```js
const map = new Map([['key1', 'value1'], ['key2', 'value2']]);

console.log(Object.getOwnPropertyDescriptor(Map.prototype, 'size'));
/*
{
  get: [Function: get size],
  set: undefined,
  enumerable: false,
  configurable: true
}
*/

map.size = 10;
console.log(map.size);	// 2
```



#### 37.2.3 요소 추가

Map 객체에 요소를 추가할 때는 Map.prototype.set 메서드를 사용한다.

```js
const map = new Map();
console.log(map);	// Map(0) {}

map.set('key1', 'value1');
console.log(map);	// Map(1) {'key1' => 'value1'}
```



set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다. 따라서 set 메서드를 연속으로 호출할 수 있다.

```js
const map = new Map();

map.set('key1', 'value1').set('key2', 'value2');

console.log(map);	// Map(2) { 'key1' => 'value1', 'key2' => 'value2' }
```

Set과 똑같이 Map도 NaN을 갖다고 평가한다.



일반 객체와 달리 Map은 모든 값을 키로 사용할 수 있다.

```js
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.set(lee, 'developer').set(kim, 'designer');

console.log(map);
/*
Map(2) {
  { name: 'Lee' } => 'developer',
  { name: 'Kim' } => 'designer'
}
*/
```



#### 37.2.4 요소 취득

특정 요소를 취득하려면 Map.prototype.get 메서드를 사용한다.

```js
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.set(lee, 'developer').set(kim, 'designer');

console.log(map.get(lee));		// developer
console.log(map.get('key'));	// undefined
```



#### 37.2.5 요소 존재 여부 확인

특정 요소가 존재하는지 확인하려면 Map.prototype.has 메서드를 사용한다.

```js
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

console.log(map.has(lee));		// true
console.log(map.has('key'));	// false
```



#### 37.2.6 요소 삭제

요소를 삭제하려면 Map.prototype.delete 메서드를 사용한다.

```js
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.delete(kim);
console.log(map);	Map(1) { {name: 'Lee'} => 'developer' }

// 존재하지 않는 키로 요소를 삭제하려 하면 에러 없이 무시된다
```

delete 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환하기 때문에 연속으로 사용할 수 없다.



#### 37.2.7 요소 일괄 삭제

요소를 일괄 삭제하려면 Map.prototype.clear 메서드를 사용한다.

```js
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.clear();
console.log(map);	// Map(0) {}
```



#### 37.2.8 요소 순회

요소를 순회하기 위해서는 Map.prototype.forEach 메서드를 사용한다. Array.prototype.forEach 메서드와 유사하게 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this 로 사용될 객체를 인수로 전달한다.

- 첫 번째 인수: 현재 순회 중인 요소값
- 두 번째 인수: 현재 순회 중인 요소키
- 세 번째 인수: 현재 순회 중인 Map 객체 자체

```js
const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.set(lee, 'developer').set(kim, 'designer');

map.forEach((v, k, map) => console.log(v, k, map));
/*
developer { name: 'Lee' } Map(2) {
  { name: 'Lee' } => 'developer',
  { name: 'Kim' } => 'designer'
}
designer { name: 'Kim' } Map(2) {
  { name: 'Lee' } => 'developer',
  { name: 'Kim' } => 'designer'
}
*/
```



Map 객체는 이터러블이다. 따라서 for ... of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.

```js
const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

const map = new Map([[lee, 'developer'], [kim, 'designer']]);

console.log(Symbol.iterator in map);	// true

for(const entry of map){
    console.log(entry);
}
/*
[ { name: 'Lee' }, 'developer' ]
[ { name: 'Kim' }, 'designer' ]
*/

console.log([...map]);	// [ [ { name: 'Lee' }, 'developer' ], [ { name: 'Kim' }, 'designer' ] ]

const [a, b] = map;
console.log(a, b);		// [ { name: 'Lee' }, 'developer' ] [ { name: 'Kim' }, 'designer' ]
```



Map 객체는 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.

| Map 메서드            | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| Map.prototype.keys    | Map 객체에서 요소키를 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |
| Map.prototype.values  | Map 객체에서 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |

```js
const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

const map = new Map([[lee, 'developer'], [kim, 'designer']]);

for(const key of map.keys()){
    console.log(key);
}
/*
{ name: 'Lee' }
{ name: 'Kim' }
*/

for(const value of map.values()){
    console.log(value);
}
/*
developer
designer
*/

for(const entry of map.entries()){
    console.log(entry);
}
/*
[ { name: 'Lee' }, 'developer' ]
[ { name: 'Kim' }, 'designer' ]
*/
```



## 38장 브라우저의 렌더링 과정

대부분의 프로그래밍 언어는 OS나 VM 위에서 실행되지만 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 따라서 브라우저 환경을 고려할 때 더 효율적인 클라이언트 사이드 자바스크립트 프로그래밍이 가능하다.

브라우저가 HTML, CSS, 자바스크립트로 작성된 텍스트 문서를 어떻게 파싱하여 브라우저에 렌더링하는지 알아보자.

- 파싱(parsing): 프로그래밍 언어의 문법에 맞게 작성된 텍스트를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하여, 토큰의 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성하는 일련의 과정을 말한다.
- 렌더링(rendering): HTML, CSS, 자바스크립트로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다.



브라우저는 다음과 같은 과정을 거쳐 렌더링을 수행한다.

1. HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.
2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더링 트리를 생성한다.
3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다.
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.



### 38.1 요청과 응답

브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 서버로부터 응답받아 브라우저에 시각적으로 렌더링하는 것이다. 서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다. 주소창에 URL을 입력하면 URL의 호스트 이름이 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에서 요청을 전송한다.



### 38.2 HTTP 1.1과 HTTP 2.0

HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜이다. 1991년 최초로 문서화되었고, 1996년 HTTP/1.0, 1999년 HTTP/1.1, 2015년 HTTP/2가 발표되었다.

HTTP/1.1 은 기본적으로 커넥션당 하나의 요청과 응답만 처리한다. HTML 문서 내에 포함된 여러 개의 리소스 요청(link, img, script 태그 등)에 의한 리소스 요청이 개별적으로 전송되고 응답도 개별적으로 전송된다. 그러면 요청이 많을 수록 응답 시간도 증가하는 단점이 있다.

HTTP/2는 커넥션당 여러 개의 요청과 응답이 가능하다. 따라서 HTTP/1.1에 비해 페이지 로드 속도가 약 50%정도 빠르다고 알려져있다.



### 38.3 HTML 파싱과 DOM 생성
