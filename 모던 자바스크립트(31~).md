# 모던 자바스크립트 Deep Dive(31 ~ )

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 31장 RegExp(정규 표현식)

### 31.1 정규 표현식이란?

정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어다. 자바스크립트의 고유 문법이 아니고, 대부분의 프로그래밍 언어와 코드 에디터에 내장되어 있다.

정규 표현식은 문자열을 대상으로 **패턴 매칭 기능**을 제공한다. 패턴 매칭 기능은 특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능을 말한다.

예를 들어, 전화번호를 입력 받을 때 숫자 3개 - 숫자 4개 - 숫자 4개라는 일정한 패턴이 있다.

```js
const tel = '010-1234-567팔'

const regExp = /^\d{3}-\d{4}-\d{4}$/;

regExp.test(tel);
```

만약 반복문과 조건문을 통해 체크하려면 한 문자씩 연속해서 체크해야 한다.



### 31.2 정규 표현식의 생성

정규 표현식 객체를 생성하기 위해서는 정규 표현식 리터럴과 RegExp 생성자 함수를 사용할 수 있다. 일반적인 방법은 리터럴을 사용하는 것이다. 정규 표현식 리터럴은 다음과 같이 표현한다. `/regExp패턴/i(플래그)`

```js
const target = 'Is this all there is?'

// 패턴: is
// 플래그: i => 대소문자를 구분하지 않고 검색한다.
const regexp = /is/i;

regexp.test(target);
```



RegExp 생성자 함수를 사용하여 RegExp 객체를 생성할 수도 있다.

```js
/**
 * pattern: 정규 표현식의 패턴
 * flags: 정규 표현식의 플래그(g, i, m, u, y)
 */

new RegExp(pattern[, flags])
```

```js
const target = 'Is this all there is?';

const egexp = new RegExp(/is/i);	// ES6
// const regexp = new RegExp(/is/i, 'i');
// const regexp = new RegExp('is', 'i');

regexp.test(target);	// true
```



RegExp 생성자 함수를 사용하면 변수를 사용해 동적으로 RegExp 객체를 생성할 수 있다.

```js
const count = (str, char) => (str.match(new RegExp(char, 'gi')) ?? []).length;

count('Is this all there is?', 'is');	// 3
count('Is this all there is?', 'xx');	// 0
```



### 31.3 RegExp 메서드

정규표현식을 사용하는 메서드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다.



#### 31.3.1 RegExp.prototype.exec

exec 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환한다. 매칭 결과가 없는 경우 null을 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.exec(target);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exex 메서드는 모든 패턴을 검색ㅎ는 g 플래그를 지정해도 첫 번째 매칭 결과만 반환한다.



#### 31.3.2 RegExp.prototype.test

test 메서드는 인수로 전달받은 문자열에 대해 정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.test(target);	// true
```



#### 31.3.3 String.prototype.match

String 표준 빌트인 객체로 대상 문자열과 인수로 전달받은 정규 표현식과의 매칭 결과를 배열로 반환한다.

```js
const target = 'Is this all there is?';
const regExp = /is/;

target.match(regExp);	// exec와 target, match의 위치만 바꼈다
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
```

exec 메서드는 g 플래그를 지정해도 첫 번쨰 매칭 결과만 반환하지만 match 메서드는 모든 결과를 배열로 반환한다.



### 31.4 플래그

패턴과 함꼐 정규 표현식을 구성한다. 플래그는 총 6개가 있다. 그중 중요한 3개를 알아보자.

| 플래그 | 의미        | 설명                                                         |
| ------ | ----------- | ------------------------------------------------------------ |
| i      | Ignore case | 대소문자를 구별하지 않고 패턴을 검색한다.                    |
| g      | Global      | 대상 문자열 내에서 패턴과 일치하는 모든 문자열을 전역 검색한다. |
| m      | Multi line  | 문자열의 행이 바뀌더라도 패턴 검색을 계속한다.               |

플래그는 옵션이니 선택적으로 사용할 수 있다. 순서와 상관없이 하나 이상의 플래그를 동시에 설정할 수도 있다. 어떠한 플래그도 사용하지 않으면 대소문자를 구별해서 패턴을 검색한다. 그리고 대상이 1개 이상 존재해도 첫 번째 대상만 검색하고 종료한다.

```js
const target = 'Is this all there is?';

target.match(/is/);
// [ 'is', index: 5, input: 'Is this all there is?', groups: undefined ]
target.match(/is/i);
// [ 'Is', index: 0, input: 'Is this all there is?', groups: undefined ]
target.match(/is/g);
// [ 'is', 'is' ]
target.match(/is/ig);
// [ 'Is', 'is', 'is' ]
```



### 31.5 패턴

정규 표현식의 패턴은 문자열의 일정한 규칙을 표현하기 위해 사용하며, 플래그는 검색 방식을 설정하기 위해 사용한다.

패턴은 /로 열고 닫으며 문자열의 따옴표는 생략한다. 따옴표를 포함하면 따옴표까지 패턴에 포함되어 검색된다. 패턴을 표현하는 몇 가지 방법에 대해 알아보자.



#### 31.5.1 문자열 검색

패턴에 문자 또는 문자열을 지정하면 검색 대상 문자열에서 패턴을 지정한 문자 또는 문자열을 검색한다.

```js
const target = 'Is this all there is?';

// is 문자열과 매치하는 패턴. 플래그가 생략되었으니 대소문자를 구별한다.
const regExp = /is/;

regExp.test(target);	// true
target.match(regExp);
```



#### 31.5.2 임의의 문자열 검색

.은 임의의 문자 한 개를 의미한다. 내용은 무엇이든 상관없다. 다음 예제는 .을 3개 연속하여 패턴을 생성하였으니 임의의 3자리 문자열과 매치한다.

```js
const target = 'Is this all there is?';

const regExp = /.../g;

console.log(target.match(regExp));
/*
[
  'Is ', 'thi',
  's a', 'll ',
  'the', 're ',
  'is?'
]
*/
```



#### 31.5.3 반복 검색

{m, n}은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미한다. 콤마 뒤에 공백이 있으면 정상 작동안하니 주의하자.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{1,2}/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AA', 'A' ]
```



{n}은 앞선 패턴이 n번 반복되는 문자열을 의미한다. 즉, {n,n}과 같다.

```js
const target = 'A AA B BB Aa Bb AAA';

// A가 최소 1번 최대 2번 반복되는 문자열을 전역 검색한다.
const regExp = /A{2}/g;

console.log(target.match(regExp));	// [ 'AA', 'AA' ]
```



{n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미한다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A{2,}/g;

console.log(target.match(regExp));	// [ 'AA', 'AAA' ]
```

 

+는 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미한다. {1,}과 같은 의미이다.

```js
const target = 'A AA B BB Aa Bb AAA';

const regExp = /A+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'A', 'AAA' ]
```



?는 앞선 패턴이 최대 한 번 이상 반복되는 문자열을 의미한다. {0, 1}과 같다. /colou?r/는 colo 다음 u가 최대 한번 반복되고 r이 이어지는 문자열(color, colour)과 매치한다.

```js
const target = 'color colour';

const regExp = /colou?r/g;

target.match(regExp);
```



#### 31.5.4 OR 검색

|은 or의 의미를 갖는다. 다음 예제의 /A|B/는 A 또는 B를 의미한다.

```js
const target = 'A AA B B Aa Bb';

const regExp = /A|B/g;

console.log(target.match(regExp));
/*
[
  'A', 'A', 'A',
  'B', 'B', 'A',
  'B'
]
*/
```



분해되지 않은 단어 레벨로 검색하기 위해서는 +를 함께 사용한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /A+|B+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



위 예제는 패턴을 or로 한 번 이상 반복하는 것인데 이를 간단히 []로 표현할 수 있다. [] 내의 문자는 or로 동작한다.

```js
const target = 'A AA B BB Aa Bb';

const regExp = /[AB]+/g;

target.match(regExp);	// [ 'A', 'AA', 'B', 'BB', 'A', 'B' ]
```



범위를 지정하려면 []내에 -를 사용한다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Z]+/g;

console.log(target.match(regExp));	// [ 'A', 'AA', 'BB', 'ZZ', 'A', 'B' ]
```



대소문자를 구별하지 않고 검색하는 방법은 다음과 같다.

```js
const target = 'A AA BB ZZ Aa Bb';

const regExp = /[A-Za-z]+/g;

console.log(target.match(regExp));
```



숫자를 검색하는 방법은 다음과 같다.

```js
const target = 'AA BB 12,345';

const regExp = /[0-9]+/g;

target.match(regExp);	// ['12', '345']

// 쉼표를 포함하고 싶다면 패턴에 쉼표를 포함시키면 된다.
// const regExp2 = [0-9,]+/g;
```



위 예제를 간단히 표현하면 다음과 같다. \d는 숫자를 의미한다. \D는 \d와 반대로 동작한다.

```js
const target = 'AA BB 12,345';

let regExp = /[\d,]+/g;

target.match(RegExp);	// ['12,345']

regExp = /[\D,]+/g;

target.match(regExp);	// ['AA BB ', ',']
```



\w는 알파벳, 숫자, 언더스코어를 의미한다. [A-Za-z0-9_]와 같다. \W는 \w와 반대로 동작한다.

```js
const target = 'Aa Bb 12,345 _$%&';

let regExp = /[\w,]+/g;

target.match(regExp);	// [ 'Aa', 'Bb', '12,345', '_' ]

regExp = /[\W,]+/g;

target.match(regExp);	// [ ' ', ' ', ',', ' ', '$%&' ]
```



#### 31.5.5 NOT 검색

[...]내의 ^은 not의 의미를 갖는다. 예를 들어, ^0-9는 숫자를 제외한 문자(\D)를 의미한다.

```js
const target = 'AA BB 12 Aa Bb';

const regExp = /[^0-9]+/g;

target.match(regExp);	// [ 'AA BB ', ' Aa Bb' ]
```



#### 31.5.6 시작 위치로 검색

[...]밖의 ^은 문자열의 시작을 의미한다. [...]안이면 NOT을 의미하니 주의하자.

```js
const target = 'https://poiemaweb.com';

// https로 시작하는지 검사한다.
const regExp = /^https/;

regExp.test(target);	// true
```



#### 31.5.7 마지막 위치로 검색

$는 문자열의 마지막을 의미한다.

```js
const target = 'https:/poiemaweb.com';

const regExp = /com$/;

regExp.test(target);	// true
```



### 31.6 자주 사용하는 정규표현식

#### 31.6.1 특정 단어로 시작하는지 검사

```js
const url = 'https://example.com';

// [] 바깥의 ^는 문자열의 시작을 의미하고 ?는 앞선 패턴이 최대 한번(있어도 되고 없어도 된다) 반복되는지를 의미한다.
// http:// 또는 https://로 시작하는지 검사한다.
/^https?:\/\//.test(url);	// true
/^(http|https):\/\//.test(url);	// true
```



#### 31.6.2 특정 단어로 끝나는지 검사

```js
const fileName = 'index.html';

/html$/.test(fileName);	// true
```



#### 31.6.3 숫자로만 이루어진 문자열인지 검사

```js
const target = '12345';

// ^: 숫자로 시작, +: 한번 이상 반복, $: 숫자로 끝남
/^\d+$/.test(target);	// true
```



#### 31.6.4 하나 이상의 공백으로 시작하는지 검사

\s는 여러가지 공백 문자를 의미한다. [\t\r\n\v\f]와 같은 의미다.

```js
const target = ' Hi!';

/^[\s]+/.test(target);	// true
```



#### 31.6.5 아이디로 사용 가능한지 검사

검색 대상 문자열이 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4~10자리인지 검사해보자

```js
const id = 'abc123';

/^[A-Za-z0-9]{4,10}$/.test(id);	// true
```



#### 31.6.6 메일 주소 형식에 맞는지 검사

*는 0번 이상의 반복을 의미한다.

```js
const email = 'sanghyun2@gmail.com';

console.log(/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/.test(email));	// true
```



인터넷 메시지 형식 규약인 RFC 5322에 맞는 정교한 패턴 매칭이 필요하다면 다음과 같은 복잡한 패턴이 필요하다.

```js
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```



#### 31.6.7 핸드폰 번호 형식에 맞는지 검사

```js
const cellphone = '010-1234-5678';

/^\d{3}-\d{4}-\d{4}$/.test(cellphone);	// true
```



#### 31.6.8 특수 문자 포함 여부 검사

특수문자는 A-Za-z0-9 이외의 문자다.

```js
const target = 'abc#123';

(/[^A-Za-z0-9]/gi).test(target);	// true
```



다음 방식으로 대체할 수도 있다. 이 방식은 특수 문자를 선택적으로 검사할 수 있다는 장점이 있다

```js
(/[\{\}\[\]\/?.,;:|\)*~`!^\-_+<>@\#$%&\\\=\(\'\"]/gi).test(target);
```



특수문자를 제거할 때는 String.prototype.replace 메서드를 사용한다.

```js
target.replace(/[^A-Za-z0-9]/gi, '');	// abc123
```

