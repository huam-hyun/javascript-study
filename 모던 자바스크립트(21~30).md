# 모던 자바스크립트 Deep Dive(21 ~ )

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 21장 빌트인 객체

### 21.1 자바스크립트 객체의 분류

- 표준 빌트인 객체

  표준 빌트인 객체는 ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공한다. 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언 없이 전역 변수처럼 언제나 참조할 수 있다.

- 호스트 객체

  호스트 객체는 ECMAScript 사양에 정의디어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체를 말한다.

- 사용자 정의 객체

  사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.



### 21.2 표준 빌트인 객체

자바스크립트는 40여 개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 ㅔ서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.

```js
const strObj = new String('Lee');

// String 생성자 함수를 통해 생성한 strObj의 프로토타입은 String.prototype이다.
console.log(Object.getPrototypeOf(strObj) === String.prototype);	// true
```



### 21.3 원시값과 래퍼 객체

원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는 무엇일까?

```js
const str = 'hello';

// 원시값이 객체처럼 작동한다
console.log(str.length);
console.log(str.toUpperCase());
```

위 예제를 보면 원시값이 객체처럼 작동하는 것을 볼 수 있다. 이것이 가능한 이유는 자바스크트 엔진이 원시값에 대해 객체처럼 접근하면 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 이처럼 **문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.**

```js
const str = 'hi';

// String 인스턴스로 변환된다.
console.log(str.length);
console.log(str.toUpperCase());

// 끝나면 다시 원시값으로 되돌린다.
console.log(typeof str);	// string
```

래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. 다른 값들도 마찬가지로 작동한다.

```js
const num = 1.5;

console.log(num.toFixed());	// 2

console.log(typeof num, num);	// number 1.5
```

문자열, 숫자, 불리언, 심벌 이외의 원시값인 null과 undefined는 래퍼 객체를 생성하지 않는다.



### 21.4 전역 객체

전역 객체는 콛가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체다. 브라우저에서는 window가 전역 객체를 가리키고, Node.js 환경에서는 global이 전역 객체를 가리킨다.

전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 전역 객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체다.

전역 객체의 특징은 다음과 같다.

- 전역 객체는 개발자가 의도적으로 생성할 수 없다.

- 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다.

  ```js
  window.parseInt('F', 16);	// 15
  
  // window.parseInt는 parseInt로 호출할 수 있다.
  parseInt('F', 16);
  
  window.parseInt === parseInt;
  ```

- 전역 객체는 Object, String, Number, Boolean, Function 등과 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.

- 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖는다.

- var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역, 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.

  ```js
  var foo = 1;
  console.log(window.foo);
  
  bar = 2;
  console.log(window.bar);
  
  function baz() {return 3;}
  console.log(window.baz());
  ```

- let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let이나 const 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록내에 존재하게 된다.

  ```js
  let foo = 123;
  console.log(window.foo);	//	 undefined
  ```

- 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리해도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미다.



#### 21.4.1 빌트인 전역 프로퍼티

빌트인 전역 프로퍼티는 전역 객체의 프로퍼티를 의미한다. 주로 애플리케이션 전역에서 사용하는 값을 제공한다.

##### Infinity

무한대를 나타내는 숫자값 Infinity를 갖는다.

```js
console.log(window.Infinity === Infinity);
```



##### NaN

NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.



##### undefined

undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.



#### 21.4.2 빌트인 전역 함수

##### eval

eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 받는다. 전달받은 문자열 코드가 표현식이라면 eval 함수는 문자열 코드를 런타임에 평가하여 값을 생성하고, 전달받은 인수가 표현식이 아닌 문이라면 eval 함수는 문자열 코드를 런타임에 실행한다. 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한다.

```js
/**
 * 주어진 문자열 코드를 런타임에 평가 또는 실행한다.
 * @param {string} code - 코드를 나타내는 문자열
 * @returns {*} 문자열 코드를 평가/실행한 결과값
 */
eval(code)
```

**eval 함수는 기존의 스코프를 런타임에 동적으로 수정한다.**

```js
const x = 1;

function foo() {
    eval('var x = 2');
    console.log(x);	// 2
}

foo();
console.log(x);	// 1
```

단, strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.

```js
const x = 1;

function foo() {
	'use strict';
    
    eval('var x = 2; console.log(x);');	// 2
    console.log(x);	// 1
}

foo()
console.log(x);	// 1
```

또한 인수로 전달받은 문자열 코드가 let, const 키워드를 사용한 변수 선언문이라면 암묵적으로 strict mode가 적용된다.

eval함수를 통해 실행되는 코드는 자바스크립트 엔진에 의해 최저고하가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느리다. 따라서 **eval 함수의 사용은 금지해야 한다.**



##### isFinite

전달받은 인수가 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 변환한다.

```js
isFinite(0);	// true
isFinite(2e64);	// true
isFinite('10');	// true
isFinite(null);	// true

// 인수가 무한수 또는 NaN으로 평가되는 값이라면 false
isFinite(Infinity);	// false
isFinite(-Infinity);// false
isFinite('Hello');	// false
isFinite(NaN);		// false
```



##### isNaN

전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.

```js
isNaN(NaN);	// true
isNaN(10);	// false

isNaN('blabla');	// true
isNaN('10');		// false
isNaN('');			// false
isNaN(' ');			// false

isNaN(undefined);	// true
isNaN({});			// true

isNaN(new Date());	// false
isNaN(new Date().toString());	// true
```



##### parseFloat

전달받은 문자열 인수를 부동 소수점 숫자로 해석하여 반환한다.

```js
parseFloat('3.14');	// 3.14
parseFloat('10.00');// 10

// 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
parseFloat('34 56 66');	// 34
parseFloat('40 years');	// 40

// 첫 번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.
parseFloat('He was 40');	// NaN

// 앞뒤 공백은 무시된다.
parseFloat(' 60 ');	// 60
```

##### parseInt

전달받은 문자열 인수를 정수로 해석하여 반한한다.

```js
parseInt('10');	// 10
parseInt('10.123');	// 10

// 두 번째 인수로 진법을 나타내는 기수를 전달할 수 있다.
// 10을 10진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10');	// 10
// 10을 2진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 2);	// 2
// 10을 8진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 8);	// 8
// 10을 16진수로 해석하고 그 결과를 10진수 정수로 반환한다.
parseInt('10', 16);	// 16

// 문자열의 첫 번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다.
parseInt('A0');	// NaN
parseInt('20', 2);	// NaN

// 문자열의 두 번째 이후부터 해당 지수의 숫자로 변환될 수 없다면 이후 문자들은 무시된다.
parseInt('1A0');	// 1
parseInt('102', 2);	// 2

// parseFloat과 같이 공백으로 나누어져 있으면 첫 번째 문재열만 변환한다.
// parseFloat과 같이 첫 번째 문자열을 변환활 수 없다면 NaN을 반환한다.
// parseFloat과 같이 앞뒤 공백은 무시된다.
```



##### encodeURI / decodeURI

encodeURI 함수는 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.

```js
// 완전한 URI
const uri = 'http://example.com?name=아무개&job=programmer&teacher';

const enc = encodeURI(uri);
console.log(enc);
// http://example.com?name=인코딩된부분&job=programmer&teacher
```

decodeURI 함수는 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩한다

```js
// 위 예제의 enc 사용
const dec = decodeURI(enc);
console.log(dec);
// http://example.com?name=아무개&job=programmer&teacher
```



##### encodeURIComponent / decodeURIComponent

encodeURIComponent 함수는 URI 구성 요소를 인수로 전달받아 인코딩한다. 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다.

encodeURIComponent 함수는 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주한다. 따라서 =, ?, &까지 인코딩한다.

```js
const uriComp = 'name=아무개&job=programmer&teacher'

let enc = encodeURIComponent(uriComp);
console.log(enc);
// name인코오오오오ㅗ디ㅣ이이이잉job인코딩programmer인코딩teacher

let dec = decodeURIComponent(enc);
console.log(dec);
// 아무개&job=programmer&teacher
```



#### 21.4.3 암묵적 전역

자바스크립트 엔진은 스코프에서 찾을 수 없는 변수를 전역 객체에 프로퍼티로 동적 생성하여 추가하기 때문에 전역변수처럼 접근할 수 있다. 이것을 **암묵적 전역**이라 한다.

```js
var x = 10;

function foo () {
    y = 20;	// window.y = 20
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
console.log(x + y);	// 30
```

또한 변수가 아니라 프로퍼티이기 때문에 y는 delete 연산자로 삭제할 수 있다.

------

## 22장 this

### 22.1 this 키워드

객체는 상태를 나타내는 프로퍼티와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조다. 동작을 나타내는 메서드는 자신이 속한 객체의 상태(프로퍼티)를 참조하고 변경할 수 있어야 한다. 이때 메서드가 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.

```js
const circle = {
    radius: 5,
    getDiameter(){
        // 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면
        // 자신이 속한 객체인 circle을 참조할 수 있어야 한다.
        return 2 * circle.radius;
    }
};

console.log(circle.getDiameter());	// 10
```

위 예제에서 getDiameter 메서드 내에서 자신이 속한 객체를 가리키는 식별자 circle을 사용하고 있다. 이 참조 표현식이 평가되는 시점은 getDiameter 메서드가 호출되어 몸체가 실행되는 시점이다.

위 예제의 객체 리터럴은 circle 변수에 할당되기 직전에 평가된다. 따라서 getDiameter가 호출되는 시점에는 이미 객체 리터럴이 평가된 후이니 getDiameter는 circle을 참조할 수 있다.

하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다. 생성자 함수 방식을 생각해보자

```js
function Cirle(radius){
	// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    ????.radius = radius;
}

Circle.prototype.getDiameter = function(){
    // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
    return 2 * ????.radius;
};

// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.
const circle = new Circle(5);
```

생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 자신을 가리킬 특별한 식별자가 필요한데, 이를 위해 자바스크립트는 this라는 특수한 식별자를 제공한다.

**this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.**

this는 자바스크립트에 의해 암묵적으로 생성된다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, **this가 가리키는 값은 함수 호출 방식에 의해 동적으로 결정된다.**

```js
const circle = {
	radius: 5,
	getDiameter(){
        return 2 * this.radius;
    }
};

console.log(circle.getDiameter());	// 10

function Circle(radius){
    this.radius = radius;
}

Circle.prototype.getDiameter = function(){
    return 2 * this.radius;
};

const circle1 = new Circle(5);
console.log(circle1.getDiameter());	// 10
```



### 22.2 함수 호출 방식과 this 바인딩

this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. 함수도 다양한 방식으로 호출할 수 있으니 주의하자

1. 일반 함수 호출
2. 메서드 호출
3. 생성자 함수 호출
4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

```js
// this 바인딩의 결정은 함수 호출 방식에 의해 결정된다.
const foo = function(){
    console.dir(this);
};

// 1. 일반 함수 호출
foo();	// window

// 2. 메서드 호출
const obj = { foo };
obj.foo();	// obj

// 3. 생성자 함수 호출
new foo();	// foo {}

// 4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출
const bar = { name: 'bar' };

foo.call(bar);	// bar
foo.apply(bar);	// bar
foo.bind(bar);	// bar
```



#### 22.2.1 일반 함수 호출

**기본적으로 this에는 전역 객체가 바인딩된다.**

```js
function foo(){
	console.log("foo's this: ", this);	// window
    function bar(){
        console.log("bar's this: ", this);	//window
    }
    bar();
}
foo();
```

전역 함수는 물론이고 중첩 함수를 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다. strict mode 에서는 this에 undefined가 바인딩된다.

메서드 내에서 중첩된 함수도 일반 함수로 호출되면 this로 전역 객체가 바인딩된다. 메서드 내부의 중첩 함수나 콜백 함수의 this 바인딩을 일치시키는 방법은 다음과 같다.

```js
var value = 1;

const obj = {
    value: 100,
    foo() {
        // this 바인딩을 that에 할당한다.
        const that = this;
        
        setTimeout(function (){
            console.log(that.value);
        }, 100);
        
        /* 2번째 방법
        화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다
        setTimeout(() => console.log(this.value), 100);	// 100
        */
    }
};

obj.foo();
```



#### 22.2.2 메서드 호출

메서드 내부의 this에는 메서드를 호출한 객체가 바인딩된다. 주의할 것은 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩된다는 것이다.

```js
const person = {
    name: 'Lee',
    getName(){
        return this.name;
    }
};

console.log(person.getName());	// Lee
```

위 예제의 getName 프로퍼티가 가리키는 함수 객체는 person 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체이다.(getName식별자가 가리키는 것은 객체의 주소니까) 따라서 getName 메서드는 다른 객체의 프로퍼티에 할당할 수도 있고 일반 변수에 할당하여 일반 함수로 호출될 수도 있다.

```js
const anotherPerson = {
	name: 'Kim'
};

another.Person.getName = person.getName;

console.log(anotherPerson.getName());	// Kim

const getName = person.getName;

console.log(getName());	// ''
// 일반 함수로 호출됐으니 window.name과 같다.
// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 ''이다.
// Node.js 환경에서 this.name은 undefined이다.
```



#### 22.2.3 생성자 함수 호출

생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스가 바인딩된다.

```js
function Circle(radius){
    this.radius = radius;
    this.getDiameter = function(){
        return 2 * this.radius;
    };
}

const circle1 = new Circle(5);
const circle2 = enw Circle(10);

console.log(circle1.getDiameter());	// 10
console.log(circle2.getDiameter());	// 20

const circle3 = Circle(15);

console.log(circle3);	// undefined

console.log(radius);	// 15
```



#### 22.2.4 Function.prototype.apply/call/bind 메서드에 의한 간접 호출

apply, call, bind 메서드는 Function.prototype의 메서드다. 모든 함수가 상속받아 사용 가능하다.

apply와 call 메서드의 사용법은 다음과 같다.

```js
/**
 * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체
 * @returns 호출된 함수의 반환값
 */
Function.prototype.apply(thisArg[, argsArray])

/**
 * 주어진 this 바인딩과 ,로 구분된 인수 리스트를 사용하여 함수를 호출한다.
 * @param thisArg - this로 사용할 객체
 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트
 * @returns 호출된 함수의 반환값
 */
Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])

function getThisBinding(){
    return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding());	// window

console.log(getThisBinding.apply(thisArg));	// {a: 1}
console.log(getThisBinding.call(thisArg));	// {a: 1}
```

apply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 작동한다. 위 예제에는 인수를 전달하지 않았으니 새로운 예제를 보자

```js
function getThisBinding(){
	console.log(arguments);
    return this;
}

const thisArg = { a: 1 };

console.log(getThisBinding.apply(thisArg, [1, 2, 3]));
// [Arguments] { '0': 1, '1': 2, '2': 3 }
// { a: 1 }

console.log(getThisBinding.call(thisArg, 1, 2, 3));
// [Arguments] { '0': 1, '1': 2, '2': 3 }
// { a: 1 }
```

apply와 call 메서드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메서드를 사용하는 경우다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice 같은 배열의 메서드를 사용할 수 없으나 apply와 call 메서드를 이용하면 가능하다.

```js
function convertArgsToArray(){
	console.log(arguments);
	
    // Array.prototype.slice를 인수 없이 호출하면 배열의 복사본을 생성한다.
    const arr = Array.prototype.slice.call(arguments);
    
    console.log(arr);
    return arr;
}

convertArgsToArray(1, 2, 3);	// [1, 2, 3]
```

Function.prototype.bind 메서드는 apply와 call 메서드와 달리 함수를 호출하지 않는다. 다만 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성해 반환한다.

```js
function getThisBinding(){
    return this;
}

const thisArg = {a: 1};

console.log(getThisBinding.bind(thisArg));	// getThisBinding
// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.
console.log(getThisBinding.bind(thisArg)());// {a: 1}
```

bind 메서드는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 사용된다.

```js
const person = {
	name: 'Lee',
	foo(callback){
        setTimeout(callback, 100);
    }
};

person.foo(function(){
    console.log(`Hi! my name is ${this.name}.`);	// Hi! my name is .
})
// foo가 호출된 시점의 this는 person이지만 콜백 함수는 일반 함수이므로 콜백 함수가 호출될 때 this는 전역 객체이다.
```

여기서 person.foo의 콜백 함수는 person.foo를 돕는 역할을 하기 때문에 this가 다르면 문맥상 문제가 발생한다. bind를 통해 this를 통일시켜 주자

```js
const person = {
	name: 'Lee',
	foo(callback){
        setTimeout(callback.bind(this), 100);
    }
};

person.foo(function(){
    console.log(`Hi! my name is ${this.name}.`);	// Hi! my name is Lee.
})
// foo가 호출된 시점의 this는 person이지만 콜백 함수는 일반 함수이므로 콜백 함수가 호출될 때 this는 전역 객체이다.
```

지금까지 알아본 this 바인딩을 정리하면 다음과 같다.

| 함수 호출 방식                                             | this 바인딩                                                  |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 일반 함수 호출                                             | 전역 객체                                                    |
| 메서드 호출                                                | 메서드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에)생성할 인스턴스                        |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |

------

## 23장 실행 컨텍스트

실행 컨텍스트는 자바스크립트의 동작 원리를 담고 있는 핵심 개념이다.

### 23.1 소스코드의 타입

ECMAScript 사양은 소스코드를 4가지 타입으로 구분한다.

| 소스코드의 타입 | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 전역 코드       | 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| 함수 코드       | 함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다. |
| eval 코드       | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드를 말한다. |
| 모듈 코드       | 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다. |

이렇게 4가지로 구분하는 이유는 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다.



#### 1. 전역 코드

전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 그리고 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 객체와 연결되어야 한다. 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.



#### 2. 함수 코드

함수 코드는 지역 스코프를 생성하고 지역 변수, 매개 변수, arguments 객체를 관리해야 한다. 그리고 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 이를 위해 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.



#### 3. eval 코드

eval 코드는 strict mode에서 자신만의 독자적인 스코프를 생성한다. 이를 위해 eval 코드가 평가되면 eval 실행 컨텍스크가 생성된다.



#### 4. 모듈 코드

모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다. 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.



### 23.2 소스코드의 평가와 실행

모든 소스코드는 실행에 앞서 평가 과정을 거치며 코드를 실행하기 위한 준비를 한다. 이는 소스코드를 '소스코드의 평가' 와 '소스코드의 실행'과정으로 나누어 처리한다는 것이다.

소스코드의 평가 과정에서 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다.

소스코드 평가 과정이 끝나면 비로소 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다.(=런타임) 이때 소스코드 실행에 필요한 정보를 실행 컨텍스트가 관리하는 스코프에서 검색해서 취득한다. 그리고 소스토드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.



### 23.3 실행 컨텍스트의 역할

다음 예제를 자바스크립트 엔진이 어떻게 평가하고 실행할지 알아보자

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

#### 1. 전역 코드의 평가

전역 코드를 실행하기에 앞서 먼저 전역 코드 평가 과정을 거친다. 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고, 그 결과 생성된 전역 변수와 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다. 이때 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.



#### 2. 전역 코드 실행

전역 코드 평가 과정이 끝나면 런타임이 된다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다.



#### 3. 함수 코드 평가

함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거친다. 이때 매개변수와 지역 변수 선언문이 먼저 실행되고, 그 결과 생성된 매개변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체가 생성되어 지역 스코프에 등록되고 this 바인딩도 결정된다



#### 4. 함수 코드 실행

함수 코드 평가 과정이 끝나고 런타임이 된다. 이때 매개변수와 지역 변수에 값이 할당되고 console.log 메서드가 호출된다.

console.log 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. console 식별자는 스코프체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다. 이는 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미한다.

다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다. 그후 console.log메서드에 인수로 전달된 표현식 a+x+y가 평가된다. a, x, y 식별자는 스코프 체인을 통해 검색한다. console.log 메서드의 실행이 종료되면 함수 코드 실행 과정이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다.



위처럼 코드가 실행되려면 다음과 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

1. 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록하고 상태 변화를 지속적으로 관리할 수 있어야 한다.
2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다.
3. 현재 실행 중인 코드의 실행 순서를 변경할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

이 모든 것을 관리하는 것이 실행 컨텍스트다. 실행 컨텍스트는 소스코드를 실행하는 데 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.

구체적으로 말하면 **실행 컨텍스트는 식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**

식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다.



### 23.4 실행 컨텍스트 스택

```js
const x = 1;

function foo(){
    const y = 2;
    
    function bar(){
        const z = 3;
        console.log(x + y + z);
    }
    bar();
}

foo();	// 6
```

위 예제는 소스코드의 타입으로 분류할 때 전역 코드와 함수 코드로 이루어져 있다. 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다.

이때 생성된 실행 컨텍스트는 스택 자료구조로 관리된다. 이를 **실행 컨텍스트 스택**이라고 한다.

위 예제를 실행하면 시간의 흐름에 따라 실행 컨텍스트 스택에는 다음과 같이 실행 컨텍스트가 추가되고 제거된다.

1. 전역 실행 컨텍스트 push
2. foo 함수 실행 컨텍스트 push
3. bar 함수 실행 컨텍스트 push
4. bar 함수 실행 컨텍스트 pop
5. foo 함수 실행 컨텍스트 pop
6. 전역 실행 컨텍스트 pop

**실행 컨텍스트 스택은 코드의 실행 순서를 관리한다. 그리고 실행 컨텍스트 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트다.** 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행중인 실행 컨텍스트**라 부른다.



### 23.5 렉시컬 환경

렉시컬 환경은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다. 실행 컨텍스트 스택이 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.

렉시컬 환경은 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 렉시컬 스코프의 실체다.

실행 컨텍스트는 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기에 이 둘은 하나의 동일한 렉시컬 환경을 참조한다. 이후 몇 가지 상황을 만나면 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성하고, 이때부터 둘의 내용이 달라지는 경우도 있다. 책에서는 이 둘을 구분하지 않고 렉시컬 환경으로 통일해서 간략하게 설명한다.

렉시컬 환경은 두 개의 컴포넌트로 구성된다.

1.  환경 레코드

   스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다. 환경 레코드는 소스코드의 타입에 따라 관리하는 내용에 차이가 있다.

2. 외부 렉시컬 환경에 대한 참조

   외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다. 이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 이것을 통해 단방향 링크드 리스트인 스코프 체인을 구현한다.



### 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

다음 예제를 통해 실행 과정을 알아보자

```js
var x = 1;
const y = 2;

function foo(a){
    var x = 3;
    const y = 4;
    
    function bar(b){
        const z = 5;
        console.log(a + b + x + y + z);
    }
    bar(10);
}

foo(20);
```



#### 23.6.1 전역 객체 생성

전역 객체는 전역 코드가 평가되기 이전에 생성된다. 전역 객체도 Object.prototype을 상속받기 때문에 프로토타입 체인의 일원이다.



#### 23.6.2 전역 코드 평가

소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가한다.

1. 전역 실행 컨텍스트 생성

   비어있는 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다. 이때 전역 실행 컨텍스트는 스택의 최상위에 위치하여 현재 실행 중인 실행 컨텍스트가 된다.

2. 전역 렉시컬 환경 생성

   전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩한다.

   1. 전역 환경 레코드 생성

      전역 렉시컬 환경을 구성하는 컴포넌트이다. 전역 변수를 관리하는 전역 스코프, 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체를 제공한다. let, const 키워드로 선언한 전역 변수를 구분하기 위해 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.

      1. 객체 환경 레코드 생성

         전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.

      2. 선언적 환경 레코드 생성

         let, const 키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다. 15.2.4절에서 let, const 키워드로 선언한 전역 변수는 개념적인 블록 내에 존재하게 된다고 했는데 그 블록이 선언적 환경 레코드다. 또한 const 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행한다. 따라서  런타임에 실행 흐름이 변수 선언문에 도달하기 전까지 **일시적 사각지대**에 빠지게된다.

   2. this 바인딩

      전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 일반적으로 전역 코드에서 this는 전역 객체를 가리키기 때문에 전역 객체가 바인딩된다. 전역 코드에서 this를 참조하면 [[GlobalThisValue]] 내부 슬롯에 바인딩되어 있는 객체가 반환된다.

   3. 외부 렉시컬 환경에 대한 참조 결정

      외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 **상위 스코프를 가리킨다.** 이를 통해 단방향 링크드 리스크인 스코프 체인을 구현한다. 현재 평가중인 코드는 전역 코드이니 참조에 null이 할당된다.



#### 23.6.3 전역 코드 실행

전역 코드가 순차적으로 실행되기 시작한다. 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인해야 한다. 어느 스코프의 식별자를 참조하면 되는지 결정하는 것을 **식별자 결정**이라 한다.

식별자 결정을 위해 식별자를 검색할 때는 실행중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 실행중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 상위 스코프(외부 렉시컬 환경에 대한 참조)로 이동하여 식별자를 검색한다. 전역에서도 검색할 수 없다면 참조 에러를 발생시킨다.



#### 23.6.4 foo 함수 코드 평가

foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다.

1. 함수 실행 컨텍스트 생성

   foo 함수 실행 컨텍스트를 생성한다. 이것은 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 푸시된다. 푸시되면 스택의 최상위인 실행 중인 실행 컨텍스트가 된다.

2. 함수 렉시컬 환경 생성

   foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩한다.

   1. 함수 환경 레코드 생성

      함수 환경 레코드는 매개변수, arguments 객체, 함수 내부에서 선언한 지역 변수와 중첩 함수를 등록하고 관리한다.

   2. this 바인딩

      함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다. 이 슬롯에 바인딩될 객체는 22장에서 보았듯 함수 호출 방식에 따라 결정된다. foo 함수는 일반 함수로 호출되었으므로 this는 전역 객체를 가리킨다.

   3. 외부 렉시컬 환경에 대한 참조 결정

      foo 함수는 전역 코드에 정의된 전역 함수다. 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트다. 따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다.



#### 23.6.5 foo 함수 코드 실행

foo 함수의 코드가 순차적으로 실행되기 시작한다. 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당된다. 그리고 bar가 호출된다.



#### 23.6.6 bar 함수 코드 평가

bar 함수가 호출되면 bar 함수 내부로 코드의 제어권이 이동하여 평가한다. 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드의 평가와 동일하다. bar 함수의 외부 렉시컬 환경에 대한 참조는 foo 함수의 렉시컬 환경이 된다.



#### 23.6.7 bar 함수 코드 실행

bar 함수의 소스코드가 순차적으로 실행된다. 그리고 console.log가 실행된다.



##### console 식별자 검색

console 식별자를 스코프 체인에서 검색한다. 현재 실행중인 실행 컨텍스트는 bar 함수 실행 컨텍스트다. 이곳(bar 함수 렉시컬 환경)에 console 식별자가 없으니 상위 스코프(foo 함수 렉시컬 환경)로 이동하여 검색한다. 이곳에도 없으니 상위 스코프(전역 렉시컬 환경)로 이동하여 console 식별자를 검색하고 console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.



##### log 메서드 검색

console 객체에서 log 메서드를 검색한다. 이때 console 객체의 프로토타입 체인을 통해 메서드를 검색한다. log는 상속된 프로퍼티가 아니라 console 객체가 직접 소유하는 프로퍼티다.

```js
console.hasOwnProperty('log');	// true
```



##### 표현식 a + b + x + y + z의 평가

표현식의 평가를 위해 a, b, x, y, z 식별자를 검색한다. 식별자는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경(상위 스코프)에 대한 참조로 이어지는 렉시컬 환경의 연속에서 검색한다.

a, x, y는 foo 함수 렉시컬 환경, b, z는 bar 함수 렉시컬 환경에서 검색된다.



##### console.log 메서드 호출

표현식이 평가되어 생성한 값 42를 console.log 메서드에 전달하여 호출한다.



#### 23.6.8 bar 함수 코드 실행 종료

더 실행할 코드가 없으니 bar 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop되어 제거되고 foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.

bar 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 렉시컬 환경은 독립적인 개체이기 때문에 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리의 공간의 확보가 해제되어 소멸한다.



#### 23.6.9 foo 함수 코드 실행 종료

bar 함수가 종료되면 더 이상 실행할 코드가 없으므로 foo 함수도 실행이 종료된다. foo 함수 실행 컨텍스트가 pop되어 제거되고 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다.



#### 23.6.10 전역 코드 실행 종료

foo 함수가 종료되면 더 이상 실행할 코드가 없으므로 전역 코드의 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 pop되어 아무것도 남지 않게 된다.



### 23.7 실행 컨텍스트와 블록 레벨 스코프

var 키워드로 선언한 변수는 함수 레벨 스코프지만 let과 const로 선언한 변수는 블록 레벨 스코프를 따른다.

```js
let x = 1;

if(true){
    let x = 10;
    console.log(x);	// 10
}

console.log(x);	// 1
```

if 문의 코드 블록이 실행되면 if 문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다. 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. 이때 새롭게 생성된 if 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if 문이 실행되기 이전의 전역 렉시컬 환경을 가리킨다.

이는 if 문뿐 아니라 블록 레벨 스코프를 생성하는 모든 블록문에 적용된다. for 문의 변수 선언문에 let 키워드를 사용한 for 문은 코드 블록이 반복해서 실행될 때마다 코드 블록을 위한 새로운 렉시컬 환경을 생성한다. 만약 for 문의 코드 블록 내에서 정의된 함수가 있다면 이 함수의 상위 스코프는 for 문이 생성한 렉시컬 환경이다. 이때 함수의 상위 스코프는 for 문의 코드 블록이 반복해서 실행될 때마다 식별자의 값을 유지해야 한다. 이를 위해 for 문의 코드 블록이 반복해서 실행될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다.

------

## 24장 클로저

클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다. 클로저는 자바스크립트 고유의 개념이 아니므로 ECMAScript 사양에 등장하지 않는다. 대신 MDN에서는 클로저에 대해 다음과 같이 정의한다.

**클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.**

```js
const x = 1;

function outerFunc() {
  const x = 10;

  function innerFunc() {
    console.log(x); // 10
  }

  innerFunc();
}

outerFunc();
```

outerFunc 함수 내부에서 중첩 함수 innerFunc가 정의되고 호출되었다. 이때 중첩 함수 innerFunc의 상위 스코프는 외부 함수 outerFunc의 스코프다. 따라서 innerFunc는 외부 함수 outerFunc의 x 변수에 접근할 수 있다.

만약 innerFunc가 outerFunc의 중첩 함수가 아니라면 outerFunc 함수의 변수에 접근할 수 없을 것이다.

```js
const x = 1;

function outerFunc() {
  const x = 10;
  innerFunc();
}

function innerFunc() {
  console.log(x); // 1
}

outerFunc();
```

이러한 이유는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문이다.



### 24.1 렉시컬 스코프

렉시컬 스코프를 실행 컨텍스트의 관점에서 다시 한번 살펴보자.

**자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.**

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

foo 함수와 bar 함수는 모두 전역에서 정의된 전역 함수다. 함수의 상위 스코프는 함수를 어디서 정의했느냐에 따라 결정되므로 foo 함수와 bar 함수의 상위 스코프는 전역이다. 함수를 어디서 호출하는지는 함수의 상위 스코프 결정에 어떠한 영향도 주지 못한다.

23장 실행 컨텍스트에서 살펴보았듯이 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 이 렉시컬 환경은 자신의 "외부 렉시컬 환경에 대한 참조"를 통해 상위 렉시컬 환경과 연결된다. 이것이 바로 스코프 체인이다. 따라서 함수의 상위 스코프를 결정한다는 것은 외부 렉시컬 환경에 대한 참조를 결정하는 것이다. 이것을 반영해서 다시 렉시컬 스코프를 정의해 보면 다음과 같다.

**렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 바로 렉시컬 스코프다.**



### 24.2 함수 객체의 내부 슬롯 [[Environment]]

함수가 정의된 환경(위치)과 호출되는 환경(위치)은 다를 수 있다. 따라서 상위 스코프를 기억해야 하기 때문에 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.

함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부 슬롯 [[Environment]]에 저장한다. 이때 자신의 내부 슬롯에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.

예를 들어, 전역에서 정의된 함수 선언문은 전역 코드가 평가되는 시점에 객체를 생성한다. 이때 생성된 함수 객체의 내부 슬롯 [[Environment]]에는 함수 정의가 평과되는 시점인 전역 코드 평가 시점에 실행 중인 컨텍스트의 렉시컬 환경 즉, 전역 렉시컬 환경의 참조가 저장된다.

```js
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수 정의 환경(위치)에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 아무런 관계가 없다.
  bar();
}

// 함수 bar는 자신의 상위 스코프, 즉 전역 렉시컬 환경을 [[Environment]]에 저장하여 기억한다.
function bar() {
  console.log(x);
}

foo(); // ?
bar(); // ?
```

foo 함수와 bar 함수는 모드 전역 함수로 선언되었다. 따라서 두 함수 모두 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성하고 전역 객체 window의 메서드가 된다.

함수가 호출되면 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 함수 코드 평가는 아래 순서로 진행된다.

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성
   1. 함수 환경 레코드 생성
   2. this 바인딩
   3. 외부 렉시컬 환경에 대한 참조 결정

이때 외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯[[Environment]]에 저장된 렉시컬 환경의 참조가 할당된다.



### 24.3 클로저와 렉시컬 환경

```js
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```

outer 함수를 호출하면 outer 함수는 중첩 함수 inner를 반환하고 생명 주기를 마감(= 실행 컨텍스트를 pop)한다. 이때 outer 함수의 지역 변수 x는 접근할 방법이 없어 보이지만 코드의 실행 결과는 10이다.

이처럼 **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.**

자바스크립트의 모든 함수는 자신의 상위 스코프를 기억한다. 따라서 함수는 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있으며 식별자에 바인딩된 값을 변경할 수도 있다. 위 예제에서 inner 함수는 자신이 평가될 때 자신이 정의된 위치에 의해 결정된 상위 스코프를 [[Environment]] 내부 슬롯에 저장한다. 이때 저장된 상위 스코프는 함수가 존재하는 한 유지된다.

위 예제에서 outer 함수의 실행이 종료되면 inner 함수를 반환하면서 outer 함수의 생명 주기가 종료된다. 이때 outer 함수의 실행 컨텍스트는 제거되지만 outer 함수의 렉시컬 환경까지 소멸하는 것은 아니다. inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되고 있기 때문이다.

자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 일반적으로 클로저라고 하지 않는다.
      function bar() {
        const z = 3;

        debugger;
        // 상위 스코프의 식별자를 참조하지 않는다.
        console.log(z);
      }

      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 외부 함수 foo보다 더 오래 유지되지만 상위 스코프의 어떤 식별자도 참조하지 않는다. 이처럼 상위 스코프의 어떤 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다. 따라서 bar 함수는 클로저라고 할 수 없다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;

      // 일반적으로 클로저라고 하지 않는다.
      // bar 함수는 클로저였지만 곧바로 소멸한다.
      function bar() {
        debugger;
        // 상위 스코프의 식별자를 참조한다.
        console.log(x);
      }
      bar();
    }

    foo();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 하지만 외부 함수 foo의 외부로 중첩 함수 bar가 반환되지 않는다. 즉, 외부 함수 foo 보다 중첩 함수 bar의 생명 주기가 짧다. 이런 경우 중첩 함수 bar는 클로저였지만 외부 함수보다 일찍 소멸되기 때문에 클로저의 본질에 부합하지 않는다. 따라서 bar는 일반적으로 클로저라고 하지 않는다.

```html
<!DOCTYPE html>
<html>
<body>
  <script>
    function foo() {
      const x = 1;
      const y = 2;

      // 클로저
      // 중첩 함수 bar는 외부 함수보다 더 오래 유지되며 상위 스코프의 식별자를 참조한다.
      function bar() {
        debugger;
        console.log(x);
      }
      return bar;
    }

    const bar = foo();
    bar();
  </script>
</body>
</html>
```

위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 외부 함수보다 오래 살아 남는다. 이러한 중첩 함수를 클로저라고 부른다. **클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.**

이론적으로 클로저는 상위 스코프를 기억해야 하므로 불필요한 메모리의 점유를 걱정할 수도 있지만 모던 자바스크립트 엔진은 최적화가 잘 되어있기 때문에 불필요한 식별자는 기억하지 않는다. 즉, 상위 스코프의 식별자 중에서 기억해야 할 식별자만 기억한다.



### 24.4 클로저의 활용

**클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.** 다시 말해, **상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.**

```js
// 카운트 상태 변수
let num = 0;

// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 예제는 잘 작동하지만 오류를 발생시킬 가능성을 내포하고 있다.

1. 카운트 상태는 increase 함수가 호출되기 전까지 변경되지 않고 유지되어야 한다.
2. 카운트 상태는 increase 함수만이 변경할 수 있어야 한다.



```js
// 카운트 상태 변경 함수
const increase = function () {
  // 카운트 상태 변수
  let num = 0;

  // 카운트 상태를 1만큼 증가 시킨다.
  return ++num;
};

// 이전 상태를 유지하지 못한다.
console.log(increase()); // 1
console.log(increase()); // 1
console.log(increase()); // 1
```

위 예제는 num을 지역 변수로 변경하의 의도치 않은 상태 변경은 방지했지만 이전 상태를 유지할 수 없다.



```js
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // 카운트 상태를 1만큼 증가 시킨다.
    return ++num;
  };
}());

console.log(increase()); // 1
console.log(increase()); // 2
console.log(increase()); // 3
```

위 코드가 실행되면 즉시 실행 함수가 호출되고 반환한 함수가  increase 변수에 할당된다. increase 변수에 할당된 함수는 자신이 정위된 위치에 의해 결정된 상위 스코프인 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다.

클로저는 increase 변수에 할당되어 호출된다. 즉시 실행 함수는 소멸했지만 즉시 실행 함수의 렉시컬 환경은 클로저에 기억되고 있기 때문에 increase를 통해서만 num을 변경시킬 수 있게 된다.



### 24.5 캡슐화와 정보 은닉

캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉이라 한다.

정보 은닉은 정보를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.

대부분의 객체지향 프로그래밍 언어는 접근 제한자(public, private, protected)를 선언하여 공개 범위를 한정할 수 있다. 하지만 자바스크립트는 이를 제공하지 않는다.

```js
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private

  // 인스턴스 메서드
  this.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };
}

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

여기서 name 프로퍼티는 공개되어 있어서 자유롭게 참조하거나 변경할 수 있다. 하지만 _age 변수는 Person 생성자 함수의 지역 변수이므로 외부에서 참조하거나 변경할 수 없다. 즉, private 하다.

위 예제는 sayHi 메서드가 Person 객체를 생성할 때마다 중복되어 생성되니 이를 방지해보자.

```js
function Person(name, age) {
  this.name = name; // public
  let _age = age;   // private
}

// 프로토타입 메서드
Person.prototype.sayHi = function () {
  // Person 생성자 함수의 지역 변수 _age를 참조할 수 없다
  console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
};
```

이때 Person.prototype.sayHi 메서드 내에서 Person 생성자 함수의 지역 변수 _age를 참조할 수 없는 문제가 발생한다. 따라서 Person 생성자 함수와 sayHi 메서드를 하나의 함수 내에 모아 보자.

```js
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수를 반환
  return Person;
}());

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined
```

위 패턴을 사용하면 접근 제한자 없이 자바스크립트에서도 정보 은닉이 가능한 것처럼 보인다. 하지만 이 코드도 문제가 있다. Person 생성자 함수가 여러 개의 인스턴스를 생성할 경우 다음과 같이 _age 변수의 상태가 유지되지 않는다는 것이다.

```js
const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.

// _age 변수 값이 변경된다!
me.sayHi(); // Hi! My name is Lee. I am 30.
```

이는 Person.prototype.sayHi 메서드가 단 한 번 생성되는 클로저이기 때문에 발생하는 현상이다. sayHi 메서드는 자신의 상위 스코프인 즉시 실행 함수의 실행 컨텍스트의 렉시컬 환경의 참조를 [[Environment]]에 저장하여 기억한다. 따라서 Person 생성자 함수의 모든 인스턴스가 상속을 통해 호출할 수 있는 sayHi 메서드의 상위 스코프는 어떤 인스턴스로 호출하더라도 하나의 동일한 상위 스코프를 사용하게 된다. 이러한 이유로 _age의 상태가 유지되지 않는다.

이처럼 자바스크립트는 정보 은닉을 완전하게 지원하지 않는다.



### 24.6 자주 발생하는 실수

아래는 클로저를 사용할 때 자주 발생할 수 있는 실수를 보여주는 예제다.

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () { return i; }; // ①
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ②
}
```

var가 함수 레벨 스코프를 갖기 때문에 i 가 전역 변수가 되어 발생하는 문제이다. 클로저를 사용해 위 예제를 제대로 동작하게 만들자

```js
var funcs = [];

for (var i = 0; i < 3; i++){
  funcs[i] = (function (id) { // ①
    return function () {
      return id;
    };
  }(i));
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

또는 var를 let으로 바꾸어 해결할 수도 있다

```js
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () { return i; };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0 1 2
}
```

let이나 const 키워드를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 마치 스냅숏을 찍는 것처럼 저장한다. 단, 이는 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다. 블록 내부에 함수 정의가 없는 반복문이 생성하는 렉시컬 환경은 반복 직후, 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다.

------

## 25장 클래스

### 25.1 클래스는 프로토타입의 문법적 설탕인가?

자바스크립트는 프로토타입 기반 객체지향 언어다. 그리고 프로토타입 기반 객체지향 언어는 클래스가 필요 없는 프로그래밍 언어다.

```js
// 클래스 없이도 상속을 구현할 수 있다.
var Person = (function(){
    function Person(name){
        this.name = name;
    }
    
    Person.prototype.sayHi = function(){
        console.log(`Hi! My name is ${this.name}`);
    };
    
    return Person;
}());

var me = new Person('Lee');
me.sayHi();	// Hi! My name is Lee
```

하지만 클래스 기반 언어에 익숙한 프로그래머들을 위해 ES6에서 클래스가 도입되었다. 하지만 사실 여기서 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고 볼 수도 있다.

단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다. 클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.

클래스와 생성자 함수의 차이점은 다음과 같다.

1. 클래스를 new 연산자 없이 호출하면 에러가 발생한다. 하지만 생성자 함수는 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false다. 열거되지 않는다.

생성자 함수와 클래스는 프로토타입 기반의 객체지향을 구현했다는 점에서 매우 유사하다. 하지만 클래스는 생성자 함수 기반의 객체 생성 방식보다 견고하고 명료하다. 따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 메커니즘**으로 보는 것이 좀 더 합당하다.



### 25.2 클래스 정의

클래스는 class 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다. 물론 사용하지 않아도 에러는 발생하지 않는다.

```js
class Person {}
```

함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. 이때 이름을 가질수도, 갖지 않을 수도 있다.

```js
const Person = class {};

const Person = class MyClass {};
```

클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용 가능한 일급 객체라는 것을 의미한다. 

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

클래스 몸체에 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드의 세 가지가 있다.

```js
class Person {
	constructor(name){
        // 인스턴스 생성 및 초기화
        this.name = name;
    }
    
    // 프로토타입 메서드
    sayHi() {
        console.log(`Hi! My name is ${this.name}`);
    }
    
    // 정적 메서드
    static sayHello(){
        console.log('Hello!');
    }
}

// 인스턴스 생성
const me = new Person('Lee');
// 프로토타입 메서드 호출
me.sayHi();
// 정적 메서드 호출
Person.sayHello();
```



### 25.3 클래스 호이스팅

클래스는 함수로 평가된다

```js
class Person {}

console.log(typeof Person);	// function
```

클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가 과정(런타임 이전)에 먼저 평가되어 함수 객체를 생성한다. 이때 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 constructor다. 이 생성자 함수로서 호출할 수 있는 함수는 평가되어 함수 객체를 생성하는 시점에 프로토타입도 같이 생성된다.

클래스는 정의 이전에 참조할 수 없다.

```js
console.log(Person);
// ReferenceError

class Person {}
```

클래스 선언문은 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

```js
const Person = '';

{
    // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
    console.log(Person);
    // ReferenceError
    
    // 클래스 선언문
    class person {}
}
```

클래스 선언문도 호이스팅이 발생한다. 단, let, const 키워드로 선언한 변수처럼 호이스팅된다. 그래서 일시적 사각지대가 생기기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.



### 25.4 인스턴스 생성

클래스 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.

```js
class Person {}

const me = new Person();
console.log(me);	// Person {}
```

함수는 new 연산자의 여부에 따라 용도가 바뀌지만 클래스는 용도가 하나이므로 반드시 new 연산자와 함께 호출해야 한다.

클래스 표현식으로 정의된 클래스의 경우 식별자를 사용해 인스턴스를 생성해야 한다.

```js
const Person = class MyClass{};

const me = new Person();	// 정상

const you = new MyClass();	// ReferenceError
```



### 25.5 메서드

클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다. 가능한 메서드의 종류는 constructor, 프로토타입 메서드, 정적 메서드의 세 가지가 있다.

#### 25.5.1 constructor

constructor는 인스턴스를 생성하고 초기화하기 위한 특수 메서드다. 이름을 변경할 수 없다.

```js
class Person {
    constructor(name){
        // 인스턴스 생성 및 초기화
        this.name = name;
    }
}
```

constructor는 클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스 어디에도 보이지 않는다. 이는 contructor가 단순한 메서드가 아니라는 것을 의미한다.

constructor는 클래스가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다. constructor와 생성자 함수는 유사하지만 몇 가지 차이가 있다.

1. constructor는 클래스 내에 최대 한 개만 존재할 수 있다.

   ```js
   class Person(){
       constructor(){}
       constructor(){}
   }
   // SyntaxError
   ```

2. constructor는 생략할 수 있다.

   ```js
   class Person {}
   ```

constructor를 생략하면 클래스에 빈 constructor가 암묵적으로 정의된다. 객체를 생성하면 빈 객체를 생성하게 된다. 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다.

```js
class Person{
    // constructor를 생략하면 빈 constructor가 암묵적으로 정의된다.
    constructor() {
        // 인스턴스를 초기화
        this.name = 'Lee';
        this.address = 'Seoul';
    }
}

// 인스턴스 프로퍼티가 추가된다.
const me = new Person();
```

인스턴스 생성 시 외부에서 초기값을 전달하려면 constructor에 매개변수를 주면 된다.

```js
class Person{
    constructor(name, address){
        this.name = name;
        this.address = address;
    }
}

// 인수로 초기값 전달
const me = new Person('Lee', 'Seoul');
console.log(me);
```

constructor 내에서는 인스턴스의 생성과 동시에 인스턴스 초기화를 실행한다. 따라서 인스턴스를 초기화하려면 constructor를 생략해서는 안 된다.

constructor는 반환문을 갖지 않아야 한다. new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this, 즉 인스턴스를 반환하기 때문이다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 인스턴스가 반환되지 못하고 return 문에 명시한 객체가 반환된다.

```js
class Person{
    constructor(name){
        this.name = name;
        
        return {};
        // return 100;
        // 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.
    }
}

// 빈 객체가 반환된다.
const me = new Person('Lee');
console.log(me);	// {}
```



#### 25.5.2 프로토타입 메서드

생성자 함수를 이용하여 인스턴스를 생성하는 경우 명시적으로 포로토타입에 메서드를 추가해야 한다.

```js
function Person(name){
	this.name = name;
}

Person.prototype.sayHi = function (){
    console.log(`Hi! My name is ${this.name}`);
};
```

하지만 클래스 몸체에서 정의한 메서드는 prototype 프로퍼티에 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

```js
class Person {
    // 생성자
	constructor(name){
        this.name = name;
    }
    
    // 프로토타입 메서드
    sayHi(){
        console.log(`Hi! My name is ${this.name}`);
    }
}
```

생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.

프로토타입 체인은 기존의 모든 객체 생성 방식 뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다. 생성자 함수의 역할을 클래스가 하는 것이다. 결국 클래스는 인스턴스를 생성하는 생성자 함수라고 볼 수 있다. 다시 말해, 클래스도 프로토타입 기반의 객체 생성 메커니즘이다.



#### 25.5.3 정적 메서드

정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드를 말한다. 생성자 함수의 경우 정적 메서드를 생성하려면 생성자 함수에 메서드를 추가해야 한다.

```js
function Person(name){
    this.name = name;
}

// 정적 메서드
Person.sayHi = function(){
    console.log(`Hi!`);
};
```

클래스에서는 메서드에 static 키워드를 붙이면 정적 메서드가 된다.

```js
class Person {
    constructor(name){
        this.name = name;
    }
    
    static sayHi(){
        console.log(`Hi!`);
    }
}
```

클래스는 함수 객체로 평가되기 때문에 자신의 프로퍼티/메서드를 소유할 수 있다. 또한 클래스는 평가 시점에 객체가 되므로 별다른 생성 과정이 필요 없다. 따라서 인스턴스를 생성하지 않고도 호출할 수 있다.

정적 메서드는 인스턴스가 아닌 클래스로 호출한다.

```js
Person.sayHi();	// Hi!
```

정적 메서드는 인스턴스로 호출할 수 없다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인에 존재하지 않기 때문이다.

```js
const me = new Person('Lee');
me.sayHi();	// TypeError
```



#### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.
3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.

```js
class Square{
	static area(width, height){
        return width * height;
    }
}

console.log(Square.area(10, 10));	// 100
```

```js
class Square {
    constructor(width, height){
        this.width = width;
        this.height = height;
    }
    
    area(){
        return this.width * this.height;
    }
}

const square = new Square(10, 10);
console.log(square.area());	// 100
```

프로토타입 메서드의 경우 area를 호출한 인스턴스가 square이니 this에 square가 바인딩되고 정적 메서드의 경우 Square가 바인딩된다. 서로의 this 바인딩이 다르다.

따라서 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용하고(프로토타입 메서드), 아니라면 this를 사용하지 않아도 된다(정적 메서드).

표준 빌트인 객체인 Math, Number, JSON 등은 다양한 정적 메서드를 가지고 있다. 이 정적 메서드들은 인스턴스와 상관없이 애플리케이션 전역에서 사용가능한 함수들이다.



#### 25.5.5 클래스에서 정의한 메서드의 특징

1. function 키워드를 생략한 메서드 축약 표현을 사용한다.
2. 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없다.
3. 암묵적으로 strict mode로 실행된다.
4. for ... in 문이나 Object.keys 메서드 등으로 열거할 수 없다. 즉, [[Enumerable]]의 값이 false다.
5. 내부 메서드 [[Construct]]를 갖지 않는 non-constructor다. new 연산자와 함께 호출할 수 없다.



### 25.6 클래스의 인스턴스 생성 과정

new 연산자와 함께 클래스를 호출하면 [[Construct]]가 호출된다.

#### 1. 인스턴스 생성과 this 바인딩

new 연산자와 함께 클래스를 호출하면 constructor의 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성된다. 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 this에 이 빈 객체가 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.

#### 2. 인스턴스 초기화

constructor 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. constructor가 생략되었다면 이 과정도 생략된다.

#### 3. 인스턴스 반환

클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.



### 25.7 프로퍼티

#### 25.7.1 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.

```js
class Person{
    constructor(name){
        // 인스턴스 프로퍼티
        this.name = name;
    }
}

const me = new Person('Lee');

console.log(me.name);	// Lee
```

new 연산자와 함께 클래스를 호출하면 this를 통해 바인딩 된 빈 객체에 프로퍼티를 추가하여 인스턴스가 초기화한다.



#### 25.7.2 접근자 프로퍼티

접근자 프로퍼티는 자체적인 값은 없지만 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 함수로 구성된 프로퍼티다.

```js
const person = {
    firstName: 'Ungmo',
    lastName: 'Lee',
    
    get fullName(){
        return `${this.firstName} ${this.lastName}`;
    }
    
    set fullName(name){
        [this.firstName, this.lastName] = name.split(' ');
    }
};

// 데이터 프로퍼티를 통한 값의 참조
console.log(`${this.firstName} ${this.lastName}`);

// 접근자 프로퍼티를 통한 값의 저장
person.fullName = 'Heegun Lee';

// 접근자 프로퍼티를 통한 값의 참조
console.log(person.fullName);

class Person{
    constructor(firstName, lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    get fullName(){
        return `${this.firstName} ${this.lastName}`;
    }
    
    set fullName(name){
        [this.firstName, this.lastName] = name.split(' ');
    }
}

const me = new Person('Ungmo', 'Lee');

// 접근자 프로퍼티를 통한 값의 저장, 참조
me.fullName = 'Heegun Lee';
console.log(me.fullName);
```

클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.



#### 25.7.3 클래스 필드 정의 제안

클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어다. 자바의 클래스 정의를 살펴보자.

```java
public class Person{
    // 클래스 필드는 클래스 몸체에 this 없이 선언해야 한다.
    private String firstName = "";
    private String lastName = "";
    
    // 생성자
    Person(String firstName, String lastName){
        // this는 언제나 클래스가 생성할 인스턴스를 가리킨다.
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    public String getFullName(){
        // this 없이도 클래스 필드를 참조할 수 있다.
        return firstName + " " + lastName;
    }
}
```

자바스크립트의 클래스에서 인스턴스 프로퍼티를 선언하고 초기화하려면 반드시 constructor 내부에서 this에 프로퍼티를 추가해야 한다. 하지만 자바는 클래스 몸체에 this 없이 선언한다.

또한 프로퍼티를 참조하려면 자바스크립트는 this를 참조해야 하지만 자바는 this를 생략해도 클래스 필드를 참조할 수 있다.

클래스 기반 언어의 this는 언제나 클래스가 생성할 인스턴스를 가리킨다. 위 예자와 같이 this는 주로 클래스 필드가 생성자 또는 메서드의 매개변수 이름과 동일할 때 이를 명확히 하기 위해 사용한다.

자바스크립트의 클래스 몸체에는 메서드만 선언할 수 있다.

```js
class person {
    name = "Lee";
}

const me = new Person('Lee');
```

따라서 위 예제는 에러가 발생해야 하지만 그렇지 않다. 그 이유는 자바스크립트에서도 인스턴스를 마치 클래스 기반 객체지향 언어의 클래스처럼 정의할 수 있는 새로운 표준 사양이 제안(2021년 1월)되어 있기 때문이다.

클래스 몸체에서 클래스 필드를 정의할 수 있는 이 제안은 아직 ECMAScript 정식 표준 사양으로 승급되지 않았지만 최신 Node.js는 이를 미리 구현해 놓았다.

```js
class Person{
    name = 'Lee';
    // this에 클래스 필드를 바인딩해서는 안된다.
    // this.name = '';
    // SyntaxError
}
```

클래스 필드를 참조하는 경우 클래스 기반 객체지향 언어에서는 this를 생략할 수 있으나 자바스크립트는 this를 반드시 사용해야 한다.

```js
class Person {
    name = 'Lee';
    
    constructor(){
        console.log(name);	// ReferenceError
    }
}

new Person();
```

클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다

```js
class Person{
    name;	// undefined
}
```

인스턴스를 생성할 때 외부의 초기값으로 클래스 필드를 초기화해야 할 필요가 있다면 constructor에서 초기화해야 한다(기존 방식)

함수는 일급 객체이니 함수를 클래스 필드에 할당할 수 있다. 따라서 클래스 필드를 통해 메서드를 정의할 수 있다.

```js
class Person{
    name = 'Lee';
    
    getName = function(){
        return this.name;
    }
}
```

이처럼 클래스 필드에 함수를 할당하는 경우, 이 함수는 프로토타입 메서드가 아닌 **인스턴스 메서드**가 된다. 모든 클래스 필드는 인스턴스 프로퍼티가 되기 때문이다.



#### 25.7.4 private 필드 정의 제안

이전에 살펴보았듯이 자바스크립트는 캡슐화를 완전하게 지원하지 않는다.

클래스 필드 정의 제안을 사용하더라도 기본적으로 public하기 때문에 외부에 그대로 노출된다.

```js
class Person{
    name = "Lee"
}

const me = new Person();
console.log(me.name);
```

현재는 private 필드를 정의할 수 있는 새로운 표준 사양이 제안(2021년 1월)되어 있다. 이 제안도 클래스 필드처럼 최신 Node.js에 구현되어 있다. private 필드의 선두엔 #을 붙여준다. private 필드를 참조할 때도 #을 붙여줘야 한다.

```js
class Person {
    #name = '';
    
    constructor(name){
        this.#name = name;
    }
}

const me = new person('Lee');

// private 필드는 외부에서 참조할 수 없다
console.log(me.#name);	// SyntaxError
```

이처럼 클래스 외부에서 private 필드에 직접 접근할 수 있는 방법은 없다. 다만 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.

```js
class Person{
    #name = '';
    
    constructor(name){
        this.#name = name;
    }
    
    get name(){
        return this.#name.trim();
    }
}

const me = new Person(' Lee ');
console.log(me.name);	// Lee
```

private 필드는 반드시 클래스 몸체에 정의해야 한다. constructor에 정의하면 에러가 발생한다.



#### 25.7.5 static 필드 정의 제안

클래스에는 static 키워드를 사용하여 정적 메서드를 정의 할 수 있지만 정적 필드는 정의할 수 없었다. 하지만 이것도 최신 Node.js에는 구현되어 있다.

```js
class MyMath {
    static PI = 22 / 7;
    
    // static private 필드 정의
    static #num = 10;

	// static 메서드
	static increment(){
        return ++MyMath.#num;
    }
}

console.log(MyMath.PI);	// 3.141592...
console.log(MyMath.increment());	// 11
```



### 25.8 상속에 의한 클래스 확장

#### 25.8.1 클래스 상속과 생성자 함수 상속

상속에 의한 클래스 확장은 프로토타입 기반 상속과는 다른 개념이다. 프로토타입 기반은 상속을 통해 다른 객체의 자산을 상속받는 개념이지만 **상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것**이다.

예를 들어, 동물을 추상화한 Animal 클래스와 새와 사자를 추상화한 Bird, Lion 클래스를 각각 정의한다고 하자. 새와 사자는 동물에 속하니 Animal을 상속받아 Animal의 속성을 그대로 사용하면서 자신만의 고유한 속성만을 추가하여 확장할 수 있다.

```js
class Animal{
    constructor(age, weight){
        this.age = age;
        this.weight = weight;
    }
    
    eat() {return 'eat';}
    
    move() {return 'move';}
}

class Bird extends Animal{
    fly() {return 'fly';}
}

const bird = new Bird(1, 5);

console.log(bird.eat());	// eat
console.log(bird.move());	// move
console.log(bird.fly());	// fly
```

클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다. extends를 사용한 클래스 확장은 간편하고 직관적이다. 하지만 생성자 함수는 클래스와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다.



#### 25.8.2 extends 키워드

상속을 통해 클래스를 확장하려면 extends 키워드를 사용한다.

```js
// 수퍼(베이스/부모) 클래스
class Base{}

// 서브(파생/자식) 클래스
class Derived extends Base{}
```

extends 키워드의 역할은 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다.

수퍼클래스와 서브클래스는 인스턴스의 프로토타입 체인뿐 아니라 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속이 가능하다.



#### 25.8.3 동적 상속

extends 키워드는 클래스 뿐만 아니라 생성자 함수를 상속받아 클래스를 확장할 수도 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야 한다.

```js
function Base(a){
    this.a = a;
}

class Derived extends Base{}

const derived = new Derived(1);
console.log(derived);	//	 Derived{a: 1}
```

extneds 키워드 다음에는 클래스 뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체로 평가될 수 있는 모든 표현식을 사용할 수 있다.

```js
function Base1(){}

class Base2 {}

let condition = true;

// 조건에 따라 동적으로 상속 대상을 결정
class Derived extends (condition ? Base1 : Base2){}

const derived = new Derived();

console.log(derived instanceof Base1);	// true
console.log(derived instanceof Base2);	// false
```



#### 25.8.4 서브 클래스의 constructor

서브클래스에서 constructor를 생략하면 다음과 같은 constructor가 암묵적으로 정의된다. args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트다.

```js
constructor(...args){super(...args)}
// super()는 수퍼클래스의 constructor를 호출하여 인스턴스를 생성한다
```



#### 25.8.5  super 키워드

super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드다.

- super를 호출하면 수퍼클래스의 constructor를 호출한다.
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

##### super 호출

```js
class Base{
    constructor(a, b){
        this.a = a;
        this.b = b;
    }
}

class Derived extends Base{
    // 암묵적으로 constructor가 정의된다
    // constructor(...args){ super(...args); }
}

const derived = new Derived(1, 2);
console.log(derived);	// Derived {a: 1, b: 2}
```

super가 수퍼클래스의 constructor를 호출하여서 a, b 프로퍼티가 초기화 되었다.

수퍼클래스에서 추가한 프로퍼티에 추가로 서브클래스에서 프로퍼티를 추가하면 constructor를 생략할 수 없다. 이때는 서브클래스의 constructor에서 호출하는 super를 통해 전달한다.

```js
class Base{
    constructor(a, b){
        this.a = a;
        this.b = b;
    }
}

class Derived extends Base{
    constructor(a, b, c){
        super(a, b);
        this.c = c;
    }
}

const derived = new Derived(1, 2, 3);
console.log(derived);	// Derived {a: 1, b: 2, c: 3}
```

super를 호출할 때 주의사항은 다음과 같다.

1. 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 cnstructor에서는 반드시 super를 호출해야 한다.
2. 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
3. super는 반드시 서브클래스의 constructor에서만 호출한다.



##### super 참조

메서드 내에서 super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

```js
// 서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킨다.
class Base{
    constructor(name){
        this.name = name;
    }
    
    sayHi(){
        return `Hi! ${this.name}`;
    }
}

class Derived extends Base{
    sayHi(){
        return `${super.sayHi()}. how are you doing?`''
    }
}

const derived = new Derived('Lee');
console.log(derived.sayHi());	// Hi! Lee. how are you doing?
```

super 참조를 통해 수퍼클래스의 메서드를 참조하려면 super가 수퍼클래스의 prototype에 바인딩된 프로토타입을 참조할 수 있어야 한다. 다시 말해 super를 호출한 클래스가 수퍼클래스에 바인딩되어 있어야 한다.

```js
// 서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킨다
class Base{
    static sayHi(){
        return 'Hi!';
    }
}

class Derived extends Base{
    static sayHi(){
        return `${super.sayHi()} how are you doing?`;
    }
}

console.log(Derived.sayHi());	// Hi! how are you doing?
```



#### 25.8.6 상속 클래스의 인스턴스 생성 과정

직사각형 Rectangle 클래스와 상속받은 ColorRectangle 클래스로 상속 관계의 두 클래스가 어떻게 인스턴스를 생성하는지 살펴보도록 하자.

```js
class Rectangle{
    constructor(width, height){
        this.width = width;
        this.height = height;
    }
    
    getArea(){
        return this.width * this.height;
    }
    
    toString(){
        return `width = ${this.width}, height = ${this.height}`;
    }
}

class ColorRectange extends Rectangle{
    constructor(width, height, color){
        super(width, height);
        this.color = color;
    }
    
    // 메서드 오버라이딩
    toStrgin(){
        return super.toString() + `, color = ${this.color}`;
    }
}

const colorRectangle = new ColorRectangle(2, 4, 'red');

console.log(colorRectangle.getArea());	// 8
console.log(colorRectangle.toString());	// width = 2, height = 4, color = red
```

##### 1. 서브클래스의 super 호출

자바스크립트 엔진을 클래스를 평가할 때 부모와 자식을 구분하기 위해 base 또는 derived를 값으로 갖는 내부 슬롯 [[ConstructorKind]]를 갖는다. 상속받지 않았다면 base지만 상속받았다면 derived를 값으로 갖는다. 이를 통해 수퍼클래스와 서브클래스는 new 연산자와 함께 호출되었을 때의 동작이 구분된다.

base의 경우 new 연산자와 호출되면 빈 객체를 생성하지만 derived의 경우는 **자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다. 이것이 서브클래스의 constructor에서 반드시 super를 호출해야 하는 이유다.**

서브클래스가 new 연산자와 호출되면 서브클래스 constructor 내부의 super 키워드가 함수처럼 호출된다(없으면 에러가 발생한다). super가 호출되면 수퍼클래스의 constructor가 호출된다. 



##### 2. 수퍼클래스의 인스턴스 생성과 this 바인딩

수퍼클래스의 constructor 내부의 코드가 실행되기 전 빈 객체를 생성하여 this에 바인딩한다.

```js
class Rectangle{
    constructor(width, height){
        // 암묵적으로 빈 객체를 생성하고 this에 바인딩한다.
        // new ColorRectangle이니 this는 Rectangle이 아니라 ColorRectangle이 된다.
        console.log(this);	// ColorRectangle {}
        
        // new 연산자와 함께 호출된 함수는 ColorRectangle이다.
        console.log(new.target);	// ColorRectangle
        ...
    }
}
```

인스턴스는 수퍼클래스가 생성했지만 new 연산자는 서브클래스가 호출되었다는 것이 중요하다.



##### 3. 수퍼클래스의 인스턴스 초기화

수퍼클래스의 constructor가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.



##### 4. 서브클래스 constructor로의 복귀와 this 바인딩

super의 호출이 종료되고 constructor로 돌아온다. 이때 super가 반환한 인스턴스가 this에 바인딩된다. **서브클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩하여 그대로 사용한다.**

```js
class ColorRectangle extends Rectangle{
    constructor(width, height, color){
        super(width, height);
        
        // super가 반환한 인스턴스가 this에 바인딩된다.
        console.log(this);	// ColorRectangle {width: 2, height: 4}
        ...
    }
}
```

이처럼 **super가 호출되지 않으면 인스턴스가 생성되지 않고, this 바인딩도 할 수 없다. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없는 이유가 바로 이 때문이다.** 서브클래스가 인스턴스를 생성하지 않으니 알고나면 당연하게 생각하게 된다.



##### 5. 서브클래스의 인스턴스 초기화

서브클래스의 constructor에 기술되어 있는 인스턴스 초기화가 실행된다.



##### 6. 인스턴스 반환

모든 처리가 끝나면 바인딩된 this가 암묵적으로 반환된다.



#### 25.8.7 표준 빌트인 생성자 함수 확장

동적 상속에서 살펴보았듯 extends 뒤에는 [[Construct]]가 있는 함수 객체를 모두 사용할 수 있다.

```js
// Array 생성자 함수를 상속받아 확장한 MyArray
class MyArray extneds Array {
    // 중복된 배열 요소를 제거하고 반환한다.
    uniq(){
        return this.filter((v, i, self) => self.indexOf(v) === i);
    }
    
    // 모든 배열 요소의 평균을 구한다.
    average(){
        return this.reduce((pre, cur) => pre + cur, 0) / this.length;
    }
}

const myArray = new MyArray(1, 1, 2, 3);

console.log(myArray.uniq());	// MyArray(3) [1, 2, 3]
console.log(myArray.average());	// 1.75
```

이때 주의할 것은 Array.prototype의 메서드 중 map, filter와 같이 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환한다는 것이다.

만약 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환하지 않고 Array의 인스턴스를 반환하면 MyArray 클래스의 메서드와 메서드 체이닝이 불가능하다.

```js
console.log(myArray.filter(v => v % 2).uniq().average());	// 2
```

MyArray 타입을 반환하지 않는다면 uniq, average 모두 메서드 체이닝이 될 수 없다.

만약 MyArray 클래스의 uniq 메서드가 MyArray 클래스가 생성한 인스턴스가 아닌 Array가 생성한 인스턴스를 반환하게 하려면 Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가한다.

```js
class MyArray extends Array {
    static get [Symbol.species]() { return Array; }
    
    uniq(){
        return this.filter((v, i, self) => self.indexOf(v) === i);
        
        average(){
            return this.reduce((pre, cur) => pre + cur, 0) / this.length;
        }
    }
}

const myArray = new MyArray(1, 1, 2, 3);

console.log(myArray.uniq() instanceof MyArray);	// false

// 메서드 체이닝
console.log(myArray.uniq().average());
// uniq메서드는 Array 인스턴스를 반환하므로 average 메서드를 호출할 수 없다.
```

------

## 26장 ES6 함수의 추가 기능

### 26.1 함수의 구분

ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다. 이는 언뜻 보면 편리해 보이지만 실수를 유발시킬 수도 있고 성능 면에서도 손해다.

```js
var foo = function(){
    return 1;
}

// 일반적인 함수로서 호출
foo();

// 생성자 함수로서 호출
new foo();

// 메서드로서 호출
var obj = {foo: foo};
obj.foo();	// 1
```

ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있었다. 이는 메서드 또한 마찬가지 였는데, 메서드가 constructor라는 것은 메서드가 prototype 프로퍼티를 가진다는 것을 의미하기 때문이다. 콜백 함수 또한 마찬가지로 불필요한 프로토타입 객체를 생성한다.

```js
var obj = {
    x: 10,
    f: function () {return this.x;}
}

// 메서드 호출
console.log(obj.f());	// 10

// 일반 함수 호출
var bar = obj.f;
console.log(bar());	// undefined

// 메서드를 생성자 함수로 호출
console.log(new obj.f());

// 콜백 함수도 constructor이며 프로토타입을 생성한다.
[1, 2, 3].map(function(item){
    return item * 2;
});
```

함수의 사용 목적에 따라 명확한 구분이 없으면 생성자 함수로 사용하지 않아도 프로토타입 객체를 생성한다. 이는 실수를 유발하기도 좋고 성능에도 좋지 않다. 이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

| ES6 함수의 구분 | constructor | prototype | super | argument |
| --------------- | ----------- | --------- | ----- | -------- |
| 일반 함수       | O           | O         | X     | O        |
| 메서드          | X           | X         | O     | O        |
| 화살표 함수     | X           | X         | X     | X        |



### 26.2 메서드

ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

```js
const obj = {
	x: 1,
    // foo는 메서드다
    foo() {return this.x;},
    // bar에 바인딩된 함수는 일반함수다
    bar: function(){return this.x;}
};

console.log(obj.foo());	// 1
console.log(obj.bar());	// 1

/*
ES6 사양에서 정의한 메서드는 non-constructor다. 따라서 생성자 함수로 호출할 수 없다.
*/
new obj.foo();	// TypeError
new obj.bar();	// bar {}
```

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다. super 참조는 이 내부 슬롯을 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 [[HomeObject]]를 갖는 ES6 메서드는 super 키워드를 사용할 수 있다.

```js
const base = {
    name: 'Lee',
    sayHi() {
        return `Hi! ${this.name}`;
    }
};

const derived = {
    __proto__: base,
    sayHi(){
        return `${super.sayHi()}. how are you doing?`;
    }
};

console.log(derived.sayHi());	// Hi! Lee. how are you doing?
```

이처럼 ES6 메서드는 super 기능은 추가하고 맞지 않는 constructor 기능은 제거했다. 따라서 메서드를 정의할 때 익명 함수 표현식을 할당하는 이전의 방식은 사용하지 않는 것이 좋다.



### 26.3 화살표 함수

화살표 함수는 function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다. 표현 뿐만 아니라 내부 동작도 기존의 함수보다 간략하다. 특히 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용하다.

#### 26.3.1 화살표 함수 정의

##### 함수 정의

함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다. 호출 방식은 기존 함수와 동일하다.

```js
const multiply = (x, y) => x * y;
multiply(2, 3);	// 6
```



##### 매개변수 선언

매개변수가 여러 개인 경우 소괄호 안에 매개변수를 선언한다.

```js
const arrow = (x, y) => {...}
```

매개변수가 하나인 경우 소괄호를 생략할 수 있다.

```js
const arrow = x => {...}
```

매개변수가 없는 경우 소괄호를 생략할 수 없다.

```js
const arrow = () => {...}
```



##### 함수 몸체 정의

함수 몸체가 하나의 문으로 구성된다면 중괄호를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.

```js
const power = x => x ** 2;
power(2);	// 4
```

중괄호를 생략한 경우 함수 몸체 내부의 문이 표현식이 아니라면 반환할 수 없기에 에러가 발생한다.

```js
const arrow = () => const x = 1;	// SyntaxError
```

객체 리터럴을 반환하는 경우 소괄호로 감싸 주어야 한다.

```js
// 객체를 소괄호로 감싸지 않으면 중괄호를 함수 몸체 부분으로 잘못 해석한다.
const create = (id, content) => ({id, content})

// 다음과 동일하다
const create = (id, content) => {return {id, content};};
```

화살표 함수도 즉시 실행 함수로 사용할 수 있다.

```js
const person = (name => ({
	sayHi() {return `Hi? My name is ${name}`;}
}))('Lee');

console.log(person.sayHi());
```

화살표 함수도 일급 객체이므로 고차 함수에 인수로 전달할 수 있다. 이 경우 표현식도 간결하고 가독성이 좋다.

```js
// ES5
[1, 2, 3].map(function(v){
    return v * 2;
});

// ES6
[1, 2, 3].map(v => v * 2);
```



#### 26.3.2 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.

2. 중복된 매개변수 이름을 선언할 수 없다.

   일반 함수는 중복된 매개변수를 선언해도 에러가 발생하지 않는다. 단, strict mode에서는 발생

   ```js
   function normal(a, a) { return a + a; }
   console.log(normal(1, 2));	// 4
   
   const arrow = (a, a) => a + a;
   // SyntaxError
   ```

3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

   화살표 함수 내에서 이것들을 참조하면 스코프 체인을 통해 상위 스코프에서 this, arguments, super, new.target을 참조한다.



#### 26.3.3 this

화살표 함수와 일반 함수가 구별되는 가증 큰 특징이다. 화살표 함수의 this는 일반 함수와 다르게 동작한다. 이는 콜백 함수 내부의 this와 외부 함수의 this가 다르게 떄문에 발생하는 문제이다.

this 바인딩은 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 이때 주의할 것은 일반 함수로서 호출되는 콜백 함수의 경우다.

```js
class Prefixer {
    constructor(prefix){
        this.prefix = prefix;
    }
    
    add(arr){
        return arr.map(function(item){
            return this.prefix + item;
        });
    }
}

const prefixer = new Prefixer('-webkit-');
console.log(prefixer.add(['transition', 'user-select']))
```

위 예제를 실행했을 때 기대하는 결과는 ['-webkit-transition', '-webkit-user-select']다. 하지만 TypeError가 발생한다.

프로토타입 메서드 내부인 add에서 this는 메서드를 호출한 객체(prefixer)를 가리킨다. 그런데 Array.prototype.map의 인수로 전달한 콜백 함수의 내부에서 this는 undefined를 가리킨다. 이는 Array.prototype.map 메서드가 콜백 함수를 일반 함수로서 호출하기 때문이다.

22장 this에서 보았듯이 일반 함수로 호출되는 모든 함수 내부의 this는 전역 객체를 가리킨다. 그런데 클래스 내부의 모든 코드엔 strict mode가 암묵적으로 혀용된다. 따라서 Array.prototype.map 메서드의 콜백 함수에도 strict mode가 적용된다. strict mode에선 일반함수 this에 undefined가 바인딩된다. 콜백함수의 this와 메서드의 this가 다르기 때문에 TypeError가 발생하는 것이다.

화살표 함수는 함수 자체의 this 바인딩을 갖지 않고 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다.

```js
// 화살표 함수는 상위 스코프의 this를 참조한다
() => this.x;

// 다음과 똑같이 작동한다
(function () { return this.x; }).bind(this);
```

프로퍼티에 할당한 화살표 함수도 스코프 체인 상에서 가장 가까운 상위 함수 중에서 화살표 함수가 아닌 함수의 this를 참조한다.

```js
// increase 프로퍼티에 할당한 화살표 함수의 this는 전역 객체를 가리킨다.
const counter = {
    num: 1,
    increase: () => ++this.num
};

console.log(counter.increase());	// NaN
```

화살표 함수는 자체 this 바인딩을 갖지 않기 때문에 Function.prototype.call, Function.prototype.apply, Function.prototype.bind 메서드를 사용해도 this를 교체할 수 없다.

메서드를 화살표 함수로 정의하는 것은 피해야 한다. 화살표 함수로 메서드를 정의하여 보자.

```js
const person = {
    name: 'Lee',
    sayHi: () => consolelog(`Hi! ${this.name}`)
};
```

화살표 함수 내부의 this는 person을 가리키지 않고 상위 스코프인 전역 객체를 가리킨다. 따라서 화살표 함수로 메서드를 정의하는 것은 바람직하지 않다.

클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다.

```js
class Person{
    constructor(){
        this.name = 'Lee';
        // this는 클래스가 생성할 인스턴스를 가리킨다.
        this.sayHi() = () => console.log(`Hi! ${this.name}`);
    }
}
```

클래스에서 this는 클래스가 생성할 인스턴스를 가리키기 때문에 메서드를 추가하기 위해서는 this를 붙여줘야 한다. 하지만 클래스 필드에 할당한 화살표 함수는 프로토타입 함수가 아닌 인스턴스가 되기 때문에 메서드를 정의할 때는 ES6 메서드 축약 표현으로 정의한 것을 사용하는 것이 좋다.



#### 26.3.4 super

화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super를 참조하면 마찬가지로 상위 스코프의 super를 참조한다.

```js
class Base{
    constructor(name){
        this.name = name;
    }
    
    sayHi(){
        return `Hi! ${this.name}`;
    }
}

class Derived extends Base{
    // 화살표 함수의 super는 상위 스코프인 constructor의 super를 가리킨다.
    sayHi = () => `${super.sayHi()} how are you doing?`;
}

const derived = new Derived('Lee');
console.log(derived.sayHi());	// Hi! Lee how are you doing?
```

super는 [[HomeObject]]를 갖는 메서드 내에서만 사용가능하지만 화살표 함수는 자체 super 바인딩을 갖지 않기 때문에 참조해도 에러가 발생하지 않게된다.



#### 26.3.5 arguments

화살표 함수는 함수 자체의 arguments를 갖지 않는다. 참조시 상위 스코프의 arguments를 참조한다.

```js
(function (){
    // foo 함수의 상위 스코프인 즉시 실행 함수의 arguments를 가리킨다.
    const foo = () => console.log(arguments);	// 1 2
    foo(3, 4);
}(1, 2));
```



### 26.4 Rest 파라미터

#### 26.4.1 기본 문법

Rest 파라미터는 매개변수 이름 앞에 세개의 점 ....을 붙여서 정의한 매개변수다. **Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.**

```js
function foo(...rest){
	console.log(rest)
}
foo(1, 2, 3, 4, 5);
```



일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이때 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다.

```js
function foo(param, ...rest){
    console.log(param);	// 1
    console.log(rest);	// [2, 3, 4, 5]
}

foo(1, 2, 3, 4, 5);
```



Rest 파라미터는 이름 그대로 먼저 선언된 매개변수에 할당된 인수를 제외한 나머지 인수들로 구성된 배열이 할당된다. 따라서 마지막 파라미터이어야 한다.

```js
function foo(...rest, param1, param2) {}

foo(1, 2, 3, 4, 5);
// SyntaxError
```



Rest 파라미터는 단 하나만 선언할 수 있다.

```js
function foo(...rest1, ...rest2) {}

foo(1, 2, 3, 4, 5);
// SyntaxError
```



Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.

```js
function foo(...rest){}
console.log(foo.length);	// 0

function foo(x, ...rest){}
console.log(foo.length);	// 1

function foo(x, y, ...rest){}
console.log(foo.length);	// 2
```



#### 26.4.2 Rest 파라미터와 argument 객체

ES5에서는 가변 인자 함수의 경우 arguments 객체를 활용하여 인수를 전달받았다.

```js
function sum(){
    console.log(arguments);
}

sum(1, 2);
```



하지만 arguments 객체는 배열이 아닌 유사 배열 객체이므로 배열 메서드를 사용하려면 Function.prototype.call 이나 apply 메서드를 통해 arguments 객체를 배열로 변환해야 하는 번거로움이 있었다.

```js
function sum(){
	var array = Array.prototype.slice.call(arguments);
    
    return array.reduce(function(pre, cur){
        return pre + cur;
    }, 0);
}

console.log(sum(1, 2, 3, 4, 5));	// 15
```



ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다.

```js
function sum(...args){
    return args.reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1, 2, 3, 4, 5));	// 15
```



### 26.5 매개변수 기본값

함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않는다. 인수가 전달되지 않았을 때 매개변수의 값은 undefined다. 이를 방치하면 의도치 않은 결과가 나오니 기본값을 할당할 필요가 있다.

```js
function sum(x, y){
    return x + y;
}

console.log(sum(1));	// NaN

// ES5
function sum(x, y){
    x = x || 0;
    y = y || 0;
    
    return x + y;
}

console.log(sum(1, 2));	// 3
console.log(sum(1));	// 1

// ES6에서 도입된 기본값을 사용하면 인수 체크 및 초기화를 간소화할 수 있다.
function sum(x = 0, y = 0){
    return x + y;
}

console.log(sum(1, 2));	// 3
console.log(sum(1));	// 1
```



매개변수 기본값은 매개변수에 인수를 전달하지 않은 경우와 undefined를 전달한 경우에만 유효하다.

```js
function logName(name = 'Lee'){
    console.log(name);
}

logName();	// Lee
logName(undefined);	// Lee
logName(null);	// null
```



Rest 파라미터에는 기본값을 지정할 수 없다.

```js
function foo(...rest = []){
    console.log(rest);
}
// SyntaxError
```

매개변수 기본값은 함수 객체의 length 프로퍼티와 arguments 객체에 아무런 영향을 주지 않는다.

------

## 27장 배열

### 27.1 배열이란?

배열은 여러 개의 값을 순차적으로 나열한 자료구조다. 사용 빈도가 매우 높은 가장 기본적인 자료구조다.

```js
const arr = ['apple', 'banana', 'orange'];
```

배열이 가지고 있는 값을 요소라고 부른다. 자바스크립트에서 값으로 인정하는 모든 것(객체, 함수, 배열 등)은 요소가 될 수 있다. 배열의 요소는 배열에서 자신의 위치를 나타내는 인덱스를 갖는다. 인덱스는 0부터 시작한다. 요소에 접근할 때는 대괄호 표기법을 사용한다.

```js
arr[0]	// 'apple'
arr[1]	// 'banana'
arr[2]	// 'orange'
```



배열은 길이를 나타내는 length 프로퍼티를 갖는다.

```js
arr.length	// 3
```



배열은 인덱스와 length 프로퍼티를 갖기 때문에 for문을 통해 순차적으로 요소에 접근할 수 있다.

```js
for(let i = 0; i < arr.length; i++){
    console.log(arr[i]);	// 'apple' 'banana' 'orange'
}
```



배열은 객체타입이다.

```js
typeof arr	// object
```



배열은 리터럴, Array 생성자 함수, Array.of, Array.from 메서드로 생성할 수 있다. 배열의 생성자 함수는 Array이며, 프로토타입 객체는 Array.prototype이다.

```js
const arr = [1, 2, 3];

arr.constructor === Array	// true
Object.getPrototypeOf(arr) === Array.prototype	// true
```



배열은 객체지만 일반 객체와는 구별되는 독특한 특징이 있다.

| 구분            | 객체             | 배열          |
| --------------- | ---------------- | ------------- |
| 구조            | 프로퍼티 키와 값 | 인덱스와 요소 |
| 값의 참조       | 프로퍼티 키      | 인덱스        |
| 값의 순서       | X                | O             |
| length 프로퍼티 | X                | O             |

일반 객체와 배열의 가장 명확한 차이는 값의 순서와 length 프로퍼티다. 이것으로 배열은 반복문을 통해 순차적으로 값에 접근하기 적합한 자료구조다.

배열의 장점은 처음부터 순차적으로 요소에 접근할 수도 있고, 역순으로 요소에 접근할 수도 있으며, 특정 위치부터 순차적으로 요소에 접근할 수도 있다는 것이다.



### 27.2 자바스크립트 배열은 배열이 아니다

자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 연속적으로 나열된 것을 말한다. 이러한 배열을 **밀집 배열**이라 한다. 이어져 있기 때문에 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있다. 이는 매우 효율적이며, 속도도 빠르다(시간 복잡도 O(1). 정렬되지 않은 배열의 경우는 처음부터 특정 요소를 발견할 때까지 검색(시간복잡도 O(n))해야 한다.

또한 배열에 요소를 삽입하거나 삭제해야 하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점도 있다.

자바스크립트의 배열은 각각의 메모리 공간이 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있는 **희소 배열**이다. 자바스크립트의 배열은 일반적인 의믜의 배열이 아닌 **배열의 동작을 흉내 낸 특수한 객체다.**

```js
console.log(Object.getOwnPropertyDescriptors([1, 2, 3]))
/*
{
	'0': {value: 1, writable: true, enumerable: true, configurable: true}
	'1': {value: 2, writable: true, enumerable: true, configurable: true}
	'2': {value: 3, writable: true, enumerable: true, configurable: true}
	length: {value: 3, writable: true, enumerable: false, configurable: false}
}
*/
```

보이는 것처럼 자바스크립트 배열은 인덱스를 프로퍼티 키로 가지며, length 프로퍼티를 가지는 특수한 객체다.

객체기 때문에 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.

```js
const arr = [
    'string',
    10,
    true,
    null,
    undefined,
    NaN,
    Infinity,
    [],
    {},
    function(){}
];
```

일반적인 배열과 자바스크립트 배열의 장단점을 정리해보면 다음과 같다.

- 일반적인 배열은 인덱스로 요소에 빠르게 접근할 수 있다. 하지만 특정 요소를 검색하거나 삽입, 삭제하는 경우에는 효율적이지 않다.
- 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 요소에 접근하는 경우 일반적인 배열보다 성능은 느릴수밖에 없는 구조적인 단점이 있다. 하지만 특정 요소를 검색하거나 삼입, 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.

인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적인 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화하여 구현했다.

```js
// 직접 해본결과 책을 쓴 시점보다 더 빨리 끝났다.
const arr = [];

console.time('Array Performance Test');

for(let i = 0; i < 10000000; i++){
    arr[i] = i;
}
console.timeEnd('Array Performance Test');
// 약 200ms

const obj = {};

console.time('Object Performance Test');

for(let i = 0; i < 10000000; i++){
    obj[i] = i;
}

console.timeEnd('Object Performance Test');
// 약 290ms
```



### 27.3 length 프로퍼티와 희소 배열

length 프로퍼티는 요소의 개수를 값으로 갖는다. 빈 배열일 경우 0이며, 아닐 경우 가장 큰 인덱스 + 1과 같다.

length 프로퍼티의 값은 0 ~ 2^32 - 1(4,294,967,296 - 1)미만의 양의 정수다.

length 프로퍼트이 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신된다.

```js
const arr = [1, 2, 3];
console.log(arr.length);	// 3

arr.push(4);
console.log(arr.length);	// 4

arr.pop();
console.log(arr.length);	// 3
```



length 프로퍼티 값은 배열의 길이를 바탕으로 결정되지만 임의의 숫자 값을 명시적으로 할당할 수도 있다.

```js
const arr = [1, 2, 3, 4, 5];

arr.length = 3;

console.log(arr);	// [1, 2, 3]
```



length 프로퍼티 값보다 큰 숫자 값을 할당하는 경우 length 프로퍼티 값은 변경되지만 실재 배열의 길이는 늘어나지 않는다.

```js
const arr = [1];

arr.length = 3;

console.log(arr.length);	// 3
console.log(arr);	// [ 1, <2 empty items> ]
```

<2 empty items>는 배열의 요소가 아니라 arr[1], arr[2]에 값이 존재하지 않는다는 얘기다. 비어있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.

```js
console.log(Object.getOwnPropertyDescriptors(arr));
/*
{
  '0': { value: 1, writable: true, enumerable: true, configurable: true },
  length: { value: 3, writable: true, enumerable: false, configurable: false }
}
*/
```



희소 배열은 요소가 연속적으로 위치하는 것처럼 보일 수 있으나 중간이나 앞부분이 비어 있을 수도 있다.

```js
const sparse = [, 2, , 4]

console.log(sparse.length); // 4
console.log(sparse);    // [ <1 empty item>, 2, <1 empty item>, 4 ]

// 인덱스가 0, 2인 요소가 존재하지 않는다.
console.log(Object.getOwnPropertyDescriptors(sparse))
/*
{
  '1': { value: 2, writable: true, enumerable: true, configurable: true },
  '3': { value: 4, writable: true, enumerable: true, configurable: true },
  length: { value: 4, writable: true, enumerable: false, configurable: false }
}
*/
```

일반적인 배열의 length는 요소의 개수와 일치하지만 희소배열은 개수가 일치하지 않는다. **희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.**

자바스크립트는 문법적으로 희소 배열을 허용하지만 사용하지 않는것이 좋다.



### 27.4 배열 생성

#### 27.4.1 배열 리터럴

0개 이상의 요소를 쉼표로 구분하여 대괄호로 묶는다.

```js
const arr = [1, 2, 3];
console.log(arr.length);	// 3
```



배열 리터럴에 요소를 하나도 추가하지 않으면 length 프로퍼티 값이 0인 빈 배열이 된다.

```js
const arr = [];
console.log(arr.length);	// 0
```



배열 리터럴에 요소를 생략하면 희소 배열이 생성된다.

```js
const arr = [1, , 3];

console.log(arr.length);	// 3
console.log(arr[1]);	// undefined
```

arr[1]이 undefined인 이유는 arr 배열(사실은 객체)에 프로퍼키가 1인 프로퍼티가 존재하지 않기 때문이다.



#### 27.4.2 Array 생성자 함수

Array 생성자 함수를 통해 배열을 생성할 수 있다.

- 전달된 인수가 1개이고 숫자인 경우 length 프로퍼티 값이 인수인 배열을 생성한다.

  ```js
  const arr = new Array(10);
  
  console.log(arr);	// [ <10 empty items> ]
  console.log(arr.length);	// 10
  ```

  이때 생성된 배열은 희소 배열이다.

  배열 요소의 최대 크기를 벗어나면 RangeError가 발생한다.

- 전달된 인수가 없는 경우 빈 배열을 생성한다.

  ```js
  new Array();	// []
  ```

- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.

  ```js
  new Array(1, 2, 3);	// [1, 2, 3]
  
  new Array({});	// [{}]
  ```

  Array 생성자 함수는 일반 함수로 호출해도 생성자 함수로 동작한다. 이는 Array 생성자 함수 내부에서 new.target을 확인하기 때문이다.

  ```js
  Array(1, 2, 3);	// [1, 2, 3]
  ```

  

#### 27.4.3 Array.of

ES6에서 도입된 Array.of 메서드는 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.

```js
Array.of(1);	// [1]

Array.of(1, 2, 3);	// [1, 2, 3]

Array.of('string');	// ['string']
```



#### 27.4.4 Array.from

ES6에서 도입된 Array.from 메서드는 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

```js
Array.from({length: 2, 0: 'a', 1: 'b'});	// ['a', 'b']

Array.from('Hello');	// ['H', 'e', 'l', 'l', 'o']
```

Array.from을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. 두 번째 인수로 전달한 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소 값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```js
// length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채운다.
Array.from({ length: 3 });	// [undefined, undefined, undefined]

// 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환한다.
Array.from({ length: 3}, (_, i) => i);	// [0, 1, 2]
```



### 27.5 배열 요소의 참조

배열의 요소를 참조할 떄에는 대괄호 표기법을 사용한다. 대괄호 안에는 인덱스가 와야 한다.

```js
const arr = [1, 2];

console.log(arr[0]);	// 1
console.log(arr[1]);	// 2
```



존재하지 않는 요소에 접근하면 undefined가 반환된다.

```js
const arr = [1, 2];

console.log(arr[2]);	// undefined
```

배열은 객체이기 때문에 객체에서 없는 프로퍼티에 접근했을 때 처럼 undefined를 반환한다.



### 27.6 배열 요소의 추가와 갱신

객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다.

```js
const arr = [0];

arr[1] = 1;

console.log(arr);	// [0, 1]
console.log(arr.length);	// 2
```

만약 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.



인덱스는 요소의 위치를 나타내므로 반드시 0 이상의 정수를 사용해야 한다. 만약 이외의 값을 사용하면 프로퍼티가 생성된다. 이때 추가된 프로퍼티는 length에 영향을 미치지 않는다.

```js
const arr = [];

arr[0] = 1;
arr['1'] = 2;

arr['foo'] = 3;
arr.bar = 4;
arr[1.1] = 5;
arr[-1] = 6;

console.log(arr);	// [ 1, 2, foo: 3, bar: 4, '1.1': 5, '-1': 6 ]

console.log(arr.length);	// 2
```



### 27.7 배열 요소의 삭제

배열은 객체이기 때문에 delete 연산자를 이용해 특정 요소를 삭제할 수 있다.

```js
const arr = [1, 2, 3];

delete arr[1];
console.log(arr);	// [1, <1 empty item>, 3]

console.log(arr.length);	// 3
```

delete 연산자는 희소 배열을 만들기 때문에 사용하지 않는 것이 좋다.



희소 배열을 만들지 않으면서 특정 요소를 삭제하려면 Array.prototype.splice 메서드를 사용한다.

```js
const arr = [1, 2, 3];

arr.splice(1, 1);
console.log(arr);	// [1, 3]

console.log(arr.length);	// 2
```



### 27.8 배열 메서드

배열 메서드는 반환 패턴이 두 가지이므로 주의가 필요하다. **원본 배열을 직접 변경하는 메서드와 원본 배열을 변경하지 않고 새로운 배열을 반환하는 메서드가 있다.**

#### 27.8.1 Array.isArray

Array 생성자 함수의 정적 메서드다. 전달된 인수가 배열이면 true, 배열이 아니면 false를 반환한다.

```js
// true
Array.isArray([]);
Array.isArray(new Array());

// false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(1);
Array.isArray(true);
```



#### 27.8.2 Array.prototype.indexOf

indexOf 메서드는 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.

- 전달된 요소와 중복되는 요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.
- 전달한 요소가 존재하지 않으면 -1을 반환한다.

```js
const arr = [1, 2, 2, 3];

arr.indexOf(2);	// 1
arr.indexOf(4);	// -1
// 두 번째 인수는 검색을 시작한 인덱스다. 생략하면 처음부터 검색한다.
arr.indexOf(2, 2);	// 2
```

배열에 특정 요소가 존재하는지 확인할 때 유용하다. 하지만 ES7에서 도입된 ARray.prototype.includes 메서드를 사용하면 가독성이 더 좋다.

```js
const foods = ['apple', 'banana', 'orange'];

if(foods.indexOf('orange') === -1){
    foods.push('orange');
}

// 가독성이 더 좋다!
if(!foods.includes('orange')){
    foods.push('orange');
}
```



#### 27.8.3 Array.prototype.push

인수로 전달받은 모든 값을 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. push 메서드는 원본 배열을 직접 변경한다.

```js
const arr = [1, 2];

let result = arr.push(3, 4);

console.log(result);	// 4
console.log(arr);	// [1, 2, 3, 4]
```

push 메서드는 성능 면에서 좋지 않다. 마지막 요소로 추가할 요소가 하나뿐이라면 length 프로퍼티를 이용해 마지막에 요소를 직접 추가할 수도 있다. 이 방법이 push 메서드보다 빠르다.

```js
cosnt arr = [1, 2];

arr[arr.length] = 3;
console.log(arr);	// [1, 2, 3]
```

push 메서드는 원본 배열을 변경하는 부수 효과가 있다. 따라서 스프레드 문법을 사용하는 편이 좋다. 그러면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과도 없다.

```js
const arr = [1, 2];
const newArr = [...arr, 3];

console.log(newArr);	// [1, 2, 3]
```



#### 27.8.4 Array.prototype.pop

pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 빈 배열이라면 undefined를 반환한다. push 메서드와 마찬가지로 원본 배열을 변경한다.

```js
const arr = [1, 2];

let result = arr.pop();
console.log(result);	// 2

console.log(arr);	// [1]
```



push, pop 메서드로 스택을 쉽게 구현할 수 있다.

```js
const Stack = (function(){
    function Stack(array = []){
        if(!Array.isArray(array)){
            throw new TypeError(`${array} is not an array`);
        }
        this.array = array;
    }
    
    Stack.prototype = {
        constructor: Stack,
        push(value){
            return this.array.push(value);
        },
        pop(){
            return this.array.pop();
        },
        entries(){
            return [...this.array];
        }
    };
    
    return Stack;
}());

const stack = new Stack([1, 2]);
console.log(stack.entries());	// [1, 2]

stack.push(3);
console.log(stack.entries());	// [1, 2, 3]

stack.pop();
console.log(stack.entries());	// [1, 2]
```



스택을 클래스로 구현하면 다음과 같다.

```js
class Stack{
    #array;
    
    constructor(array = []){
        if(!Array.isArray(array)){
            throw new TypeError(`${array} is not an array.`);
        }
        this.#array = array;
    }
    
    push(value){
        return this.#array.push(value);
    }
    
    pop(){
        return this.#array.pop();
    }
    
    entries(){
        return [...this.#array];
    }
}

const stack = new Stack([1, 2]);
console.log(stack.entries());	// [1, 2]

stack.push(3);
console.log(stack.entries());	// [1, 2, 3]

stack.pop();
console.log(stack.entries());	// [1, 2]
```



#### 27.8.5 Array.prototype.unshift

unshift 메서드는 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. 원본 배열을 직접 변경한다.

```js
const arr = [1, 2];

let result = arr.unshift(3, 4);
console.log(result);	// 4

console.log(arr);	// [3, 4, 1, 2]
```



unshift 메서드는 원본 배열을 변경하는 부수효과가 있으니 스프레드 문법을 사용하는 편이 좋다.

```js
const arr = [1, 2];

const newArr = [3, ...arr];
console.log(newArr);	// [3, 1, 2]
```



#### 27.8.6 Array.prototype.shift

shift 메서드는 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 빈 배열이면 undefined를 반환하고 원본 배열을 직접 변경한다.

```js
const arr = [1, 2];

let result = arr.shift();
console.log(result);	// 1

console.log(arr);	// [2]
```



shift, push 메서드를 사용하면 큐를 쉽게 구현할 수 있다.

```js
const Queue = (function (){
    function Queue(array = []){
        if(!Array.isArray(array)){
            throw new TypeError(`${array} is not an array.`);
        }
        this.array = array;
    }
    
    Queue.prototype = {
        constructor: Queue,
        enqueue(value){
            return this.array.push(value);
        },
        dequeue(){
            return this.array.shift();
        },
        entries(){
            return [...this.array];
        }
    };
    
    return Queue;
}());

const queue = new Queue([1, 2]);
console.log(queue.entries());	// [1, 2]

queue.enqueue(3);
console.log(queue.entries());	// [1, 2, 3]

queue.dequeue();
console.log(queue.entries());	// [2, 3]
```



클래스로 표현하면 다음과 같다.

```js
class Queue{
    #array;
    
    constructor(array = []){
        if(!Array.isArray(array)){
            throw new TypeError(`#{array} is not an array.`);
        }
        this.#array = array;
    }
    
    enqueue(value){
        return this.#array.push(value);
    }
    
    dequeue(){
        return this.#array.shift();
    }
    
    entreis(){
        return [...this.#array];
    }
}

const queue = new Queue([1, 2]);
console.log(queue.entries());	// [1, 2]

queue.enqueue(3);
console.log(queue.entries());	// [1, 2, 3]

queue.dequeue();
console.log(queue.entries());	// [2, 3]
```



#### 27.8.7 Array.prototype.concat

concat 메서드는 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 원본 배열은 변경되지 않는다.

```js
const arr1 = [1, 2];
const arr2 = [3, 4];

let result = arr1.concat(arr2);
console.log(result);	// [1, 2, 3, 4]

result = arr1.concat(3);
console.log(result);	// [1, 2, 3]

result = arr1.concat(arr2, 5);
console.log(result);	// [1 ,2 ,3 ,4 ,5]

console.log(arr1);	// [1, 2]
```

push와 unshift 메서드는 concat 메서드로 대체할 수 있다. push와 unshift는 concat 메서드와 유사하게 동작하지만 원본 배열을 변경하느냐의 차이점이 있다.



#### 27.8.8 Array.prototype.splice

원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우 splice 메서드를 사용한다. 3개의 매개변수가 있으며 원본 배열을 직접 변경한다.

- start : 원본 배열의 요소를 제거하기 시작할 인덱스, start만 지정하면 start부터 모든 요소를 제거한다. 음수일 경우 배열의 끝에서의 인덱스를 나타낸다.
- deleteCount : start부터 제거할 요소의 개수이다. 0일 경우 아무론 요소도 제거되지 않는다(옵션).
- items : 제거한 위치에 삽입할 요소들의 목록이다. 생략할 경우 제거하기만 한다.

```js
let arr = [1, 2, 3, 4];
let result = arr.splice(1, 2, 20, 30);

console.log(result);	// [2, 3]
console.log(arr);		// [1, 20, 30, 4]

// deleteCount가 0이면 추가만 한다.
arr = [1, 2, 3, 4];
result = arr.splice(1, 0, 100);

console.log(arr);		// [1, 100, 2, 3, 4]
console.log(result);	// []

// items가 없다면 제거만 한다.
arr = [1, 2, 3, 4];
result = arr.splice(1, 2);

console.log(arr);		// [1, 4]
console.log(result);	// [2, 3]

// deleteCount를 생략하면 start부터 모든 인수를 제거한다.
arr = [1, 2, 3, 4];
result = arr.splice(1);

console.log(arr);		// [1]
console.log(result);	// [2, 3, 4]
```



배열에서 특정 요소를 제거하려면 indexOf 메서드를 같이 사용하면 된다.

```js
const arr = [1, 2, 3, 1, 2];

function remove(array, item){
    const index = array.indexOf(item);
    
    if(index !== -1) array.splice(index, 1);
    
    return array;
}

console.log(remove(arr, 2));	// [1, 3, 1, 2]
console.log(remove(arr, 10));	// [1, 3, 1, 2]
```



#### 27.8.9 Array.prototype.slice

slice 메서드는 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 원본 배열은 변경되지 않는다. 두 개의 매개변수를 갖는다.

- start : 복사를 시작할 인덱스다. 음수인 경우 배열의 끝에서의 인덱스를 나타낸다.
- end : 복사를 종료할 인덱스다. 인덱스에 해당하는 요소는 복사되지 않는다(2 일경우 인덱스 1까지만). 생략될 경우 기본적으로 length 프로퍼티 값이다.

```js
const arr = [1, 2, 3];

arr.slice(0, 1);	// [1]
arr.slice(1, 2);	// [2]
arr.slice(1);		// [2, 3]
// 음수는 끝에서부터 n번째를 나타낸다
arr.slice(-1);		// [3]
arr.slice(-2);		// [2, 3]
// 인수를 모두 생략하면 전체를 복사한다
const copy = arr.slice();	// [1, 2, 3]

// 이때 복사는 얕은 복사다
console.log(copy === arr);	// false
console.log(arr);	// [1, 2, 3]
```



#### 27.8.10 Array.prototype.join

join 메서드는 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열로 연결한 문자열을 반환한다. 구분자는 생략 가능하며 기본 구분자는 콤마다.

```js
const arr = [1, 2, 3, 4];

arr.join();		// '1,2,3,4'
arr.join('');	// '1234'
arr.join(':');	// '1:2:3:4'
```





#### 27.8.11 Array.prototype.reverse

reverse 메서드는 원본 배열의 순서를 반대로 뒤집는다. 이때 원본 배열이 변경된다. 반환값은 변경된 배열이다.

```js
const arr = [1, 2, 3];
const result = arr.reverse();

console.log(arr);	// [3, 2, 1]
console.log(result);	// [3, 2, 1]
```



#### 27.8.12 Array.prototype.fill

fill 메서드는 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 이때 원본 배열이 변경된다.

```js
const arr = [1, 2, 3];

arr.fill(0);

console.log(arr);	// [0, 0, 0]
```



두 번째 인수로 요소 채우기를 시작할 인덱스를 전달할 수 있다.

```js
const arr = [1, 2, 3];

arr.fill(0, 1);

console.log(arr);	// [1, 0, 0]
```



세 번째 인수로 요소 채우기를 멈출 인덱스를 전달할 수 있다.

```js
const arr = [1, 2, 3, 4, 5];

arr.fill(0, 1, 3);

console.log(arr);	// [1, 0, 0, 4, 5]
```



fill 메서드로 요소를 채울 경우 모든 요소를 하나로만 채울 수 밖에 없다. 하지만 Array.from 메서드를 사용하면 콜백 함수를 통해 요소 값을 만들면서 배열을 채울 수 있다.

```js
const sequences = (length = 0) => Array.from({ length }, (_,i) => i);

console.log(sequences(3));	// [0, 1, 2]
```



#### 27.8.13 Array.prototype.includes

배열 내에 특정 요소가 포함되어 있는지 확인하여 true 또는 false를 반환한다. 첫 번째 인수로 검색할 대상을 지정한다.

```js
const arr = [1, 2, 3];

arr.includes(2);	// true
arr.includes(100);	// false
```



두 번째 인수로 검색을 시작할 인덱스를 설정할 수 있다. 생략할 경우 기본값은 0이다. 음수일 경우 마지막에서 n번째로 계산한다.

```js
const arr = [1, 2, 3];

arr.includes(1, 1);		// false
arr.includes(3, -1);	// true
```



#### 27.8.14 Array.prototype.falt

ES10에서 도입된 flat 메서드는 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.

```js
[1, [2, 3, 4, 5]].flat();	// [1, 2, 3, 4, 5]
```



중첩 배열을 평탄화할 깊이를 인수로 전달할 수 있다. 인수를 생략할 경우 기본값은 1이다. 인수로 Infinity를 전달하면 중첩 배열 모두를 평탄화한다.

```js
[1, [2, [3, [4]]]].flat();	// [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(1);	// [1, 2, [3, [4]]]
[1, [2, [3, [4]]]].flat(2);	// [1, 2, 3, [4]]
[1, [2, [3, [4]]]].flat().flat()	// [1, 2, 3, [4]]
[1, [2, [3, [4]]]].flat(Infinity);	// [1, 2, 3, 4]
```



### 27.9 배열 고차 함수

고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다. 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

#### 27.9.1 Array.prototype.sort

sort 메서드는 배열의 요소를 정렬한다. 원본 배열을 직접 변경하며 정렬된 배열을 반환한다. 기본으로 오름차순으로 요소를 정렬한다.

```js
const fruits = ['Banana', 'Orange', 'Apple'];

fruits.sort();

console.log(fruits);	// ['Apple', 'Banana', 'Orange']
```

한글 문자열도 가능하다. 또한 내림차순으로 정렬하고 싶다면 sort 후 reverse 메서드를 사용하면 된다.



숫자 요소로 이루어진 배열을 정렬할 때는 주의가 필요하다.

```js
const points = [40, 100, 1, 5, 2, 25, 10];

points.sort();

console.log(points);	// [1, 10, 100, 2, 25, 40, 5]
```

sort 메서드의 기본 정렬 순서는 유니코드 코드 포인트의 순서를 따른다. 요소가 숫자이더라도 문자열로 변환 후 순서를 매기기 때문에 '2' 보다 '10'이 앞서게 되는 것이다. 따라서 숫자 요소를 정렬할 때는 sort 메서드에 **정렬 순서를 정의하는 비교 함수를 인수로 전달**해야한다.

비교 함수는 양수나 음수 또는 0을 반환해야 한다. 비교 함수의 반환값이 0보다 작으면 첫 번째 인수를 우선하여 정렬하고, 0이면 정렬하지 않으며, 0보다 크면 두 번째 인수를 우선하여 정렬한다.

```js
const points = [40, 100, 1, 5, 2, 25, 10];

// 오름차순 정렬
points.sort((a, b) => a - b);
console.log(points);	// [1, 2, 5, 10, 25, 40, 100]

// 내림차순 정렬
points.sort((a, b) => b - a);
console.log(points);	// [100, 40, 25, 10, 5, 2, 1]
```



객체를 요소로 갖는 배열을 정렬하는 예제는 다음과 같다.

```js
const todos = [
	{ id: 4, content: 'JavaScript' },
    { id: 1, content: 'HTML' },
    { id: 2, content: 'CSS' },
];

function compare(key){
    return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0))
}

todos.sort(compare('id'));
console.log(todos);
/*
[
  { id: 1, content: 'HTML' },
  { id: 2, content: 'CSS' },
  { id: 4, content: 'JavaScript' }
]
*/

todos.sort(compare('content'));
console.log(todos);
/*
[
  { id: 2, content: 'CSS' },
  { id: 1, content: 'HTML' },
  { id: 4, content: 'JavaScript' }
]
*/
```



#### 27.9.2 Array.prototype.forEach

함수형 프로그래밍은 조건문과 반복문을 제거하고 변수의 사용을 억제해야 한다. 하지만 for 문은 함수형 프로그래밍이 추구하는 바와 맞지 않는다.

```js
const numbers = [1, 2, 3];
const pows = [];

for(let i = 0; i < numbers.length; i++){
    pows.push(numbers[i] ** 2);
}
console.log(pows);	// [1, 4, 9]
```



forEach 메서드는 for 문을 대체할 수 있는 고차 함수다. forEach 메서드는 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출한다.

```js
const numbers = [1, 2, 3];
const pows = [];

numbers.forEach(item => pows.push(item ** 2));
console.log(pows);	// [1, 4, 9]
```



forEach 메서드의 콜백 함수는 forEach 메서드를 호출한 배열의 요소값과 인덱스, forEach 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받을 수 있다.

```js
[1, 2, 3].forEach((item, index, arr) =>{
    console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

forEach 메서드는 원본 배열을 변경하지 않지만, 콜백 함수를 통해 원본 배열을 변경할 수는 있다.



forEach 메서드의 반환값은 언제나 undefined다.

```js
const result = [1, 2, 3].forEach(console.log);
console.log(result);	// undefined
```



forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.

```js
class Numbers{
    numberArray = [];
    
    multiply(arr){
        arr.forEach(function (item){
            // TypeError : Cannot read property 'numberArray' of undefined
            this.numberArray.push(item * item);
        });
    }
}

const numbers = new Numbers();
numbers.multiply([1, 2, 3]);
```

forEach메서드의 콜백 함수는 일반 함수로 호출되므로 콜백 함수 내부의 this는 undefined를 가리킨다. this가 전역 객체가 아닌 undefined를 가리키는 이유는 클래스 내부의 모든 코드에는 암묵적으로 strict mode가 적용되기 때문이다.

forEach 메서드의 콜백 함수 내부의 this와 multiply 메서드 내부의 this를 일치시키려면 forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달한다.

```js
class Numbers{
    numberArray = [];
    
    multiply(arr){
        arr.forEach(function (item){
            // TypeError : Cannot read property 'numberArray' of undefined
            this.numberArray.push(item * item);
        }, this);	// forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달
    }
}

const numbers = new Numbers();
numbers.multiply([1, 2, 3]);
```



더 나은 방법은 ES6의 화살표 함수는 사용하는 것이다. 화살표 함수는 자체 this 바인딩이 없기 때문에 상위 스코프의 this를 참조하기 때문이다.

```js
class Numbers {
    numberArray = [];
    
    multiply(arr){
        arr.forEach(item => this.numberArray.push(item * item));
    }
}

const numbers = new Numbers();
numbers.multiply([1, 2, 3]);
console.log(numbers.numberArray);	[1, 4, 9]
```



forEach를 이해하기 위해 forEach 메서드의 폴리필을 살펴보자.

```js
// 만약 Array.prototype에 forEach 메서득 ㅏ존재하지 않으면 폴리필을 추가한다.
if (!Array.prototype.forEach){
    Array.prototype.forEach = function (callback, thisArg){
        // 첫 번쨰 인수가 함수가 아니면 TypeError를 발생시킨다.
        if(type callback !== 'function'){
            throw new TypeError(callback + ' is not a function');
        }
        
        // this로 사용할 두 번째 인수를 전달받지 못하면 전역 객체를 this로 사용한다.
        thisArg = thisArg || window;
        
        // for 문으로 배열을 순회하면서 콜백 함수를 호출한다.
        for(var i = 0; i < this.length; i++){
            // call 메서드를 통해 thisArg를 전달하면서 콜백 함수를 호출한다.
            // 이때 콜백 함수의 인수로 배열 요소, 인덱스, 배열 자신을 전달한다.
            callback.call(thisArg, this[i], i, this);
        }
    };
}
```

이처럼 forEach 메서드도 내부에서는 반복문을 통해 배열을 순회할 수 없지만, 반복문을 메서드 내부로 은닉하여 로직의 흐름을 이해하기 쉽게 바꿨다.

forEach 메서드는 for 문과는 달리 break, continue 문을 사용할 수 없다.

희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.



#### 27.9.3 Array.prototype.map

map 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.

```js
const numbers = [1, 4, 9];

const roots = numbers.map(item => Math.sqrt(item));
```

forEach와 map의 차이점은 forEach는 반환값이 undefined라는 것이고 map은 배열이라는 것이다.



map 메서드는 콜백 함수를 호출할 때 3개의 인수 배열의 요소값, 인덱스, 메서드를 호출한 배열(this)를 순차적으로 전달한다.

```js
[1, 2, 3].map((item, index, arr) =>{
    console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
    return item;
});
/*
요소값: 1, 인덱스: 0, this: [1,2,3]
요소값: 2, 인덱스: 1, this: [1,2,3]
요소값: 3, 인덱스: 2, this: [1,2,3]
*/
```

forEach 메서드와 마찬가지로 두 번째 인수로  map 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다. 또한 화살표 함수를 선택하는 것이 더 나은 방법이다.



#### 27.9.4 Array.prototype.filter

filter 메서드는 자신이 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 **콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.** 원본 배열은 변경되지 않는다.

```js
const numbers = [1, 2, 3, 4, 5];

const odds = numbers.filter(item => item % 2);
console.log(odds);	// [1, 3, 5]
```



filter 메서드는 자신이 호출한 배열에서 조건을 만족하는 특정 요소만 추출하여 새로운 배열을 만들고 싶을 때 사용한다. filter 또한 3개의 인수를 가진다(이전 메서드들과 동일하다).

```js
[1, 2, 3].filter((item, index, arr) =>{
    console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
    return item % 2;
});
/*
요소값: 1, 인덱스 0, this: [1, 2, 3]
요소값: 2, 인덱스 1, this: [1, 2, 3]
요소값: 3, 인덱스 2, this: [1, 2, 3]
*/
```

forEach, map 메서드와 마찬가지로 filter 메서드의 두 번째 인수로 filter 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다. 똑같이 더 나은 방법은 화살표 함수를 사용하면 된다.



#### 27.9.5 Array.prototype.reduce

reduce 메서드는 자신이 호출한 배열을 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값을 다음 순회 시 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 **하나의 결과값을 만들어 반환한다.** 원본 배열은 변경되지 않는다.

첫 번째 인수로 콜백 함수, 두 번째 인수로 초기값을 전달받는다. reduce 메서드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, reduce 메서드를 호출한 배열의 요소값과 인덱스, this가 전달된다.

```js
const sum = [1, 2, 3, 4].reduce((accumulator, currentValue, index, array) => accumulator + currentValue, 0);

console.log(sum);	// 10
```



reduce 메서드는 다음과 같이 활용할 수 있다.

**평균 구하기**

```js
const values = [1, 2, 3, 4, 5, 6];

const average = values.reduce((acc, cur, i, {length}) =>{
    return i === length - 1 ? (acc + cur) / length : acc + cur;
}, 0);

console.log(average);	// 3.5
```



**최대값 구하기**

```js
const values = [1, 2, 3, 4, 5];

const max = values.reduce((acc, cur) => (acc > cur ? acc : cur), 0);
console.log(max);
```

최대값을 구할 때는 Math.max 메서드를 사용하는 것이 더 직관적이다.



**요소의 중복 횟수 구하기**

```js
const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];

const count = fruits.reduce((acc, cur) =>{
    // 첫 순회시 초기값이 빈 객체이고 cur은 첫 번째 요소인 'banana'다.
    // 초기값으로 전달받은 빈 객체에 요소값이 cur을 프로퍼티 키로, 요소의 개수를 프로퍼티 값으로 할당한다.
    // 프로퍼티 값이 undefined라면 프로퍼티 값으 1로 초기화한다.
    acc[cur] = (acc[cur] || 0) + 1;
    return acc;
}, {});

console.log(count);	// { banana: 1, apple: 2, orange: 2 }
```



**중첩 배열 평탄화**

```js
const values = [1, [2, 3], 4, [5, 6]];

const flatten = values.reduce((acc,cur) => acc.concat(cur), []);

console.log(flatten);	// [1, 2, 3, 4, 5, 6]
```

중첩 배열을 평탄화 할때는 flat 메서드를 사용하는 방법이 더 직관적이다.



**중복 요소 제거**

```js
const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];

const result = values.reduce((unique, val, i, _values) =>
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 같다면 val은 처음 순회하는 요소다.
    // 현재 순회 중인 요소의 인덱스 i가 val의 인덱스와 다르다면 val은 중복된 요소다.
    // 처음 순회하는 요소만 초기값 []가 전달된 unique 배열에 담아 반환하면 중복된 요소는 제거된다.
    _values.indexOf(val) === i ? [...unique, val] : unique, []
);

console.log(result);
```

중복 요소 제거는 filter 메서드를 사용하는 방법이 더 직관적이다. 또한 유일값들의 집합인 Set을 사용할 수도 있다.

```js
const values = [1, 2, 1, 3, 5, 4, 5, 3, 4, 4];

const result = [...new Set(values)];
console.log(result);
```



두 번째 인수로 전달하는 초기값은 옵션이다. 즉, 생략할 수 있다.

```js
const sum = [1, 2, 3, 4].reduce((acc, cur) => acc + cur);
console.log(sum);	// 10
```

다만 빈 배열에 reduce를 사용할 때는 초기값을 주지 않으면 에러가 발생한다. 또한 객체의 특정 프로퍼티 값을 합산하는 경우에는 반드시 초기값을 전달해야 한다.

```js
const products = [
    { id: 1, price: 100 },
    { id: 2, price: 200 },
    { id: 3, price: 300 },
];

const priceSum = products.reduce((acc, cur) => acc + cur.price, 0);

console.log(priceSum);	// 600
```

reduce 메서드를 호출할 때는 초기값을 생략하지 말고 언제나 전달하는 것이 안전하다.



#### 27.9.6 Array.prototype.some

some 메서드는 자신이 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. 콜백 함수의 반환값이 단 한 번이라도 참이면 true, 모두 거짓이면 false를 반환한다. 즉, 배열의 요소 중에 콜백 함수의 조건을 만족하는 요소가 1개 이상 존재하는지 확인하여 그 결과를 불리언 타입으로 반환한다. 단, 빈 배열의 경우 항상 false를 반환한다.

forEach, map, filter 메서드와 마찬가지로 콜백 함수는 요소값과 인덱스, this를 순차적으로 전달받을 수 있다.

```js
[5, 10, 15].some(item => item > 10);	// true

[5, 10, 15].some(item => item < 0);		// false

['apple', 'banana', 'mango'].some(item => item === 'banana');	// true

[].some(item => item > 3);	// false
```



#### 27.9.7 Array.prototype.every

every 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. 이때 반환값이 모두 참이면 true, 하나라도 거짓이면 false를 반환한다. some 메서드와 true, false 조건만 다르다고 볼 수 있다. 빈 배열의 경우 항상 true를 반환한다.

forEach, map, filter 메서드와 마찬가지로 콜백 함수는 요소값과 인덱스, this를 순차적으로 전달받을 수 있다.

```js
[5, 10, 15].every(item => item > 3);	// true

[5, 10, 15].every(item => item > 10);	// false

[].every(item => item > 3);	// true
```



#### 27.9.8 Array.prototype.find

find 메서드는 요소를 순회하면서 인수로 전달된 콜백 함수의 반환값이 true인 첫 번째 요소를 반환한다. 콜백 함수의 반환값이 true인 요소가 존재하지 않는다면 undefined를 반환한다.

forEach, map, filter 메서드와 마찬가지로 콜백 함수는 요소값과 인덱스, this를 순차적으로 전달받을 수 있다.

```js
const user = [
    { id: 1, name: 'Lee' },
    { id: 2, name: 'Kim' },
    { id: 3, name: 'Choi' },
    { id: 4, name: 'Park' },
];

users.find(user => user.id === 2);	// {id: 2, name: 'Kim'}
```

filter 메서드는 호출 결과가 true인 요소만 추출한 배열을 반환하지만 find 메서드는 결과가 true인 첫 번째 요소를 반환한다는 것이 다르다.



#### 27.9.9 Array.prototype.findIndex

findIndex 메서드는 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 true인 첫 번쨰 요소의 인덱스를 반환한다. 요소가 존재하지 않는다면 -1을 반환한다.

forEach, map, filter 메서드와 마찬가지로 콜백 함수는 요소값과 인덱스, this를 순차적으로 전달받을 수 있다.

```js
const user = [
    { id: 1, name: 'Lee' },
    { id: 2, name: 'Kim' },
    { id: 3, name: 'Choi' },
    { id: 4, name: 'Park' },
];

users.findIndex(user => user.id === 2);			// 1
users.findIndex(user => user.name === 'Park');	// 3

// 위와 같이 프로퍼티 키와 값으로 요소의 인덱스를 구하는 경우 다음과 같이 콜백 함수를 추상화할 수 있다.
function predicate(key, value){
    return item => item[key] === value;
}

users.findIndex(predicate('id', 2));		// 1
users.findIndex(predicate('name', 'Park'));	// 3
```



#### 27.9.10 Array.prototype.flatMap

ES10에서 도입된 flatMap 메서드는 map 메서드를 통해 생성된 새로운 배열을 평탄화한다. 즉, map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다.

```js
const arr = ['hello', 'world'];

arr.map(x => x.split('')).flat();
// ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']

arr.flatMap(x => x.split(''));
// ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']
```

단, flatMap 메서드는 flat 메서드처럼 평탄화 깊이를 지정할 수 없고 1단계만 평탄화한다.



## 28장 Number

### 28.1 Number 생성자 함수

표준 빌트인 객체인 Number 객체는 생성자 함수 객체다. 따라서 new 연산자와 함꼐 호출하여 Number 인스턴스를 생성할 수 있다.

Number 생성자 함수에 인수를 전달하지 않고 new 연산자와 호출하면 [[NumberData]] 내부 슬롯에 0을 할당한 Number 래퍼 객체를 생성한다.

```js
const numObj = new Number();
console.log(numObj);
```

![image-20220310151846639](C:\Users\Sanghyun\AppData\Roaming\Typora\typora-user-images\image-20220310151846639.png)

브라우저 개발자 도구에서 실행해보면 [[PrimitiveValue]]라는 접근할 수 없는 프로퍼티가 있는데 이는 [[NumberData]] 내부 슬롯을 가리킨다. ES5에서는 [[NumberData]]를 [[PrimitiveValue]]라 불렀다.

Number 생성자 함수의 인수로 숫자를 전달하면 전달받은 숫자를 할당한 Number 래퍼 객체를 생성한다. 숫자가 아닌 값을 전달하면 인수를 숫자로 강제 변환 후 Number 래퍼 객체를 생성한다. 인수를 숫자로 변환할 수 없다면 NaN을 할당한 Number 래퍼 객체를 생성한다.

```js
let numObj = new Number('10');
console.log(numObj);	// [[PrimitiveValue]]: 10

numObj = new Number('Hello');
console.log(numObj);	// [[PrimitiveValue]]: NaN
```



이전에도 살펴보았듯이 new 연산자 없이 Number 생성자 함수를 호출하면 숫자를 반환한다.

```js
Number('0');	// 0
```



### 28.2 Number 프로퍼티

#### 28.2.1 Number.EPSILON

Number.EPSILON은 1과 1부다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다. 약 2.2204460492503130808472633361816 * 10^-16 이다.

부동소수점 산술 연산은 정확한 결과를 기대하기 어렵다. 정수는 2진법으로 오차없이 저장 가능하지만 부동소수점은 무한소수가 되어 미세한 오차가 발생할 수 밖에 없는 구조적 한계가 있다.

```js
0.1 + 0.2;	// 0.3000000000000004
0.1 + 0.2 === 0.3;	// false
```

Number.EPSILON은 이 오차를 해결하기 위해 사용한다.

```js
function isEqual(a, b){
    // a - b의 절대값이 EPSILON보다 작으면 같은 수로 인정한다.
    return Math.abs(a - b) < Number.EPSILON;
}

isEqual(0.1 + 0.2, 0.3);	// true
```



#### 28.2.2 Number.MAX_VALUE

자바스크립트에서 표현할 수 있는 가장 큰 양수 값(1.7976931348623157 * 10^308)이다. MAX_VALUE 보다 큰 숫자는 Infinity다.

```js
Number.MAX_VALUE;
Infinity > Number.MAX_VALUE;	// true
```



#### 28.2.3 Number.MIN_VALUE

자바스크립트에서 표현할 수 있는 가장 작은 양수 값(5 * 10^-324)이다. MIN_VALUE 보다 작은 숫자는 0이다.

```js
Number.MIN_VALUE;
Number.MIN_VALUE > 0;	// true
```



#### 28.2.4 Number.MAX_SAFE_INTEGER

자바스크립트에서 안전하게 표현할 수 있는 가장 큰 정수값(9007199254740991)이다.

```js
Number.MAX_SAFE_INTEGER;
```



#### 28.2.5 Number.MIN_SAFE_INTEGER

자바스크립트에서 안전하게 표현할 수 있는 가장 작은 정수값(-9007199254740991)이다.

```js
Number.MIN_SAFE_INTEGER;
```



#### 28.2.6 Number.POSITIVE_INFINITY

양의 무한대를 나타내는 숫자값 Infinity와 같다.

```js
Number.POSITIVE_INFINITY;
```



#### 28.2.7 Number.NEGATIVE_INFINITY

음의 무한대를 나타내는 숫자값 -Infinity와 같다

```js
Number.NEGATIVE_INFINITY;
```



#### 28.2.8 Nuber.NaN

숫자가 아님을 나타내는 숫자값이다. Number.NaN은 window.NaN과 같다.

```js
Number.NaN;
```



### 28.3 Number 메서드

#### 28.3.1 number.isFinite

정적 메서드로 인수로 전달된 숫자값이 유한수인지 아닌지를 검사하여 불리언 값으로 반환한다.

```js
// 정상적인 유한수이면 true를 반환한다
Number.isFinite(0);
Number.isFinite(Number.MAX_VALUE);
Number.isFinite(Number.MIN_VALUE);

// 무한수이면 false를 반환한다
Number.isFinite(Infinity);
Number.isFinite(-Infinity);

// NaN은 언제나 false이다
Number.inFinite(NaN);

// 인수가 숫자가 아니어도 false다
Number.inFinite(null);
```

Number.isFinite와 빌트인 전역함수 isFinite는 차이점이 있다. Number는 인수가 숫자가 아니면 암묵적으로 형변환을 하지 않지만 전역함수 isFinite는 암묵적으로 형변환을 한다.



#### 28.3.2 Number.isInteger

정적 메서드로 인수로 전달된 값이 정수인지 검사하여 그 결과를 불리언 값으로 반환한다. 암묵적 형변환을 하지 않는다.

```js
// 인수가 정수면 true를 반환한다
Number.isInteger(0);
Number.isInteger(123);
Number.isInteger(-123);

// 정수가 아니면 false를 반환한다
Number.isInteger(0.5);
Number.isInteger('123');
Number.isInteger(false);
Number.isInteger(Infinity);
```



#### 28.3.3 Number.isNaN

정적 메서드로 전달된 숫자값이 NaN인지 검사하여 그 결과를 불리언 값을 반환한다.

```js
Number.isNaN(NaN);
```

이 메서드도 빌트인 전역 함수 isNaN과 암묵적 형변환의 유무가 차이점으로 존재한다.



#### 28.3.4 Number.isSafeInteger

 정적 메서드로 인수로 전달된 숫자값이 안전한 정수인지 검사하여 그 결과를 불리언 값으로 반환한다. 암묵적 형변환을 하지 않는다.

```js
// 안전한 값은 true다
Number.isSafeInteger(0);
Number.isSafeInteger(1000000000000000);

// 안전하지 않은 값은 false다
Number.isSafeInteger(10000000000000001);
Number.isSafeInteger(0.5);
```



#### 28.3.5 Number.prototype.toExponential

toExponential 메서드는 숫자를 지수 표기법으로 변환하여 문자열로 반환한다. 인수로 소수점 이하로 표현할 자릿수를 전달할 수 있다.

```js
(77.1234).toExponential();	// "7.71234e+1"
(77.1234).toExponential(4);	// "7.7123e+1"
(77.1234).toExponential(2);	// "7.71e+1"
```

숫자 뒤의 .은 부동 소수점의 소수 구분 기호일 수도 있고 프로퍼티 접근 연산자 일 수도 있기 때문에 숫자를 그룹 연산자로 묶어서 사용하는 것이 좋다.

```js
77.toExponential();	// SyntaxError: Invalid or unexpected token

// 두 번째 .은 접근 연산자임이 확실하니 오류가 발생하지 않는다.
77.1234.toExponential();
```



#### 28.3.6 number.prototype.toFixed

toFixed 메서드는 숫자를 반올하여 문자열로 반환한다. 자릿수를 나타내는 0~20 사이의 정수값을 인수로 전달할 수 있다. 기본값은 0이다.

```js
(12345.6789).toFixed();		// 12346
(12345.6789).toFixed(1);	// 12345.7
```



#### 28.3.7 Number.prototype.toPrecision

toPrecision 메서드는 인수로 전달받은 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다. 전체 자릿수를 나타내는 0~21 사이의 정수값을 인수로 전달할 수 있다. 기본값은 0이다.

```js
(12345.6789).toPricision();		// 12345.6789
(12345.6789).toPricision(1);	// 1e+4
(12345.6789).toPricision(2);	// 1.2e+4
(12345.6789).toPricision(6);	// 12345.7
```



#### 28.3.8 Number.prototype.toString

toString 메서드는 숫자를 문자열로 변환하여 반환한다. 진법을 나타내느 2~36 사이의 정수값을 인수로 전달할 수 있다. 기본값은 10진법이다.

```js
(10).toString();	// "10"
(16).toString(2);	// "10000"
```



## 29장 Math

표준 빌트인 객체 Math는 수학적인 상수와 함수를 위한 프로퍼티와 메서드를 제공한다. 생성자 함수가 아니기 때문에 정적 프로퍼티와 메서드만 제공한다.

### 29.1 Math 프로퍼티

#### 29.1.1 Math.PI

원주율 값을 반환한다.

```js
MATH.PI;	// 3.14159265358979
```



### 29.2 Math 메서드

#### 29.2.1 Math.abs

인수로 전달된 숫자의 절대값을 반환한다.

```js
Math.abs(-1);		// 1
Math.abs('-1');		// 1
Math.abs('');		// 0
Math.abs([]);		// 0
Math.abs({});		// NaN
Math.abs('string');	// NaN
Math.abs();			// NaN
```



#### 29.2.2 Math.round

인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환한다.

```js
Math.round(1.4);	// 1
Math.round(1.6);	// 2
Math.round(-1.4);	// -1
Math.round(-1.6);	// -2
Math.round(1);		// 1
Math.round();		// NaN
```



#### 29.2.3 Math.ceil

인수로 전달된 숫자의 소수점 이하를 올림한 정수를 반환한다.

```js
Math.ceil(1.4);		// 2
Math.ceil(1.6);		// 2
Math.ceil(-1.4);	// -1
Math.ceil(-1.6);	// -1
Math.ceil(1);		// 1
Math.ceil();		// NaN
```



#### 29.2.4 Math.floor

인수로 전달된 숫자의 소수점 이하를 버림한 정수를 반환한다.

```js
Math.floor(1.4);	// 1
Math.floor(1.6);	// 1
Math.floor(-1.4);	// -2
Math.floor(-1.6);	// -2
Math.floor(1);		// 1
Math.floor();		// NaN
```



#### 29.2.5 Math.sqrt

인수로 전달된 숫자의 제곱근을 반환한다.

```js
Math.sqrt(9);	// 3
Math.sqrt(-9);	// NaN
Math.sqrt(2);	// 1.414213562373095
Math.sqrt(1);	// 1
Math.sqrt(0);	// 0
Math.sqrt();	// NaN
```



#### 29.2.6 Math.random

임의의 난수를 반환한다. 반환한 난수는 0에서 1미만의 실수다. 0은 포함되지만 1은 포함되지 않는다.

```js
const random = Math.floor((Math.random() * 10) + 1);
console.log(random);	// 1에서 10 범위의 정수
```



#### 29.2.7 Math.pow

첫 번째 인수를 밑으로, 두 번째 인수를 지수로 거듭제곱한 결과를 만환한다.

```js
Math.pow(2, 8);	// 256
Math.pow(2, -1);// 0.5
Math.pow(2);	// NaN
```

ES7에서 도입된 지수 연산자를 사용하면 가독성이 더 좋다.

```js
2 ** 2 ** 2;	// 16
Math.pow(Math.pow(2, 2), 2);	// 16
```



#### 29.2.8 Math.max

전달받은 인수 중에서 가장 큰 수를 반환한다.

```js
Math.max(1);		// 1
Math.max(1, 2);		// 2
Math.max(1, 2, 3);	// 3
Math.max();			// Infinity
```

배열을 인수로 받아 최대값을 구하려면 Function.prototype.apply 메서드 또는 스프레드 문법을 사용해야 한다.

```js
Math.max.apply(null, [1, 2, 3]);	// 3

Math.max(...[1, 2, 3]);				// 3
```



#### 29.2.9 Math.min

전달받은 인수 중에서 가장 작은 수를 반환한다.

```js
Math.min(1);		// 1
Math.min(1, 2);		// 1
Math.min(1, 2, 3);	// 1
Math.min();			// Infinity
```

배열을 인수로 받아 최대값을 구하려면 Function.prototype.apply 메서드 또는 스프레드 문법을 사용해야 한다.

```js
Math.min.apply(null, [1, 2, 3]);	// 1

Math.min(...[1, 2, 3]);				// 1
```



## 30장 Date

표준 빌트인 객체인 Date는 날짜와 시간을 위한 메서드를 제공하는 빌트인 객체이면서 생성자 함수다.

UTC는 국제 표준시를 말한다. GMT(그리니치 평균시)로 불리기도 하지만 초의 소수점 단위에서만 차이가 난다. 기술적인 표기에서는 UTC가 사용된다. KST(한국 표준시)는 UTC에 9시간을 더한 시간이다.

현재 날짜와 시간은 자바스크립트 코드가 실행된 시스템의 시계에 의해 결정된다.

### 30.1 Date 생성자 함수

Date 생성자 함수로 생성한 Date 객체는 내부적으로 날짜와 시간을 나타내는 정수값을 갖는다. 이 값은 1970년 1월 1일 00:00:00(UTC)을 기점으로 Date 객체가 나타내는 날짜와 시간까지의 밀리초를 나타낸다. 예를 들어 1970년 1월 1일 00:00:00를 나타내는 Date 객체는 정수값 0을 가지고 하루가 지난 1970년 1월 2일 00:00:00을 나타내는 Date 객체는 86,400,000(24h * 60m * 60s * 1000ms)을 가진다.

Date 생성자 함수는 기본적으로 현재 날짜와 시간을 나타내는 정수값을 가진다. 다른 날을 다루고 싶은 경우 Date 생성자 함수에 명시적으로 해당 날짜와 시간 정보를 인수로 지정하는 4가지 방법이 있다.

#### 30.1.1 new Date()

Date 생성자 함수를 인수 없이 호출하면 현재 날짜와 시간을 가지는 Date 객체를 반환한다.

```js
new Date();	// Thu Mar 10 2022 17:26:31 GMT+0900 (대한민국 표준시)
```

Date 생성자 함수를 new 연산자 없이 호출하면 Date 객체를 반환하지 않고 날짜와 시간 정보를 나타내는 문자열을 반환한다.

```js
Date();	// "Thu Mar 10 2022 17:26:31 GMT+0900 (대한민국 표준시)"
```



#### 30.1.2 new Date(milliseconds)

생성자 함수에 숫자 타입의 밀리초를 인수로 전달하면 기준 날로부터 전달된 밀리초만큼 경과한 날짜와 시간을 나타내는 Date 객체를 반환한다.

```js
new Date(0);		// 1970-01-01T00:00:00.000Z

new Date(86400000);	// 1970-01-02T00:00:00.000Z
```



#### 30.1.3 new Date(dateString)

생성자 함수에 날짜와 시간을 나타내는 문자열을 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 이때 인수로 전달한 문자열은 Date.parse 메서드에 의해 해석 가능한 형식이어야 한다.

```js
new Date('March 10, 2022 17:30:00');	// 2022-03-10T08:30:00.000Z

new Date('2022/03/10/17:30:00');		// 2022-03-10T08:30:00.000Z
```



#### 30.1.4 new Date(year, month[, day, hour, minute, second, millisecond])

생성자 함수에 연, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 인수로 전달하면 지정된 날짜와 시간을 나타내는 Date 객체를 반환한다. 이때 연, 월은 반드시 지정해야 한다. 지정하지 않은 옵션 정보는 0 또는 1로 초기화된다.

| 인수        | 내용                                                         |
| ----------- | ------------------------------------------------------------ |
| year        | 연을 나타내는 1900년 이후의 정수. 0부터 99는 1900부터 1999로 처리된다 |
| month       | 월을 나타내는 0~11까지의 정수(0 = 1월)                       |
| day         | 일을 나타내는 1~31까지의 정수                                |
| hour        | 시를 나타내는 0~23까지의 정수                                |
| minute      | 분을 나타내는 0~59까지의 정수                                |
| second      | 초를 나타내는 0~59까지의 정수                                |
| millisecond | 밀리초를 나타내는 0~999까지의 정수                           |



### 30.2 Date 메서드

#### 30.2.1 Date.now

1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다.

```js
const now = Date.now();

new Date(now);	// 2022-03-10T08:39:13.134Z
```



#### 30.2.2 Date.parse

Date 생성자 함수 기본일을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. 이때 인수의 형식은 new Date(dateString)의 인수와 동일하다.

```js
Date.parse('Jan 2, 1970 00:00:00 UTC');
```



#### 30.2.3 Date.UTC

기본일을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. 인수는 new Date(year, month[, day, hour, minute, second, millisecond])의 인수와 동일한 형식이다.

```js
Date.UTC(1970, 0, 2);
```



#### 30.2.4 Date.prototype.getFullYear

객체의 연도를 나타내는 정수를 반환한다.

```js
new Date('2022/03/10').getFullYar();	// 2022
```



#### 30.2.5 Date.prototype.setFullYear

객체에 연도를 나타내는 정수를 설정한다. 연도 이외에 옵션으로 월, 일도 설정할 수 있다.

```js
const today = new Date();

today.setFullYear(2022);
today.getFullYear(2022);	// 2022

today.setFullYear(2022, 2, 10);
```



#### 30.2.6 Date.prototype.getMonth

객체의 월을 나타내는 0 ~ 11의 정수를 반환한다.

```js
new Date('2022/03/10').getMonth();	// 2
```



#### 30.2.7 Date.prototype.setMonth

객체에 월을 나타내는 0 ~ 11의 정수를 설정한다. 옵션으로 일도 설정할 수 있다.

```js
const today = new Date();

today.setMonth(2);
today.getMonth();	// 2

today.setMonth(2, 10);
```



#### 30.2.8 Date.prototype.getDate

객체의 날짜를 나타내는 정수를 반환한다.

```js
new Date('2022/03/10').getDate();	// 10
```



#### 30.2.9 Date.prototype.setDate

객체에 날짜를 나타내는 정수를 설정한다.

```js
const today = new Date();

today.setDate(10);
today.getDate();	// 10
```



#### 30.2.10 Date.prototype.getDay

객체의 요일(0 ~ 6)을 나타내는 정수를 반환한다. 0부터 일요일 ~ 6 토요일 이다.

```js
new Date('2022/03/10').getDay();	// 4(목요일)
```



#### 30.2.11 Date.prototype.getHours

객체의 시간을 나타내는 정수를 반환한다.

```js
new Date('2022/03/10/12:00').getHours();	// 12
```



#### 30.2.12 Date.prototype.setHours

객체에 시간을 나타내는 정수를 설정한다. 옵션으로 분, 초, 밀리초도 설정할 수 있다.

```js
const today = new Date();

today.setHours(7);

today.setHours(0, 0, 0, 0);	// 시 분 초 밀리초
```



#### 30.2.13 Date.prototype.getMinutes

객체의 분을 나타내는 정수를 반환한다.

```js
new Date('2022/03/10/12:30').getMinutes();	// 30
```



#### 30.2.14 Date.prototype.setMinutes

객체에 분을 나타내는 정수를 설정한다. 옵션으로 초, 밀리초도 설정할 수 있다.

```js
const today = new Date();

today.setMinutes(50);

today.setMinutes(5, 10, 999);	// 분 초 밀리초
```



#### 30.2.15 Date.prototype.getSeconds

객체의 초를 나타내는 정수를 반환한다.

```js
new Date('2022/03/10/12:30:10').getSeconds();	// 10
```



#### 30.2.16 Date.prototype.setSeconds

객체에 초를 나타내는 정수를 설정한다. 옵션으로 밀리초도 설정할 수 있다.

```js
const today = new Date();

today.setSeconds(30);	

today.setSeconds(10, 0);	// 초 밀리초
```



#### 30.2.17 Date.prototype.getMilliseconds

객체의 밀리초를 나타내는 정수를 반환한다.

```js
new Date('2022/03/10/12:30:10:150').getMilliseconds();	// 150
```



#### 30.2.18 Date.prototype.setMilliseconds

객체에 밀리초를 나타내는 정수를 설정한다.

```js
const today = new Date();

today.setMilliseconds(123);
```



#### 30.2.19 Date.prototype.getTime

기준일을 기점으로 Date 객체의 시간까지 경과된 밀리초를 반환한다.

```js
new Date('2022/03/10/12:30').getTime();
```



#### 30.2.20 Date.prototype.setTimte

Date 객체에 기준일로부터 경과된 밀리초를 설정한다.

```js
const today = new Date();

today.setTime(86400000);
```



#### 30.2.21 Date.prototype.TimezoneOffset

UTC와 Date 객체에 지정된 로캘 시간과의 차이를 분 단위로 반환한다.

```js
const today = new Date();

today.getTimezoneOffset() / 60;	// -9
```



#### 30.2.22 Date.prototype.toDateString

사람이 읽을 수 있는 형식의 문자열로 Date 객체의 날짜를 반환시킨다.

```js
const today = new Date('2020/03/10/12:30');

today.toString();		// Tue Mar 10 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toDateString();	// Tue Mar 10 2020
```



#### 30.2.23 Date.prototype.toTimeString

사람이 읽을 수 있는 형식으로 Date 객체의 시간을 표현한 문자열을 반환한다.

```js
const today = new Date('2020/03/10/12:30');

today.toString();		// Tue Mar 10 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toTimeString();	// 12:30:00 GMT+0900 (대한민국 표준시)
```



#### 30.2.24 Date.prototype.toISOString

ISO 8601 형식으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다.

```js
const today = new Date('2022/03/10/12:30');

today.toString();		// Tue Mar 10 2020 12:30:00 GMT+0900 (대한민국 표준시)
today.toISOString();	// 2020-03-10T03:30:00.000Z
```



#### 30.2.25 Date.prototype.toLocalString

인수로 전달한 로캘을 기준으로 Date 객체의 날짜와 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.

```js
const today = new Date('2022/03/10/12:30');

today.toString();				// Thu Mar 10 2022 12:30:00 GMT+0900 (대한민국 표준시)
today.toLocaleString();			// 2022. 3. 10. 오후 12:30:00
today.toLocaleString('ko-KR');	// 2022. 3. 10. 오후 12:30:00
today.toLocaleString('en-US');	// 3/10/2022, 12:30:00 PM
today.toLocaleString('ja-JP');	// 2022/3/10 12:30:00
```



#### 30.2.26 Date.prototype.toLocaleTimeString

인수로 전달한 로캘을 기준으로 Date 객체의 시간을 표현한 문자열을 반환한다. 인수를 생략한 경우 브라우저가 동작 중인 시스템의 로캘을 적용한다.

```js
const today = new Date('2022/03/10/12:30');

today.toString();					// Thu Mar 10 2022 12:30:00 GMT+0900 (대한민국 표준시)
today.toLocaleTimeString();			// 오후 12:30:00
today.toLocaleTimeString('ko-KR');	// 오후 12:30:00
today.toLocaleTimeString('en-US');	// 12:30:00 PM
today.toLocaleTimeString('ja-JP');	// 12:30:00
```



### 30.3 Date를 활용한 시계 예제

현재 날짜와 시간을 초 단위로 반복 출력한다.

```js
// 시계 예제
(function printNow(){
    const today = new Date();

    const dayNames = [
        '(일요일)',
        '(월요일)',
        '(화요일)',
        '(수요일)',
        '(목요일)',
        '(금요일)',
        '(토요일)'
    ];

    const day = dayNames[today.getDay()];
    const year = today.getFullYear();
    const month = today.getMonth() + 1;
    const date = today.getDate();
    let hour = today.getHours();
    let minute = today.getMinutes();
    let second = today.getSeconds();
    const ampm = hour >= 12 ? 'PM' : 'AM';

    // 12시간제로 변경
    hour %= 12;
    hour = hour || 12; // hour가 0이면 12를 재할당

    // 10 미만인 분과 초를 2자리로 변경
    minute = minute < 10 ? '0' + minute : minute;
    second = second < 10 ? '0' + second : second;

    const now = `${year}년 ${month}월 ${date}일 ${day} ${hour}:${minute}:${second} ${ampm}`;

    console.log(now);

    setTimeout(printNow, 1000);
}());

/*
결과 화면
2022년 3월 10일 (목요일) 6:21:30 PM
2022년 3월 10일 (목요일) 6:21:31 PM
2022년 3월 10일 (목요일) 6:21:32 PM
2022년 3월 10일 (목요일) 6:21:33 PM
2022년 3월 10일 (목요일) 6:21:34 PM
2022년 3월 10일 (목요일) 6:21:35 PM
*/
```

