# 모던 자바스크립트 Deep Dive(11 ~)

------

## 개요

Javascript 공부를 위해 구매한 책을 정리한 노트입니다

이미 알고 있는 내용도 복습의 차원에서 같이 정리하였습니다

------

## 11장 원시 값과 객체의 비교

자바스크립트가 제공하는 7가지 데이터 타입은 크게 **원시 타입**과 **객체 타입**으로 구분할 수 있다. 원시 타입과 객체 타입은 크게 세 가지 측면에서 다르다

1. 원시 타입의 값은 변경 불가능하다. 그에 반해 객체 타입의 값은 변경 가능하다.
2. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 전달된다(값에 의한 전달). 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다(참조에 의한 전달).



### 11.1 원시 값

#### 11.1.1 변경 불가능한 값

원시 타입의 값은 변경 불가능한 값이다. 여기서 변경 불가능하단 의미는 변수의 값을 변경할 수 없다는 것이 아니라 값 자체를 변경할 수 없다는 얘기다.

4.5절 값의 할당에서 우리는 변수에 값을 재할당 했을 때 메모리 공간의 주소를 변경해 주었던 것을 볼 수 있었다. 그 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문에 새로운 원시 값을 할당하면 기존에 있던 원시 값을 그대로 두고 다른 메모리에서 원시 값을 제공한 것이다. 이러한 값의 특성을 불변성이라 한다.

**불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법은 없다.** 그렇지 않다면 예기치 않은 변수 값의 변경이 생겨날 수 있기 때문이다



#### 11.1.2 문자열과 불변성

원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있다. 문자 하나는 2바이트의 저장 공간이 필요하기에 문자열은 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다. 문자열도 원시값이기 때문에 변경이 불가능하다.

```js
let str = 'Hello';
str = 'world';
```

여기서도 str은 'Hello'가 저장된 메모리 공간의 첫 번째 메모리 셀을 가리키다가 두번째 문이 실행되면 'world'가 저장된 첫 번째 메모리 셀을 가리키게 된다.

```js
let str = 'string';

str[0] = 'S';		//문자열은 원시값이기 떄문에 반영되지 않는다

console.log(str);	//string
```



#### 11.1.3 값에 의한 전달

```js
let score = 80;
let copy = score;
//copy에는 원시값 80이 전달된다

console.log(score);	//80
console.log(copy);	//80

score = 100;

console.log(score);	//100
console.log(copy);	//80
```

여기서 score와 copy는 각각 다른 메모리 공간을 가진다. 엄밀히 말하자면 변수에는 값이 아니라 메모리 주소가 전달된다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

하지만 결국 **두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다**



### 11.2 객체

객체는 프로퍼티의 수가 정해져 있지 않고, 동적으로 추가되고 삭제될 수 있다. 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

#### 11.2.1 변경 가능한 값

객체는 타입의 값, 즉 **변경 가능한 값**이다.

```js
let person = {
    name: 'Lee'	//변경이 가능하다
};
```

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리 공간의 주소 그 자체다.

원시 값은 변경 불가능한 값으로 변수의 값을 변경하려면 재할당 밖에는 방법이 없지만 객체는 변경 가능한 값이기 때문에 재할당 없이 직접 변경할 수 있다.

객체는 크기가 매우 클 수도 있고, 원시 값처럼 크기가 일정하지도 않으며, 프로퍼티 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.(= 메모리의 효율적으로 사용하기 어렵고 성능이 나빠진다)

따라서 객체를 복사해 생성하는 비용을 절약하기 위해 객체는 변경 가능하게 설계되었다. 이러한 구조적 단점이 존재하는데 그것은 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

##### 얕은 복사와 깊은 복사

얕은 복사는 객체의 참조 값을 복사하고 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사한다.

```js
const o = { x: { y: 1 } };

//얕은 복사
const c1 = { ...o };
console.log(c1 === o);	//false
console.log(c1.x === o.x);	//true

//lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('lodash');
//깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o);	//false
console.log(c2.x === o.x);	//false
```



#### 11.2.2 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇인지 알아보자

```js
let person = {
    name: 'Lee'
};

let copy = person;
```

여기서 copy는 person의 참조 값이 복사되어 전달 된다. 따라서 copy와 person 두 개의 식별자가 하나의 객체를 공유하게 된다.

```js
let person = {
    name: 'Lee'
};

let copy = person;

copy.name = 'Kim';
person.address = 'Seoul';

//객체를 공유하기 때문에 둘 다 변경되었다
console.log(person);	//{ name: "Kim", address: "Seoul" }
console.log(copy);		//{ name: "Kim", address: "Seoul" }
```

참조에 의한 전달과 값에 의한 전달은 메모리 공간에 있는 값을 복사한다는 점은 같지만, 복사한 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.

------

## 12장 함수

### 12. 1 함수란?

**함수란 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.**

```js
function 함수이름(매개변수1, 매개변수2, ...){	//함수 정의
	return 반환값;		//함수 몸체
}
함수이름(인수);		//함수 호출
```



### 12.2 함수를 사용하는 이유

함수는 만들어 두면 몇 번이든 호출할 수 있으므로 **코드의 재사용**이라는 측면에서 매우 유용하다. 코드의 중복을 줄이게 되면 **유지보수의 편의성**을 높이고 **코드의 신뢰성**을 높이는 효과가 있다. 또한 적절한 함수의 이름은 **코드의 가독성**을 향상시킨다.

```js
//기존 코드
let x = 0, y = 0, result = 0;

x = 1;
y = 2;
result = x + y;

x = 3;
y = 4;
result = x + y;

x = 5;
y = 6;
result = x + y;

//함수를 사용한 코드
function add(x, y){
    return x + y;
}

let result = 0;

result = add(1, 2);
result = add(3, 4);
result = add(5, 6);
```



### 12.3 함수 리터럴

자바스크립트의 함수는 개체 타입의 값이다. 따라서 함수 리터럴로 생성할 수 있다.

```js
let f = function add(x, y){
    return x + y;
};
```

| 구성 요소     | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 함수 이름     | 함수 이름은 식별자다. 따라서 식별자 네이밍 규칙을 준수해야 한다<br />함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다<br />함수 이름은 생략할 수 있다. 이름이 있는 함수를 기명 함수, 이름이 없는 함수를 무명/익명 함수라 한다 |
| 매개변수 목록 | 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다<br />각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당된다. 즉, 순서가 의미가 있다<br />매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다 |
| 함수 몸체     | 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다<br />함수 몸체는 함수 호출에 의해 실행된다 |

함수도 리터럴로 평가되어 값을 생성하며, 이 값은 **객체**다. **일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.**



### 12.4 함수 정의

함수 정의 방식에는 4가지가 있다

```js
//함수 선언문
function add(x, y){
    return x + y;
}

//함수 표현식
let add = function(x, y){
    return x + y;
};

//Function 생성자 함수
let add = new Function('x', 'y', 'return x + y');

//화살표 함수(ES6)
let add = (x, y) => x + y;
```



#### 12.4.1 함수 선언문

함수 선언문은 함수 리터럴과 형태가 동일하다. 단, 함수 리터럴은 함수 이름을 생략할 수 있으나 **함수 선언문은 함수 이름을 생략할 수 없다.**

함수 선언문은 표현식이 아닌 문이다. 5.6절에서 표현식이 아닌 문은 변수에 할당할 수 없다고 했으나 다음 예제는 함수 선언문은 변수에 할당되는 것처럼 보인다.

```js
let add = function add(x, y){
	return x + y;
};

console.log(add(2, 5));
```

이것이 가능한 이유는 자바스크립트 엔진이 코드의 문맥에 따라 함수 리터럴을 표현식이 아닌 함수 선언문으로 해석하는 경우와 표현식인 함수 리터럴 표현식으로 해석하는 경우가 있기 때문이다. 함수 선언문은 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 같은 형태를 가진다. 이것은 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 수 있다는 얘기이다.

**{}도 블록문 또는 객체 리터럴로 해석될 수 있는 것처럼 함수 리터럴도 문맥에 따라 해석이 달라진다**

함수 선언문과 함수 리터럴의 차이를 알아보기 위한 예제를 살펴보자

```js
//기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
//함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo') }
foo();

//함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
//함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar') });
bar();	//ReferenceError: bar is no defined
```

위 예제에서 함수 리터럴의 경우 함수를 정의한것 처럼 보이지만 호출할 수 없다. 12.3절에서 "함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다"라고 했다. 이는 함수 몸체 외부에서 함수 이름으로 함수를 참조할 수 없다는 뜻으로, 함수 이름으로 함수를 호출할 수 없다는 의미이다. 그렇다면 foo(함수 선언문)함수는 어떻게 외부에서 함수 이름을 통해 함수를 호출했을까?

그 이유는 자바스크립트 엔진이 암묵적으로 foo라는 식별자를 생성해냈기 때문이다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이니 함수 객체를 가리킬 식별자가 필요하니 **자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.**

```js
let add = function add(x, y){	//식별자 add에 함수 add를 할당했다.
    return x + y;
};

console.log(add(2, 5));			//add 함수를 호출한 것은 함수 이름이 아니라 식별자 add이다.
```



#### 12.4.2 함수 표현식

값의 성질을 갖는 객체를 **일급 객체**라고 한다. **자바스크립트의 함수는 일급 객체다.** 이는 함수를 값처럼 자유롭게 사용할 수 있다는 의미이다.

```js
//기명 함수 표현식
let add = function foo(x, y){
    return x + y;
};

//함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));

//함수 이름으로 호출하면 ReferenceError가 발생한다.
console.log(foo(2, 5));	//ReferenceError: foo is not defined
```

자바스크립트 엔진이 함수 선언문의 함수 이름으로 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. 하지만 함수 선언문은 '표현식이 아닌 문'이고 함수 표현식은 '표현식인 문'이니 차이가 있다는 것을 기억하자.



#### 12.4.3 함수 생성 시점과 함수 호이스팅

```js
//함수 참조
console.dir(add);	// f add(x, y)
console.dir(sub);	// undefined

//함수 호출
console.log(add(2, 5));	// 7
console.log(sub(2, 5));	// TypeError: sub is not a function

//함수 선언문
function add(x, y){
    return x + y;
}

//함수 표현식
let sub = function (x, y){
    return x - y;
}
```

위 예제에서 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 하지만 함수 표현식으로 정의한 함수는 이전에 호출할 수 없다. 함수 선언문은 런타임 이전에 코드가 먼저 실행되기 때문이다. 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **함수 호이스팅**이라 한다.

함수 호이스팅과 변수 호이스팅은 약간의 차이점이 존재한다. 변수 호이스팅은 undefined로 초기화되어 참조시 undefined로 평가되지만 함수 호이스팅은 호출이 가능하다.

변수 할당문은 값이 할당되는 시점인 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 따라서 **함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅만 발생한다.**



#### 12.4.4 Function 생성자 함수

Function 생성자 함수로 add 함수를 생성해 보자.

```js
let add = new Function('x', 'y', 'return x + y');

console.log(add(2, 5));
```

Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다. 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

```js
let add1 = (function (){
    let a = 10;
    return function(x, y){
        return x + y + a;
    };
}());

console.log(add1(1, 2));	//13

let add2 = (function (){
    let a = 10;
    return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2));	//ReferenceError: a is not defined
```



#### 12.4.5 화살표 함수

ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표(=>)를 이용해 좀 더 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명으로 정의한다.

```js
const add = (x, y) => x + y;
console.log(add(2, 5));
```

화살표 함수는 기존의 함수 선언문 또는 함수 표현식을 완전히 대체하기 위해 디자인된 것은 아니다. 화살표 함수는 기존의 함수보다 표현만 간략한 것이 아니라 내부의 동작 또한 간략화 되어 있다. 화살표 함수는 생성자로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. 화살표 함수에 대해서는 이 개념들을 다 살펴본 후 자세히 살펴보자.



### 12.5 함수 호출

함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.

#### 12.5.1 매개변수와 인수

함수를 실행하기 위해 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우, 매개변수를 통해 인수를 전달한다. 인수는 값으로 평가될 수 있는 표현식이어야 하며, 개수와 타입에 제한이 없다.

```js
//함수 선언문
function add(x, y){
    return x + y;
}

//함수 호출
//인수 1,2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
let result = add(2, 5);
```

매개변수는 함수 몸체 내부에서만 참조할 수 있고 외부에서는 참조할 수 없다. 스코프(유효 범위)가 함수 내부라는 의미다.

```js
function add(x, y){
    return x + y;
}

add(2, 5);

// add 함수의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.
console.log(x, y);	//ReferenceError: x is not defined
```

함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다. 함수를 호출할 때 매개변수의 수만큼 인수를 전달하지 않아도 에러가 발생하지 않는다. 인수가 할당되지 않은 매개변수의 값은 undefined다. 초과된 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

```js
function add(x, y){
    return x + y;
}

console.log(add(2));	//NaN

--------------------------------

function add(x, y){
    console.log(arguments);
    
    return x + y;
}

console.log(add(2, 5, 10));	//7

```



#### 12.5.2 인수 확인

```js
function add(x, y){
    return x + y;
}

console.log(add(2));	//NaN
console.log(add('a', 'b'));	//'ab'
```

위 예제는 자바스크립트 문법상 어떠한 문제도 없다. 그 이유는 다음과 같다

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

따라서 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.

```js
function add(x, y){
    if(typeof x !== 'number' || typeof y !== 'number'){
        throw new TypeError('인수는 모두 숫자 값이어야 합니다!');
    }
    return x + y;
}

console.log(add(2));		//TypeError: 인수는 모두 숫자 값이어야 합니다.
console.log(add('a', 'b'));	//TypeError: 인수는 모두 숫자 값이어야 합니다.
```

arguments 객체를 통해 인수 개수를 확인할 수도 있고, 단축 평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.

```js
function add(a, b, c){
    a = a || 0;
    b = b || 0;
    c = c || 0;
    return a + b + c;
}

console.log(add(1, 2, 3));	//6
console.log(add(1, 2));		//3
console.log(add(1));		//1
console.log(add());			//0
```

ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다. 이 기본값은 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효하다.

```js
function add(a = 0, b = 0, c = 0){
    return a + b + c;
}

console.log(add(1, 2, 3));	//6
console.log(add(1, 2));		//3
console.log(add(1));		//1
console.log(add());			//0
```



#### 12.5.3 매개변수의 최대 개수

ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다. 하지만 함수의 매개변수가 많으면 함수의 사용법을 이해하기 어렵게 만들고 나중에 변경시 함수를 사용하는 코드 전체가 영향을 받아 유지보수성이 나빠진다.

이상적인 매개변수의 개수는 0개이다. 매개변수가 많다는 의미는 함수가 여러가지 일을 한다는 증거이므로 바람직하지 않다. 이상적인 함수는 한 가지 일만 해야하며 가급적 작게 만들어야 한다. 따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.

```js
//jQuery의 ajax 메서드에 객체를 인수로 전달하는 예
$.ajax({
	method: 'POST',
    url: '/user',
    data: { id: 1, name: 'Lee' },
    cache: false
});
```

객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 된다. 또한 명시적으로 인수의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과가 있다.

하지만 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과가 발생하니 주의해야한다.



#### 12.5.4 반환문

함수는 return 키워드와 표현식으로 이뤄진 반환문을 사용해 실행 결과를 함수 외부로 반환할 수 있다.

```js
function multiply(x, y){
	return x * y;
}

let result = multiply(3, 5);
console.log(result);	//15
```

**함수 호출은 표현식이다.** 함수 호출 표현식은 return 키워드가 반환한 표현식의 평가 결과, 즉 반환값으로 평가된다.

반환문의 역할은 다음과 같다.

1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 반환문 이후의 다른 문은 실행되지 않고 무시된다.
2. return 키워드 뒤에 오는 표현식을 평가해 반환한다. 표현식이 명시되지 않으면 undefined가 반환된다.

```js
function multiply(x, y){
	return x * y;
    console.log('실행되지 않는다')
}

let result = multiply(3, 5);
console.log(result);	//15

//표현식을 지정하지 않으면 undefined가 반환된다
function foo(){
	return;
}

console.log(foo());	//undefined

//반환문이 생략되면 암묵적으로 undefined를 반환한다
function foo(){
	
}

console.log(foo());	//undefined
```



### 12.6 참조에 의한 전달과 외부 상태의 변경

11장 "원시 값과 객체에 비교"에서 살펴보았듯이 값에 의한 전달, 참조에 의한 전달은 매개변수에도 그대로 적용된다.

```js
function changeVal(primitive, obj){
    primitive += 100;
    obj.name = 'Kim';
}

//외부 상태
let num = 100;
let person = { name: 'Lee' };

console.log(num);
console.log(person);

changeVal(num, person);

//원시 값은 원본이 훼손되지 않는다
console.log(num);	// 100
//객체는 원본이 훼손된다
console.log(person);	//{name: 'Kim'}
```

이처럼 객체가 변경되는 문제를 해결하는 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다. 객체의 상태 변경이 필요한 경우에는 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨 수 있다.



### 12.7 다양한 함수의 형태

#### 12.7.1 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다. 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다.

```js
(function (){
    let a = 3;
    let b = 5;
    return a * b;
}());
```

즉시 실행 함수는 익명 함수를 사용하는 것이 일반적이다. 기명 함수도 사용할 수 있지만 어차피 즉시 실행 함수를 다시 호출할 수는 없다.

즉시 실행 함수는 반드시 그룹 연산자(...)로 감싸야 한다. 그렇지 않으면 에러가 발생한다

```js
function (){	//SyntaxError: Function statements require a function name
    //...
}();

function foo(){	
    //...
}();	//SyntaxError: Unexpected token ')'
//함수 선언문 뒤에 자동으로 ;이 삽입되고 그 뒤에 그룹 연산자에 피연산자가 없기 때문에 나타나는 에러다
```

즉시 실행 함수를 사용하는 방법은 여러가지가 있다

```js
(function () {
    // ...
}());

(function () {
    // ...
})();

!function () {
    // ...
}();

+function () {
    // ...
}();
```

즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

```js
let res = (function () {
    let a = 3;
    let b = 5;
    return a * b;
}());

console.log(res);	//15

res = (function (a, b){
    return a * b;
}(3, 5));

console.log(res);	//15
```



#### 12.7.2 재귀 함수

함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 함수는 자기 자신을 호출하는 함수를 말한다.

```js
//일반 함수 이용
function countdown1(n) {
    for(let i = n; i >= 0; i--){
        console.log(i);
    }
}
countdown(10);

//재귀 함수 이용
function countdown2(n) {
    if(n < 0) return;
    console.log(n)
    countdown2(n - 1);
}
countdown(10);
```

재귀 함수는 자신을 무한 재귀 호출한다. 따라서 **탈출 조건**을 반드시 만들어야 한다. 없다면 함수가 무한 호출되어 스택 오버플로가 발생한다.



#### 12.7.3 중첩 함수

함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라 한다. 중첩 함수를 포함하는 함수는 외부 함수라 부른다. 중첩 함수는 외부 함수 내부에서만 호출할 수 있다.

```js
function outer() {
    let x = 1;
    
    function inner() {
        let y = 2;
        console.log(x + y);
    }
    inner();
}
outer();
```



#### 12.7.4 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부러 전달되는 함수를 콜백 함수라 하고, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.

```js
function repeat(n , f){
    for(let i = 0; i < n; i++){
        f(i);
    }
}

let logAll = function (i){
    console.log(i);
};

repeat(5, logAll);	//0, 1, 2, 3, 4

let logOdds = function (i){
    if(i % 2) console.log(i);
};

repeat(5, logOdds);	//1, 3
```

콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.

```js
//익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, function (i){
    if(i % 2) console.log(i);
});	//1, 3
```

이 때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다. **고차 함수가 여러번 호출되면 함수 객체를 호출되는 만큼 생성한다는 의미이다.** 따라서 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 고차 함수에 전달하는 것이 효율적이다.

콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.

```js
document.getElementById('myButton').addEventListener('click', function (){
	console.log('button clicked!');
});

setTimeout(function (){
    console.log('1초 경과!');
}, 1000);
```

콜백 함수는 배열 고차 함수에서도 사용된다. 배열은 사용 빈도가 매우 높은 자료구조이고 고차 함수는 매우 중요하니 나중에 자세히 살펴보자.

```js
let res = [1, 2, 3].map(function (item){
    return item * 2;
})

console.log(res);	//[2, 4, 6]

res = [1, 2, 3].filter(function (item){
    return item % 2;
});

console.log(res);	//[1, 3]

res = [1, 2, 3].reduce(function (acc, cur) {
    return acc + cur;
}, 0);

console.log(res);	//6
```



#### 12.7.5 순수 함수와 비순수 함수

함수형 프로그래밍에서는 부수 효과가 없는 함수를 순수 함수, 부수 효과가 있는 함수를 비순수 함수(외부 상태에 의존)라고 한다. 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다.

순수 함수는 일반적으로 최소 하나 이상의 인수를 전달받는다. 인수를 전달받지 않는 순수 함수는 언제나 같은 값을 반환하므로 결국 상수와 마찬가지다. 또한 순수 함수는 불변성 유지를 위해 인수를 변경하지 않는 것이 기본이다.

```js
let count = 0;

//순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n){
    return ++n;
}

//순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count);	//1

count = increase(count);
console.log(count);	//2
```

반대로 함수의 외부 상태에 따라 반환값이 달라지는 함수, 다시 말해 외부 상태에 의존하는 함수를 비순수 함수라고 한다. 비순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하는 부수 효과가 있다는 것이다.

```js
let count = 0;

//비순수 함수
function increase(){
    return ++count;
}

//비순수 함수는 외부 상태를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count);	//1

increase();
console.log(count);	//2
```

------

## 13장 스코프

### 13.1 스코프란?

스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다. **변수(식별자)는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정되는데, 이를 스코프라 한다.**

```js
let x = 'global';

function foo() {
	let x = 'local';
    console.log(x)
}

foo();			//local

console.log(x);	//global
```

위 예제에서 코드의 가장 바깥 영영에 선언된 x는 어디서든 참조할 수 있다. 하지만 foo 함수 내에서 선언된 x는 foo 함수 내부에서만 참조할 수 있다. 이 때 두 개의 x는 식별자 이름이 동일하지만 자신이 유효한 범위, 즉 스코프가 다른 별개의 변수다.

원래 식별자는 유일한 이름이어 한다고 알고있다. 하지만 두 개의 x를 가질 수 있는 이유는 스코프를 통해 변수 이름의 충돌을 방지하기 때문이다. 스코프 내의 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.



### 13.2 스코프의 종류

코드는 전역과 지역으로 구분할 수 있다.

| 구분 | 설명                  | 스코프      | 변수      |
| ---- | --------------------- | ----------- | --------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

이때 변수는 자신이 선언되 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.



#### 13.2.1 전역과 전역 스코프

전역이란 코드의 가장 바깥 영역을 말한다. 전역은 전역 스코프를 만든다. 전역 변수는 어디서든지 참조할 수 있다.



#### 13.2.2 지역과 지역 스코프

지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만든다. 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.



### 13.3 스코프 체인

함수는 전역에서 정의할 수도 있고 함수 몸체 내부에서 정의할 수도 있다. 함수 몸체 내부에서 함수가 정의되면 함수의 중첩이라 한다. 함수가 중첩될 수 있으므로 지역 스코프도 중첩될 수 있다. 이는 **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다**는 것을 의미한다.

모든 스코프는 하나의 계층적 구조로 연결 되며, 모든 지역 스코프의 최상위 스코프는 전역 스코프다. 이렇게 스코프가 계층적으로 연결된 것을 **스코프 체인**이라 한다. 

**※ 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.**

스코프 체인은 물리적인 실체로 존재한다. 자바스크립트 엔진은 코드를 실행하기에 앞서 렉시컬 환경(자료구조)을 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 이 자료구조에 키로 등록되고, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조 상에서 이뤄진다.



#### 13.3.1 스코프 체인에 의한 변수 검색

자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드를 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이는 **상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한  변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다.**



#### 13.3.2 스코프 체인에 의한 함수 검색

다음 예제를 살펴보자

```js
//전역 함수
function foo() {
	console.log('global function foo');
}

function bar() {
    //중첩 함수
    function foo() {
        console.log('local function foo');
    }
    foo();
}

bar();	//local function foo
```

아래에서 위로 검색하기 때문에 local함수 foo가 먼저 검색된다. 따라서 "local function foo"가 출력되었다.

이처럼 함수도 식별자에 할당되기 때문에 스코프를 갖는다. 따라서 스코프를 **식별자를 검색하는 규칙**이라고 생각하는 편이 더 적합하다.



### 13.4 함수 레벨 스코프

지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다. 이는 **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다**는 의미다.

C나 자바 등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체 뿐만 아니라 모든 코드 블록이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라 한다. 하지만 **var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다.**

```js
var x = 1;
if(true){
    var x = 10;
}

console.log(x);	// 10
```

var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만 ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다.



### 13.5 렉시컬 스코프

```js
var x = 1;

function foo(){
	var x = 10;
    bar();
}

function bar(){
    console.log(x);
}

foo();	//1
bar();	//1
```

위 예제의 실행 결과는 bar 함수의 상위 스코프가 무엇인지에 따라 결정된다. 두 가지 패턴을 예측할 수 있다.

1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다

첫 번째 방식으로 함수의 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 foo 함수의 지역 스코프와 전역 스코프일 것이다. 두 번째 방식으로 함수의 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 전역 스코프일 것이다.

첫 번째 방식을 동적 스코프, 두 번째 방식을 렉시컬 스코프 또는 정적 스코프라 한다.

**자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.** 즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.

------

## 14장 전역 변수의 문제점

### 14.1 변수의 생명 주기

#### 14.1.1 지역 변수의 생명 주기

변수는 언젠가 없어지기 때문에 생명주기가 존재한다. 생명주기가 없다면 한번 선언된 변수가 영원히 메모리 공간을 점유하게 될것이다.

젼역변수의 생명 주기는 애플리케이션의 생명 주기와 같지만 함수 내부에 선언된 지역 변수는 함수가 호출되면 생성되고 종료하면 소멸한다.

```js
function foo(){
	let x = 'local';
    console.log(x);
    return x;
}

foo();
console.log(x);	//ReferenceError: x is not defined
```

위 예제에서 지역 변수 x는 foo 함수가 호출되기 이전까지는 생성되지 않는다. foo 함수를 호출하지 않으면 함수 내부의 변수 선언문이 실행되지 않기 때문이다.     

4.4절에서 봤던 변수 호이스팅에서 변수 선언은 위치에 상관없이 가장 먼저 실행된다고 했다. 하지만 이는 전역 변수에만 한정된 것이다. foo 함수를 호출하면 다른 문들이 실행되기 이전에 x 변수의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 x변수가 선언되고 undefined로 초기화된다. 그 후, 다른 문들이 순차적으로 실행된다. 그리고 함수가 종료되면 x변수도 소멸되어 생명 주기가 종료된다.

**지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.**

```js
var x = 'global';

function foo(){
	console.log(x);	//undefined
    var x = 'local';
}

foo();
console.log(x);	//global
```

위 예제를 보면 foo 내에 있는 x가 undefined로 출력이 된걸로 보아 호이스팅이 일어난 것을 알 수 있다. 이처럼 호이스팅은 스코프를 단위로 동작한다. **호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.**



#### 14.1.2 전역 변수의 생명 주기

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 의미한다. 전역 객체란 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 먼저 생성되는 특수한 객체다.

브라우저 환경에서 전역 객체는 window이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다. 전역 객체 window는 웹 페이지를 닫기 전까지 유효하다. 따라서 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹페이지를 닫을 때까지 유효하다. **var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다.**



### 14.2 전역 변수의 문제점

- 암묵적 결합
  - 전역 변수를 선언한다면 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합**을 허용하는 것이다. 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.
- 긴 생명 주기
  - 전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다. 또한 전역 변수의 상태를 변경 할 수 있는 시간도 길고 기회도 많다.
- 스코프 체인 상에서 종점이 존재
  - 전역 변수는 스코프 체인 상에서 종점에 존재한다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다(= **검색 속도가 가장 느리다**)
- 네임스페이스 오염
  - 자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 이싿 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 정겨 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.



### 14.3 전역 변수의 사용을 억제하는 방법

**전역 변수를 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사요해야 한다. 변수의 스코프는 좁을수록 좋다.** 무분별한 전역 변수의 사용을 막기 위해 사용할 수 있는 방법을 알아보자.

#### 14.3.1 즉시 실행 함수

즉시 실행 함수는 단 한 번만 호출된다. **모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.**

```js
(function () {
    var foo = 10;	//즉시 실행 함수의 지역 변수
    // ...
}());

console.log(foo);	//ReferenceError: foo is not defined
```



#### 14.3.2 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.

```js
var MYAPP = {};
MYAPP.name = 'Lee';
console.log(MYAPP.name);
```

네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용해 보이지는 않는다.



#### 14.3.3 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다.

```js
var Counter = (function (){
    //private 변수
    var num = 0;
    
    //외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
    return {
        increase() {
            return ++num;
        },
        decrease() {
            return --num;
        }
    };
}());
```

위 예제의 즉시 실행 함수는 객체를 반환한다. 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다. 이 때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버다. 외부에 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버가 된다.



#### 14.3.4 ES6 모듈

ES6 모듈을 사용하면 더는 전역 변수를 사용할 수 없다. **ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.** 따라서 모듈 내에서 var 키워드로 선언한 변수는 더는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

```js
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```

------

## 15장 let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

#### 15.1.1 변수 중복 선언 허용

```js
var x = 1;
var y = 1;

var x = 100;

var y;	//초기화문이 없는 변수 선언문은 무시된다.

console.log(x);	// 100
console.log(y);	// 1
```



#### 15.1.2 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

```js
var x = 1;

if(true){
	var x = 10;
}

console.log(x);	// 10
```

for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다.

```js
var i = 10;

for(var i = 0; i < 5; i++){
	console.log(i);	// 0 1 2 3 4
}

console.log(i)	// 5
```



#### 15.1.3 변수 호이스팅

var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.

```js
console.log(foo);	// undefined

foo = 123;

console.log(foo);	// 123

var foo;
```

변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.



### 15.2 let 키워드

var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드인 let, const를 도입했다.

#### 15.2.1 변수 중복 선언 금지

var 키워드로 변수를 중복 선언하면 에러가 발생하지 않았지만, let 키워드를 사용하면 문법 에러(SyntaxError)가 발생한다.

```js
let bar = 123;
let bar = 456;	// SyntaxError: Identifier 'bar' has already been declared
```



#### 15.2.2 블록 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.

```js
let foo = 1;

{
    let foo = 2;
    let bar = 3;
}

console.log(foo);	// 1
console.log(bar);	// ReferenceError: bar is not defined
```



#### 15.2.3 변수 호이스팅

var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```js
console.log(foo);	// ReferenceError: foo is not defined
let foo;
```

var 키워드로 선언된 변수는 선언 단계와 초기화 단계(undefined)가 같이 실행됐지만 **let 키워드로 선언한 변수는 "선언 단계"와 "초기화 단계"가 분리되어 진행된다.** 만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없다. 이 구간을 **일시적 사각지대**라고 부른다.

```js
console.log(foo);	// ReferenceError: foo is not defined

let foo;
console.log(foo);	// undefined

foo = 1;
console.log(foo);	// 1
```

let 키워드는 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않다.

```js
let foo = 1;

{
    console.log(foo);	//ReferenceError: Cannot access 'foo' before initialization
    let foo = 2;
}
```

만약 let 키워드가 호이스팅을 하지 않는다면 위 예제는 전역변수 foo 의 값 1을 출력했어야 하지만 호이스팅이 발생하기 때문에 ReferenceError가 발생하였다.



#### 15.2.4 전역 객체와 let

var 키워드로 선언한 전역 변수와 전역 함수, 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.

```js
//브라우저에서 실행해야 한다.
var x = 1;
y = 2;
function foo (){}

console.log(window.x);	// 1
console.log(x);			// 1

console.log(window.y);	// 2
console.log(y);			// 2

console.log(window.foo);// foo() {}
console.log(foo);		// foo() {}
```

let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. let 전역 변수는 보이지 않는 개념적인 블록 내에 존재하게 된다.

```js
//브라우저에서 실행해야 한다.
let x = 1;

console.log(window.x);	// undefined
console.log(x);			// 1
```



### 15.3 const 키워드

const 키워드는 상수를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. const 키워드의 특징은 let 키워드와 대부분 동일하니 다른 점을 알아보자.



#### 15.3.1 선언과 초기화

**const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.**

```js
const foo = 1;

const bar;	//SyntaxError: Missing initializer in const declaration
```



#### 15.3.2 재할당 금지

**const 키워드로 선언한 변수는 재할당이 금지 된다.**

```js
const foo = 1;
foo = 2;	// TypeError: Assignment to constant variable.
```



#### 15.3.3 상수

const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다. 원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다.

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.

```js
//세전 가격
let preTaxPrice = 100;

//세후 가격
//0.1의 의미를 명확히 알기 어렵다
let afterTaxPrice = preTaxPrice + (preTaxPrice * 0.1);

console.log(afterTaxPrice);
```

일반적으로  상수의 이름은 대문자로 선언해 상수임을 명확히 나타낸다. 여러 단어로 이뤄진 경우에는 스네이크 케이스로 표현하는 것이 일반적이다.

```js
const TAX_RATE = 0.1;

let preTaxPrice = 100;

let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);

console.log(afterTaxPrice);	// 110
```



#### 15.3.4 const 키워드와 객체

**const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.** 원시 값은 재할당 없이 변경할 수 있는 방법이 없지만 객체는 재할당 없이도 직접 변경이 가능하기 때문이다.

```js
const person = {
	name: 'Lee',
};

person.name = "Kim";

console.log(person);	// {name: 'Kim'}
```

**const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않는다.** 객체를 변경하더라도 변수에 할당된 참조 값을 변화시키지는 않기 때문에 객체는 변경 가능하다.



### 15.4 var vs let vs const

변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. var와 let, const 키워드는 다음과 같이 사용하는 것을 권장한다.

- ES6를 사용한다면 var 키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.

------

## 16장 프로퍼티 어트리뷰트

### 16.1 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다. EMCAScript 사양에 등장하는 이중 대괄호로 감싼 이름들이 내부 슬롯과 내부 메서드다.

내부 슬롯과 내부 메서드는 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아니다. 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.

그 예로 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 내부 슬롯은 원칙적으로 직접 접근할 수 없지만 [[Prototype]] 내부 슬롯의 경우, `__proto__`를 통해 간접적으로 접근할 수 있다.

```js
const o = {};

o.[[Prototype]]	//직접 접근은 불가
o.__proto__	// Object.prototype
```



### 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

**자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.** 프로퍼티의 상태란 프로퍼티의 값, 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다.

프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬롯 [[Value]], [[Writable]], [[Enumberable]], [[Configurable]]이다. 따라서 직접 접근은 불가능하지만 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.

```js
const person = {
    name: 'Lee'
};

console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// {value: "Lee", writable: true, enumerable: ture, configurable: true}
```



### 16.3 데이터 프로퍼티와 접근자 프로퍼티

프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.

- 데이터 프로퍼티

  키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.

- 접근자 프로퍼티

  자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 떄 호출되는 접근자 함수로 구성된 프로퍼티다.



#### 16.3.1 데이터 프로퍼티

데이터 프로퍼티는 다음과 같은 어트리뷰트를 갖는다.

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터객체의 프로퍼티 | 설명                                                         |
| ------------------- | ---------------------------------- | ------------------------------------------------------------ |
| [[Value]]           | value                              | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.<br />프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다. |
| [[Writable]]        | writable                           | 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.  |
| [[Enumerable]]      | enumerable                         | 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.<br />[[Enumerable]]의 값이 false인 경우 해당 프로퍼티는 for ... in 문이나 Object.key 메서드 등으로 열거할 수 없다. |
| [[Configurable]]    | configurable                       | 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.<br />[[Configurable]]의 값이 false인 경우 해당 프로퍼티의 삭제, 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. |



#### 16.3.2 접근자 프로퍼티

접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 떄 사용하는 접근자 함수로 구성된 프로퍼티다.

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                         |
| ------------------- | ----------------------------------- | ------------------------------------------------------------ |
| [[Get]]             | get                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 합수다.<br />접근자 프로퍼티 키로 프로퍼티 값에 접근하면 getter 함수가 호출되고 그 결과가 반환된다. |
| [[Set]]             | set                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다.<br />접근자 프로퍼티 키로 프로퍼티 값을 저장하면 setter 함수가 호출되고 그 결과가 반환된다. |
| [[Enumberable]]     | enumberable                         | 데이터 프로퍼티의 [[Enumerable]]과 같다.                     |
| [[Configurable]]    | configurable                        | 데이터 프로퍼티의 [[Configurable]]과 같다.                   |

접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.

```js
const person = {
    firstName: 'Ungmo',
    lastName: 'Lee',
    
    get fullName(){
        return `${this.firstName} ${this.lastName}`;
    },
    set fullName(name){
        [this.firstName, this.lastName] = name.split(' ');
    }
};

//데이터 프로퍼티를 통한 프로퍼티 값의 참조
console.log(person.firstName + ' ' + person.lastName);	// Ungmo Lee

//접근자 프로퍼티를 통한 프로퍼티 값의 저장
person.fullName = 'Heegun Lee';

//접근자 프로퍼티를 통한 프로퍼티 값의 참조
console.log(person.fullName)	//Heegun Lee
```

접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메서드가 호출되어 다음과 같이 동작한다.

1. 프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심벌이어야 한다.
2. 프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다.
3. 검색된 fullName프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName은 접근자 프로퍼티다.
4. fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다.



### 16.4 프로퍼티 정의

프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하고나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 의미한다. Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다.

```js
const person = {};

Object.defineProperty(person, 'firstName', {
    value: 'Ungmo',
    writable: true,
    enumerable: true,
    configurable: true,
});

Object.defineProperty(person, 'lastName', {
    value: 'Lee'
});

let discriptor = Ojbect.getOwnPropertyDescriptor(person, 'firstName');
console.log('firstName', descriptor);
// firstName {value: "ungmo", writable: true, enumerable: ture, configurable: true}

//디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.
descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');
console.log('lastName', descriptor);
//lastName {value: "Lee", writable: false, enumerable: false, configurable: false}

//[[Enumerable]]의 값이 false인 경우 나열되지 않는다
console.log(Object.keys(person));	//["firstName"]

//[[Writable]]의 값이 false인 경우 해당 프로퍼티의 값을 변경할 수 없다.
person.lastName = 'Kim';

//[[Configurable]]의 값이 false인 경우 해당 프로퍼티를 삭제할 수 없다.
delete person.lastName;

//[[Configurable]]의 값이 false인 경우 해당 프로퍼티를 재정의할 수 없다.
Object.defineProperty(person, 'lastName', { enumerable: ture });
//Uncaught TypeError: Cannot redefine property: lastName

//접근자 프로퍼티 정의
Object.defineProperty(person, 'fullName', {
    //getter 함수
    get (){
        return `${this.firstName} ${this.lastName}`;
    },
    //setter 함수
    set (name){
        [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable: ture,
    configurable: true
});

person.fullName = 'Heegun Lee';
console.log(person);	//{firstName: "Heegun", lastName: "Lee"}
```

프로퍼티 디스크립터 객체에서 생략된 어트리뷰트는 다음과 같이 기본값이 적용된다.

| 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본값 |
| ----------------------------------- | ---------------------------- | -------------------- |
| value                               | [[Value]]                    | undefined            |
| get                                 | [[Get]]                      | undefined            |
| set                                 | [[Set]]                      | undefined            |
| writable                            | [[Writable]]                 | false                |
| enumerable                          | [[Enumberable]]              | false                |
| configurable                        | [[Configurable]]             | false                |

Ojbect.defineProperty 메서드는 한번에 하나의 프로퍼티만 정의할 수 있다. Object.defineProperties 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.

```js
const person = {};

Object.defineProperties(person, {
    firstName: {
        value: 'Ungmo',
        writable: true,
        enumerable: true,
        configurable: true
    },
    lastName: {
        value: 'Lee',
        writable: ture,
        enumerable: true,
        configurable: true
    },
    //접근자 프로퍼티 정의
    fullName: {
        get() {
            return `${this.firstName} ${this.lastName}`
        },
        set(name){
            [this.firstName, this.lastName] = name.split(" ");
        },
        enumerable: true,
        configurable: true
    }
});

person.fullName = 'Heegun Lee';
console.log(person);	//{firstName: "Heegun", lastName: "Lee"}
```



### 16.5 객체 변경 방지

객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다. 프로퍼티를 추가하거나 삭제하고, 값을 갱신할 수 있으며, Object.defineProperty 또는 Object.defineProperties 메서드를 사용하여 프로퍼티 어트리뷰트를 재정의 할 수도 있다.

자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다. 객체 변경 방지 메서드들은 객체의 변경을 금지하는 강도가 다르다.

| 구분           | 메서드                   | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
| -------------- | ------------------------ | ------------- | ------------- | ---------------- | ---------------- | -------------------------- |
| 객체 확장 금지 | Object.preventExtensions | X             | O             | O                | O                | O                          |
| 객체 밀봉      | Object.seal              | X             | X             | O                | O                | X                          |
| 객체 동결      | Object.freeze            | X             | X             | O                | X                | X                          |



#### 16.5.1 객체 확장 금지

Object.preventExtensions 메서드는 객체의 확장을 금지한다. 이것은 프로퍼티 추가 금지를 의미한다. 프로퍼티 동적 추가와 Object.defineProperty 메서드 모두 금지된다.

확장이 가능한 객체인지 여부는 Object.isExtensible 메서드로 확인할 수 있다.



#### 16.5.2 객체 밀봉

Object.seal 메서드는 객체를 밀봉한다. 객체 밀봉이란 프로퍼티 추가 및 삭제와 어트리뷰트 재정의 금지를 의미한다. 즉, **읽기와 쓰기만 가능하다.**

밀봉된 객체인지 여부는 Object.isSealed 메서드로 확인할 수 있다.



#### 16.5.3 객체 동결

Object.freeze 메서드는 객체를 동결한다. 객체 동결이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉, **읽기만 가능하다.**

동결된 객체인지 여부는 Object.isFrozen 메서드로 확인할 수 있다.



#### 16.5.4 불변 객체

지금까지 살펴본 변경 방지 메서드들은 얕은 변경 방지로 중첩 객체까지 영향을 주지 못한다. 객체의 중첩 객체까지 영향을 주려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 변경 방지 메서드를 호출해주어야 한다.

```js
function deepFreeze(target) {
    if(target && typeof target === 'object' && !Object.isFrozen(target)){
        Object.freeze(target);
        
        Object.keys(target).forEach(key => deepFreeze(target[key]));
    }
    return target;
}

const person = {
    name: 'Lee',
    address: {city: 'Seoul'}
};

deepFreeze(person);

console.log(Object.isFrozen(person));	//true
console.log(Object.isFrozen(person.address));	//true

person.address.city = 'Busan';
console.log(person);	//{name: 'Lee', address: {city: 'Seoul'}}
```

------

## 17장 생성자 함수에 의한 객체 생성

생성자 함수에 의한 객체 생성 방식을 한번 알아보자.

### 17.1 Object 생성자 함수

new 연산자와 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후로 프로퍼티 또는 메서드를 추가할 수 있다.

```js
//빈 객체 생성
const person = new Object();

//프로퍼티 추가
person.name = 'Lee';
person.sayHello = function() {
    console.log(`Hi! My name is ${this.name}`);
};

console.log(person);	// {name: 'Lee', sayHello: f}
person.sayHello();
```

생성자 함수란 new 연산자와 함꼐 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.



### 17.2 생성자 함수

#### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 이러한 방식은 단 하나의 객체만 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 떄문에 비효율적이다.

```js
const circle1 = {
    radius: 5,
    getDiameter() {
        return 2 * this.radius;
    }
};

console.log(circle1.getDiameter());	// 10

const circle2 = {
    radius: 10,
    getDiameter() {
        return 2 * this.radius;
    }
};

console.log(circle2.getDiameter());	// 20
```

circle1과 circle2 객체의 프로퍼티 구조는 동일하다. 객체 고유의 상태 데이터인 radius는 객체마다 다를 수 있지만 getDiameter 메서드는 완전히 동일하다. 이처럼 객체 리터럴에 의해 객체를 생성할 경우 프로퍼티가 동일함에도 매번 같은 프로퍼티와 메서드를 기술해야 한다. 만약 객체를 수십개 생성해야 한다면 문제가 발생한다.



#### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

```js
//생성자 함수
function Circle(radius) {
    // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.
	this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
}

const circle1 = new Circle(5);
const circle2 = new Circle(10);

console.log(circle1.getDiameter());	// 10
console.log(circle2.getDiameter());	// 20
```

생성자 함수는 이름 그대로 객체를 생성하는 함수다. 하지만 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.

```js
const circle3 = Circle(15);

// Circle이 일반 함수로 호출 되었다. Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.
console.log(circle3);	// undefined

// 일반 함수로 호출된 Circle 내의 this는 전역 객체를 가리킨다.
console.log(radius);	// 15
```



#### 17.2.3 생성자 함수의 인스턴스 생성 과정

생성자 함수의 역할은 인스터스를 생성하는 것과 생성된 인스턴스를 초기화 하는 것이다. 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스를 초기화하는 것은 옵션이다.

```js
function Circle(radius){
    this.radius = radius;
    this.getDiameter = function (){
        return 2 * this.radius;
    };
}

const circle1 = new Circle(5);
```

생성자 함수 내부의 코드를 살펴보면 전달된 인수를 할당하여 초기화 하는 부분은 있지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다. 자바스크립트 엔진이 암묵적인 처리를 통해 인스턴스를 생성하고 반환하기 때문이다.



##### 1. 인스턴스 생성과 this 바인딩

암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스다. 그리고 인스턴스는 this에 바인딩된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. 이 처리는 런타임 이전에 실행된다.

```js
function Circle(radius) {
    // 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    console.log(this)	// Circle {}
    
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
}
```



##### 2. 인스턴스 초기화

생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되에 this에 바인딩되어 있는 인스턴스를 초기화한다. 이 처리는 개발자가 기술한다.

```js
function Circle(radius) {
    // 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    
    // this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
}
```



##### 3. 인스턴스 반환

생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.

```js
function Circle(radius) {
    // 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    
    // this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
    
    // 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
}

// 인스턴스 생성
const circle = new Circle(1);
```

만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 아니라 return 문에 명시한 객체가 반환된다.

```js
function Circle(radius) {
    // 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    
    // this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
    
    // 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
    // 명시적으로 객체를 반환하면 this 반환이 무시된다.
    return {};
}

// 인스턴스 생성
const circle = new Circle(1);	// {}
```

하지만 원시 값을 반환하면 원시 값 반환이 무시된다.

```js
function Circle(radius) {
    // 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
    
    // this에 바인딩되어 있는 인스턴스를 초기화한다.
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * this.radius;
    };
    
    // 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
    // 명시적으로 원시값을 반환하면 this가 반환된다.
    return 100;
}

// 인스턴스 생성
const circle = new Circle(1);
```



#### 17.2.4 내부 메서드 [[Call]]과 [[Construct]]

함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수도 있고 생성자 함수로서도 호출할 수 있다.

함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기때문이다.

```js
function foo(){}

// 객체이기 때문에 프로퍼티를 소유할 수 있다.
foo.prop = 10;

// 객체이기 때문에 메서드를 소유할 수 있다.
foo.method = function () {
    console.log(this.prop);
};

foo.method();	// 10
```

함수와 일반 객체의 차이점은 함수는 호출할 수 있다는 것이다. 따라서 함수 객체는 일반 객체가 가지고 있는 내부 슬롯, 메서드에 함수 객체를 위한 내부 슬롯과 내부 메서드를 추가로 가지고 있다.

함수가 일반 함수로 호출되면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.

```js
function foo() {}

// 일반적인 함수로서 호출: [[Call]]이 호출된다.
foo();

// 생성자 함수로서 호출: [[Construct]]가 호출된다.
new foo();
```

내부 메서드  [[Call]]을 가지는 함수 객체를 callable이라 하며, [[Construct]]를 갖는 객체를 constructor, [[Construct]]를 갖지 않는 객체를 non-constructor라 부른다. 함수는 호출할 수 있으니 반드시 callable이어야 한다. 하지만 constructor일 수도 non-constructor일 수도 있다.



#### 17.2.5 constructor와 non-constructor의 구분

자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 두 가지로 구분한다.

- constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
- non-constructor: 메서드(ES6 메서드 축약 표현), 화살표 함수

EMCAScript 사양에서 메서드로 인정하는 범위는 일반적인 의미의 메서드보다 좁다.

```js
// 일반 함수 정의: 함수 선언문, 함수 표현식
function foo() {}
const bar = function () {};
//프로퍼티 x의 값으로 일반 함수로 정의된 함수가 할당되었다. 이는 메서드로 인정하지 않는다.
const baz = {
    x: function () {}
};

// 일반 함수로 정의된 함수만이 constructor다.
new foo();	// foo {}
new bar();	// bar {}
new baz.x();// x {}

// 화살표 함수 정의
const arrow = () => {};

new arrow();	// TypeError: arow is not a constructor

//메서드 정의: ES6의 메서드 축약 표현만 메서드로 인정한다.
const obj = {
    x() {}
};

// 메서드기 때문에 생성자 함수로 사용 불가능하다.
new obj.x();	// TypeError: obj.x is not a constructor
```



#### 17.2.6 new 연산자

일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자를 붙이면 해당 함수가 생성자 함수로 동작하게 된다. 단, new 연산자와 함께 호출하는 함수는 constructor여야 한다.

```js
function add(x, y){
    return x + y;
}

let inst = new add();

// 반환문이 객체가 아니니 빈 객체가 생성되어 반환된다.
console.log(inst);	// add {}

function createUser(name, role){
    return {name, role};
}

inst = new createUser('Lee', 'admin');

console.log(inst);	// { name: 'Lee', role: 'admin' }
```



#### 17.2.7 new.target

생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다.

new.target은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라 부른다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다. **new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리키고, 일반 함수로 호출되면 new.target은 undefined다.**

```js
function Circle(radius) {
    if(!new.target){
        return new Circle(radius);
    }
    this.radius = radius;
    this.getDiameter = function () {
        return 2 * this.radius;
    };
}

// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.
const circle = Circle(5);
console.log(circle.getDiameter());
```

------

## 18장 함수와 일급 객체

### 18.1 일급 객체

다음과 같은 조건을 만족하는 객체를 일급 객체라 한다.

1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.

자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체다.

```js
// 1.함수는 무명의 리터럴로 생성할 수 있다.
// 2.함수는 변수에 저장할 수 있다.
// 런타임에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.
const increase = function (num) {
    return ++num;
};

const decrease = function (num) {
    return --num;
};

// 2. 함수는 객체에 저장할 수 있다.
const auxs = { increase, decrease };

// 3. 함수의 매개변수에 전달할 수 있다.
// 4. 함수의 반환값으로 사용할 수 있다.
function makeCounter(aux) {
    let num = 0;
    
    return function() {
        num = aux(num);
        return num;
    };
}

// 3.함수는 매개변수에게 함수를 전달할 수 있다.
const increaser = makeCounter(auxs.increase);
console.log(increaser());
console.log(increaser());

// 3.함수는 매개변수에게 함수를 전달할 수 있다.
const increaser = makeCounter(auxs.decrease);
console.log(decreaser());
console.log(decreaser());
```

함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳이라면 어디서든지 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.

일급 객체로서 함수가 가지는 가장 큰 특징은 일반 객체와 같이 함수의 매개변수에 전달할 수 있으며, 함수의 반환값으로 사용할 수도 있다는 것이다.



### 18.2 함수 객체의 프로퍼티

console.dir 메서드를 사용하여 함수 객체의 내부를 들여다보자.

```js
function square(number) {
	return number * number;
}

console.dir(square);
```

![예제 18-02](C:\Users\Sanghyun\Desktop\JavascriptWorkspace\javascript-study\18-02.png)

square 함수의 모든 프로퍼티를 Object.getOwnPropertyDescriptors 메서드로 확인해보면 다음과 같다.

```js
console.log(Object.getOwnPropertyDescriptors(square));
```

![18-03](C:\Users\Sanghyun\Desktop\JavascriptWorkspace\javascript-study\18-03.png)

arguments, caller, length, name, prototype 프로퍼티는 모두 일반 객체에는 없는 함수 객체 고유의 프로퍼티다. 하지만 `__proto__`는 접근자 프로퍼티이며, Object.prototype 객체의 프로퍼티를 상속받은 것이다.



#### 18.2.1 arguments 프로퍼티

함수 객체의 arguments 프로퍼티 값은 arguments 객체다. 이 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역변수처럼 사용된다. 함수 외부에서는 참조할 수 없다.

함수 객체의 arguments 프로퍼티는 현재 일부 브라우저에서 지원하고 ES3부터 표준에서 폐지되었다. 따라서 Function.arguments와 같은 사용법은 권장되지 않으며 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다.

자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 따라서 함수 호출 시 매개변수의 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않는다.

```js
function multiply(x, y) {
    console.log(arguments);
    return x * y;
}

console.log(multiply());		// NaN
console.log(multiply(1));		// NaN
console.log(multiply(1, 2));	// 2
console.log(multiply(1, 2, 3));	// 2
```

함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.

선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 전달되지 않은 매개변수는 undefined로 초기화 된 상태를 유지한다. 인수를 더 많이 전달한 경우 초과된 인수는 무시된다. 초과된 인수가 그냥 버려지는 것은 아니다. 모든 안수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.

![image-20220125164713873](C:\Users\Sanghyun\AppData\Roaming\Typora\typora-user-images\image-20220125164713873.png)

arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다. arguments 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수(함수 자신)를 가리키고 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다.

arguments 객체는 매개변수 개수를 확정할 수 없는 **가변 인자 함수**를 구현할 때 유용하다.

```js
function sum() {
	let res = 0;
    
    //arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.
    for(let i = 0; i < arguments.length; i++){
        res += arguments[i];
    }
    
    return res;
}

console.log(sum());			// 0
console.log(sum(1, 2));		// 3
console.log(sum(1, 2, 3));	// 6
```

유사 배열 객체는 배열이 아니므로 배열 메서드를 사용할 경우 에러가 발생한다. 따라서 배열 메서드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해 간접 호출해야 하는 번거로움이 있다.

```js
function sum() {
	// arguments 객체를 배열로 변환
    const array = Array.prototype.slice.call(arguments);
    return array.reduce(function (pre, cur) {
        return pre + cur;
    }, 0);
}

console.log(sum(1, 2));
console.log(sum(1, 2, 3, 4, 5));
```

이러한 번거로움을 해결하기 위해 ES6에서는 Rest 파라미터를 도입했다.

```js
function sum(...args) {
    return args.reduce((pre, cur) => pre + cur), 0);
}

console.log(sum(1, 2));
console.log(sum(1, 2, 3, 4, 5));
```



#### 18.2.2 caller 프로퍼티

caller 프로퍼티는 ECMAScript 사양에 포함되지 않은 비표준 프로퍼티다. 이후 표준화될 예정도 없으니 지나쳐도 된다.

함수 객체의 caller 프로퍼티는 함수 자신을 호출한 함수를 가리킨다.



#### 18.2.3 length 프로퍼티

함수 객체의 length 프로퍼티는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.

```js
function foo() {}
console.log(foo.length);	// 0

function bar(x) {
    return x;
}
console.log(bar.length);	// 1

function baz(x, y) {
    return x * y;
}
console.log(baz.length);	// 2
```

arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으니 주의해야 한다. arguments 객체의 length는 인자의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수의 개수를 가리킨다.



#### 18.2.4 name 프로퍼티

함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. name 프로퍼티는 ES5와 ES6에서 다르게 동작한다. 익명 함수 표현식의 경우 ES5에서는 빈 문자열을 값으로 갖지만 ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.

```js
// 기명 함수 표현식
var namedFunc = function foo() {};
console.log(namedFunc.name);	// foo

// 익명 함수 표현식
var anonymousFunc = function() {};
// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.
// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.
console.log(anonymousFunc.name);	// anonymousFunc

// 함수 선언문
function bar() {}
console.log(bar.name);	// bar
```



#### 18.2.5 __ proto__ 접근자 프로퍼티

모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. [[Prototype]] 내부 슬롯은 객체지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.

`__proto__` 프로퍼티는 [[Prototype]] 내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티다. 내부 슬롯에 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.

```js
const obj = { a: 1 };

// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.
console.log(obj.__proto__ === Object.prototype);	// true

// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.
// hasOwnProperty 메서드는 Object.prototype의 메서드다. 상속받은 프로퍼티 키인 경우 false를 반환한다.
console.log(obj.hasOwnProperty('a'));			// true
console.log(obj.hasOwnProperty('__proto__'));	//false
```



#### 18.2.6 prototype 프로퍼티

prototype 프로퍼티는 생성자 함수로 호출할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티다.

```js
// 함수 객체는 prototype 프로퍼티를 소유한다.
(function () {}).hasOwnProperty('prototype');	// true

// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.
({}).hasOwnProperty('prototype');				// false
```

------

## 19장 프로토타입

### 19.1 객체지향 프로그래밍

객체지향 프로그래밍은 프로그램을 명령오 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.

"이름"과 "주소"라는 속성을 갖는 person이라는 객체를 자바스크립트로 표현하면 다음과 같다.

```js
// 이름과 주소 속성을 갖는 객체
const person = {
    name: 'Lee',
    address: 'Seoul'
};

console.log(person); // {name: "Lee", address: "Seoul"}
```

이때 프로그래머는 이름과 주소 속성으로 표현된 객체인 person을 다른 객체와 구별하여 인식할 수 있다. 이처럼 객체는 **속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조이다.**

객체지향 프로그래밍은 객체의 **상태**를 나타내는 데이터와 상태 데이터를 조작할 수 있는 **동작**을 하나의 논리적인 단위로 묶어 생각한다.

```js
const circle = {
    // 상태
    radius: 5,
    
    // 동작
    getDiameter() {
        return 2 * this.radius;
    },
    getPerimeter() {
        return 2 * Math.PI * this.radius;
    },
    getArea() {
        return Math.PI * this.radius ** 2;
    }
};
```



### 19.2 상속과 프로토타입

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.

```js
// 생성자 함수
function Circle(radius) {
    this.radius = radius;
    this.getArea = function () {
        return Math.PI * this.radius ** 2;
    };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유한다.
// getArea 메서드는 하나만 생성하여 모든 인스턴스가 공유해서 사용하는 것이 바람직하다.
console.log(circle1.getArea === circle2.getArea);	// false
```

Circle 생성자 함수가 생성하는 모든 객체는 radius 프로퍼티와 getArea 메서드를 갖는다. radius 값은 객체마다 다를 수 있지만, getArea 메서드는 모든 인스턴스가 갖은 내용을 사용하므로 하나만 생성하는 것이 바람직하다(메모리 낭비가 발생한다).

상속을 통해 불필요한 중복을 제거해 보자. **자바스크립트는 프로토타입을 기반으로 상속을 구현한다.**

```js
function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.getArea = function() {
    return Math.PI * this.radius ** 2;
};

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea);	// true
```

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다.

getArea 메서드는 단 하나만 생성되어 Circle.prototype의 메서드로 할당되어 있다. Circle 생성자 함수가 생성하는 모든 인스턴스는 자신의 상태인 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메서드는 상속을 통해 공유하여 사용되는 것이다.

상속은 코드의 재사용이란 관점에서 매우 유용하다. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해 두면 모든 인스턴스는 별도의 구현 없이 상위 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.



### 19.3 프로토타입 객체

프로토타입 객체란 객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조다. [[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다.

예를 들어, 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다.



#### 19.3.1 `__proto__`접근자 프로퍼티

모든 객체는 `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.

##### `__proto__`는 접근자 프로퍼티다

내부 슬롯은 프로퍼티가 아니다. 따라서 자바스크립트는 원칙적으로 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공한다. [[Prototype]] 내부 슬롯도 직접 접근할 수 없으며 `__proto__`접근자 프로퍼티를 통해 간접적으로 프로토타입에 접근할 수 있다.

접근자 프로퍼티는 다른 데이터 프로퍼티 값을 읽거나 저장할 때 사용하는 접근자 함수, 즉 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티다.

Object.prototype의 접근자 프로퍼티인 `__proto__`는 getter/setter 함수라고 부르는 접근자 함수 프로퍼티를 통해 프로토타입을 취득하거나 할당한다.

```js
const obj = {};
const parent = { x: 1 };

// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득
obj.__proto__;

// setter 함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체
obj.__proto__ = parent;

console.log(obj.x);	// 1
```



##### `__proto__` 접근자 프로퍼티는 상속을 통해 사용된다

`__proto__`접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 모든 객체는 상속을 통해 `Object.prototype.__proto__`접근자 프로퍼티를 사용할 수 있다.

```js
const person = { name: 'Lee' };

// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.
console.log(person.hasOwnProperty('__proto__')); // false

// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티다.
console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));
// { get: [Function: get __proto__], set: [Function: set __proto__], enumerable: false, configurable: true }

// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
console.log({}.__proto__ === Object.prototype);	// true
```



##### `__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

[[Prototype]] 내부 슬롯의 값, 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.

```js
const parent = {};
const child = {};

// child의 프로토타입을 parent로 설정
child.__proto__ = parent;
// parent의 프로토타입을 child로 설정
parent.__proto__ = child;	// TypeError: Cyclic __proto__ value
```

프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 또 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 한다. 하지만 위 예제는 순환 참조하는 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 떄문에 프로퍼티 검색에서 무한 루프에 빠진다. 따라서 아무런 체크 없이 무조건적으로 프로토타입을 교체할 수 없도록 `__proto__`접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어 있다.



##### `__proto__`접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다

모든 객체가 `__proto__`를 사용할 수 있는 것은 아니기 때문에 코드 내에서 `__proto__`접근자 프로퍼티를 직접 사용하는 것은 권장하지 않는다.

```js
// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.
const obj = Object.create(null);

console.log(obj.__proto__);	// undefined

//따라서 __proto__보다 Object.getPrototypeOf 메서드를 사용하는 편이 좋다.
console.log(Object.getPrototypeOf(obj)); // null
```

따라서 `__proto__`접근자 프로퍼티 대신 프로토타이의 참조를 취득하고 싶은 경우에는 Object.getPrototypeOf 메서드를 사용하고, 프로토타입을 교체하고 싶은 경우에는 Object.setPrototypeOf 메서드를 사용할 것을 권장한다.



#### 19.3.2 함수 객체의 prototype 프로퍼티

**함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.**

```js
console.log((function () {}).hasOwnProperty('prototype'));	//true

console.log(({}).hasOwnProperty('prototype'));	//false
```

따라서 생성자 함수로서 호출할 수 없는 함수인 non-constructor인 화살표 함수와 ES6 메서드 축약 표현으로 정의한 메서드는  prototype 프로퍼티를 소유하지 않는다.

`__proto__`접근자 프로퍼티와 prototype 프로퍼티는 결국 동일한 프로토타입을 가리키지만 사용 주체가 다르다. 접근자 프로퍼티는 모든 객체가 사용할 수 있지만 prototype 프로퍼티는 생성자 함수만이 사용 가능하다.



#### 19.3.2 프로토타입의 constructor 프로퍼티와 생성자 함수

모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.

```js
function Person(name) {
    this.name = name;
}

const me = new person('Lee');

console.log(me.constructor === Person);	// true
```



### 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

리터럴 표기법에 의해 생성된 객체의 경우 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.

```js
const obj = {};

// 객체 리터럴로 생성한 obj의 constructor 가 Object 생성자 함수이다.
console.log(obj.constructor === Object);	// true

function foo() {}

console.log(foo.constructor === Function);	// true
```

리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요하다. 따라서 리터럴 표기법에 의해 생성된 객체도 가상적인 생성자 함수를 갖는다.

리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 큰 틀에서 생각해 보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다.



### 19.5 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.

#### 19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점

생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
